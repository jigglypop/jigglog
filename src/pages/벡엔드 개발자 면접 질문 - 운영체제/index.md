---
path: '/벡엔드 개발자 면접 질문 - 운영체제/'
category: '기술 면접'
tags: ['벡엔드', '개발자', '면접', '기술면접', 'CS']
title: '벡엔드 개발자 면접 질문 - 운영체제'
date: '2021-11-22T02:00:00.000Z'
summary: '벡엔드 개발자 면접 질문 - 운영체제'
images: ['images/2.jpg']
---

> 백엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요

# 2. 운영체제

---

### 1) 가비지 컬렉터

---

#### (1) 가비지와 가비지 컬렉터

- Garbage : 정리되지 않은 메모리, 유효하지 않은 객체의 메모리
- Garbage collector (GC) : 프로그램이 사용할 수 있는 메모리 용량이 부족할 때 가비지들을 메모리에서 해제하는 기능

#### (2) 메모리

- 메모리 할당 : 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당한다.

- 메모리 사용 : 메모리를 읽고 쓰는 것을 의미. 메모리가 할당된 변수를 사용하면 읽기와 쓰기 작업이 이루어짐

- 메모리 해제 : 더 이상 필요하지 않은 메모리를 해제하여 재사용 할 수 있도록 함

#### (3) 레퍼런스 카운팅(Reference Counting)

- 해당 값이 얼마나 많이 참조되었는지 추적

- 변수를 선언하고 참조값이 할당되면 레퍼런스 카운트는 1이 됨
- 다른 변수가 같은 값을 참조하면 레퍼런스 카운트가 늘어남
- 마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 레퍼런스 카운트가 줄어듦

```javascript
let objectA = {}; // 레퍼런스 카운트 1
let objectB = objectA; // 레퍼런스 카운트 2

objectA = null; // 레퍼런스 카운트 1
objectB = null; // 레퍼런스 카운트 0
```

- 값의 레퍼런스 카운트가 0이 되면 해당 값에 접근할 방법이 없으며 메모리를 회수해도 안전

- 순환 참조 문제 : 객체가 두 개일 때 함수 실행이 끝날 때 두 객체는 모두 스코프를 벗어나게 될 것이고, 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 하지만 함수 실행이 끝난 뒤에도 레퍼런스 카운트가 0이 되지 않으므로 두 객체는 계속 존재

- 이런 함수를 여러 번 호출하면 메모리를 회수하지 못하고 낭비되는 메모리가 많이 늘어남

#### (4) 마크 앤 스위프(Mark and sweep)

- 메모리 해제 여부를 결정하기 위해 루트(roots, 자바스크립트의 `window` 객체)부터 해당 객체까지 닿을 수 있는지를 판단

- 루트부터 시작하여 루트가 참조하는 객체들과 그 객체가 참조하는 또 다른 객체들을 추적

- 객체를 추적하면서 닿을 수 있는 객체는 표시(mark) 한 후, 표시가 없는 객체들은 메모리를 해제(sweep)

### 2) Call-by-value, Call-by-reference, Call-by-assignment

---

#### (1) call-by-value(cbv):

- 변수의 *값*을 복사하여 함수의 인자로 전달
- 복사된 인자는 함수 내에서만 사용되는 local variable의 특성을 가짐
- 함수 안에서 인자의 값이 변경되어도 외부의 변수의 값은 변경되지 않음

#### (2) call-by-reference(cbr)

- 변수의 *주소값*을 복사하여 함수의 인자로 전달
- 함수 안에서 값이 인자의 값이 변경된다면 전체 코드에서 해당 변수의 값이 변경

#### (3) call-by-assignment (cba)(python)

- 전달받는 객체에 따라 참조 방식이 결정.
- immutable object : (int, float, tuple)이 함수의 인자로 넘어갈 땐 call-by-value로 전달
- mutable object : (list, dic, set)이 함수의 인자로 넘어갈 땐 call-by-reference로 전달
- list, dic, set이 mutable object 인 이유 : 객체의 크기가 아주 큰 경우 복사 참조만 된다면 메모리 공간이 낭비

### 3) 가상 메모리와 페이지 폴트

---

#### (1) 가상 메모리

- 프로그램 실행에 필요한 메모리 용량 전체를 RAM에서 할당받는 것이 아니라, 최소한의 메모리를 RAM에서 할당받아 저장하고 나머지는 HDD (가상 메모리 공간)에 저장하는 것
- 요구 페이징 : 페이지 폴트가 발생하면 운영 체제가 가상 메모리에서 해당 페이지를 찾아 물리 메모리의 불필요한 페이지와의 교체를 요구. 그리고 이 과정 동안은 모든 스레드가 대기

#### (3) 페이지 교체 알고리즘

- 요구 페이징이 발생했을 때 교체할 물리 메모리의 페이지를 선정하는 알고리즘

- `FIFO (First In First Out)` : 물리 메모리에 적재된지 가장 오래된 페이지를 교체. 페이지의 사용 빈도를 무시하기 때문에 활발하게 사용하는 페이지가 교체될 수 있다는 문제점이 있음. 페이지가 적재된 순서를 Queue에 저장하는 방식을 사용
- `LRU (Least Recently Used)` : 가장 오랜 기간 사용되지 않은 페이지를 교체. 많은 운영체제가 사용하는 알고리즘
- `LFU (Least Frequently Used)` : 참조 횟수가 가장 적은 페이지를 교체. 만약 교체 대상이 여러 개일 경우에 LRU를 사용LFU는 초기에 한 페이지를 집중적으로 참조하다가 이후에 참조하지 않는 경우에 메모리에 계속 남아있을 수 있음
- `MFU (Most Frequently Used)` : LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘

#### (4) 메모리 단편화 (Memory Fragmentation)

- 내부 단편화 : 교체된 페이지의 크기 < 할당된 공간의 크기
- 외부 단편화 : 교체된 페이지의 크기 > 할당된 공간의 크기

#### (5) 페이징과 세그먼테이션

- 메모리 단편화를 해결할 수 있는 기법

- 페이징
  - 페이지가 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 방법
  - 가상 메모리는 페이지, 물리 메모리는 프레임이라는 고정 크기의 블록으로 나눈 후, 페이지 테이블의 매핑을 통해 1:1 대응
  - 페이지 단위를 작게하면 내부 단편화(Internal fragmentation) 역시 해결할 수 있지만 페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에 그 만큼 page mapping 과정이 증가
- 세그멘테이션

  - method, function, object, variables 등 프로그램의 논리적 단위를 바탕으로 서로 다른 크기의 블록으로 나누는 방법
  - 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법
  - 각 세그먼트 별로 길이 값을 가지고 있어 내부 단편화를 해결

### 4) 프로세스와 스레드

---

#### (1) 프로세스

- _실행 중인 프로그램_
- 운영체제로부터 자원을 할당. 한 프로세스 안에 여러개의 스레드가 생성될 수 있음
- 운영체제로부터 프로세서, 주소 공간, 메모리과 같은 시스템 자원을 할당받는 작업의 단위로 실행된 프로그램
- 프로세스는 실행될 때 운영 체제로부터 독립된 메모리 영역 (Code, Data, Heap, Stack)을 할당
- 다른 프로세스의 자원에는 접근할 수 없음

#### (2) 프로세스 관련 용어

- PCB : 프로세스 제어 블록, 프로세스에 대한 중요한 정보를 저장
- PC : 프로그램 카운터, 프로세스 실행을 위한 다음 명령의 주소를 표시
- 캐시메모리 : 자주 사용되는 데이터가 저장되는 공간으로 CPU의 레지스터와 메모리 사이에서 병목 현상을 완화하는 장치

#### (3) 스레드

- _실행 부분만 분리한 것_
- 프로세스 내에서 동작되는 실행의 단위
- Stack 외에 프로세스가 할당받은 자원 (Code, Data, Heap)을 스레드끼리 공유하면서 실행
- 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠름
- 자원 공유로 인해 문제가 발생할 수 있음
- 하나의 프로세스가 실행되면 기본적으로 하나의 메인 스레드가 생성

#### (4) 멀티 프로세스

- 하나의 프로그램을 프로세스 여러 개로 구성하여 Context switching을 통해 실행하는 것
- 하나의 프로세스에 문제가 생기더라도 다른 프로세스에 영향을 미치지 않음

#### (5) 멀티 스레드

- 하나의 프로그램을 한 프로세스 내에 여러 개의 스레드로 구성하여 실행하는 것
- 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것

- 장점
  - 멀티 프로세스에 비해 메모리 자원소모가 줄어듬
  - 힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단
  - 스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠름
- 단점
  - 힙 영역에 있는 자원을 사용할 때는 동기화를 해야 함
  - 동기화를 위해서 락을 과도하게 사용하면 성능이 저하
  - 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료

#### (6) Thread-safe

- 두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미
- java.util.concurrent 패키지 하위의 클래스를 사용
- 인스턴스 변수를 두지 않음
- Singleton 패턴을 사용(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않습니다.)
- 동기화(syncronized) 블럭에서 연산을 수행

#### (7) ThreadLocal

- 스레드 내부에서 사용되는 지역변수

- 각각의 thread scope 내에서 공유되어 사용될 수 있는 값으로 다른 스레드에서 공유 변수에 접근할 시 발생할 수 있는 동시성 문제의 예방을 위해 만들어짐

#### (8) 컨텍스트 스위칭

- _한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법_

- 프로세서가 멀티 프로세싱을 구성하여 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 기존 프로세스의 상태 또는 레지스터 값 (context)을 저장하고 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업.

- 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작

- CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하 원인

- 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭 가능

- 멀티 프로세싱을 Computer multitasking을 통해 빠른 속도로 Task를 바꿔 가며 실행하여 실시간 처리에 근사하도록 하는 기술

#### (9) 프로세스 동기화

- 다중 프로세스 환경에서 자원등에 한 프로세스만이 접근가능하도록 하는 것
- 프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 존재

- 경쟁 상태(Race Condition)

  - 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황
  - 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황

- 임계 구역(Critical Section)

  - 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭
  - 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능
  - 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용

- 임계 구역 문제를 해결하기 위한 조건

  - 상호 배제(Mutual Exclusion): 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.
  - 진행(Progress): 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.
  - 유한 대기(Bounded Waiting): 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)

### 5) 동기, 비동기 / 블로킹/논블로킹

---

#### (1) 동기(Synchronous) 방식

- _요청과 결과가 동시에 일어남_
- 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식
- 동기 방식은 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같음

#### (2) 비동기(Asynchronous) 방식

- _요청한 그 자리에서 결과가 주어지지 않음_
- 여러 개의 처리가 함께 실행되는 방식
- 동기 방식에 비해 단위시간 당 많은 작업을 처리할 수 있음
- CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있고 프로그램의 복잡도도 증가

#### (3) 블로킹 / 논블로킹 방식

- 블로킹 : 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있음
- 논블로킹 : 대상의 작업 완료여부와 상관없이 새로운 작업을 수행

#### (4) 동기 논블로킹

- 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생

### 6) RISC와 CISC

---

#### (1) RISC(Reduced Instruction Set Computer)

- 축소 명령어 세트 컴퓨터(명령어의 개수가 적은 것)
- 핵심적인 명령어를 기반으로 최소한의 명령어 세트를 구성함으로써 파이프라이닝 이라는 획기적인 기술을 도입할 수 있어 빠른 동작 속도와 하드웨어의 단순화와 효율화를 시킬 수 있었고, 가격 경쟁력에서도 우위를 점함

- 특징
  - 적은 명령어 세트
  - 간단한 명령어로 빠른 실행속도
  - 고정적인 명령어 길이
  - 워드, 데이터 버스 크기가 동일하고 실행 사이클도 모두 동일
  - 회로 구성이 단순
  - 프로그램을 구성할 때 상대적으로 많은 명령어가 필요
  - 파이프 라이닝을 사용함
  - 명령어 개수가 적어서 컴파일러가 단순하게 구현

#### (2) CISC(Complex Instruction Set Computer)

- 연산을 처리하는 복잡한 명령어(명령어가 할 수 있는 일의 양이 RISC 대비하여 많다는 것)들을 수백개 이상 탑재하고 있는 프로세서
- CISC는 명령어 개수 증가에 따라 프로세서 내부구조가 매우 복잡해지고, 고속으로 작동되는 프로세서를 만들기 힘들어짐
- 명령어마다 길이가 다르고 실행에 필요한 사이클 수도 다르기 때문에 파이프 라이닝설계가 어려움
- 특징

  - 명령어의 개수가 많음
  - 명령어 길이가 다양하며, 실행 사이클도 명령어 마다 다름
  - 회로구성이 복잡함
  - 프로그램을 만들 때 적은 명령어로 구현 가능
  - 다양한 명령어를 사용하기 때문에 컴파일러가 복잡

- 사용 이유

  - 아직 너무도 많은 프로세서가 CISC 모델로 구축되어 있고 이것을 전부 바꾸는 것은 비용이 큼

  - CISC 성능의 취약점은 RISC와 같은 파이프라인을 일부 사용하고 집적도는 더 높임으로써 부분적으로 보완이 가능

  - RISC에 비해 호환성이 좋음

### 7) 교착상태(Deadlock)

---

- 서로 다른 프로세스가 서로의 자원을 요구하며 무한정 기다리는 현상

#### (1) 상호배제 (Mutual exclusion)

- 한번에 한 프로세스만이 자원을 점유할 수 있음
- 하나의 프로세스가 자원을 사용할 경우 다른 프로세스는 그 자원을 사용할 수 없는 것

#### (2) 점유와 대기, 보유 및 대기(Hold and wait)

- 프로세스가 이미 자원을 점유하는 상태에서 다른 자원을 무한정 기다림
- 프로세스가 자신이 가질 수 있는 자원은 가지고 있으면서 다른 자원이 오기를 기다리고 있는 것

#### (3) 비선점(No Preemption)

- 프로세스가 어떤 자원의 점유를 끝낼 때까지 그 자원을 뺏을 수 없음
- CPU 할당뿐만 아니라 모든 자원에 의해서 비선점이 된다는 것
- 임의의 프로세스가 자원을 할당 받은 상태에서 다른 프로세스는 이 자원을 뺏어서 사용할 수 없는 형태

#### (4) 환형대기(Circular wait)

- 각 프로세스들이 원형으로 구성되어 순환적으로 자원을 요구

- 선형이 아니고 원형을 이루게 되어 프로세스의 자원 할당에서 첫 번째 프로세스와 마지막 프로세스의 자원할당이 겹치게 되어 원형에 있는 모든 프로세스가 자원 할당을 받고자 기다리는 형태가 만들어지는 것

#### (2) 교착 상태 해결방법

- 예방 : 4가지 조건 중 하나라도 만족되지 않도록 함
- 회피 : 알고리즘을 데드락이 발생하지 않도록 함
- 회복 : 교착상태가 발생할 때 해결
- 무시 : 회복과정의 성능저하가 심하다면 그냥 무시

#### (3) 기아상태(Starvation)

- 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우

- 우선순위를 수시로 변경하거나 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용

### 8) 세마포어와 뮤텍스

---

- 뮤텍스와 세마포어 : 다수의 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 제어하는 것

#### (1) 세마포어

- _여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식_
- 뮤텍스가 될 수 있음
- 다른 프로세스가 세마포어를 해제할 수 있음
- 현재 공유 자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두는 상호 배제 기법.
- 그 값만큼 동시에 스레드가 해당 공유 자원에 접근 가능

#### (2) 뮤텍스

- _한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식_
- 뮤텍스는 세마포어가 될 수 없음
- 락을 획득한 프로세스만 락을 반환할 수 있음
- 한 스레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법
- 한 스레드가 임계 영역에 들어갈 때 lock을 걸어 다른 스레드가 접근하지 못하도록 하고 임계 영역에서 나올 때 unlock

### (4) 가상 메모리

- Swap 영역. 실제 메모리에서 공간이 부족한 경우 보조 기억 장치(auxiliary storage, secondary storage)에서 임시로 사용하는 영역
- OS 에서 관리하며 프로세스는 이것이 실제 메모리인지 Swap 영역인지 모름
- 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며 가급적이면 swap메모리를 사용하지 않도록 설계하는 것이 좋고 만약 계속해서 사용하는 양이 증가한다면 메모리 누수 의심

### (5) 캐시의 지역성

- 시간 지역성 : 최근에 접근한 데이터에 다시 접근하는 경향
- 공간 지역성 : 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향
