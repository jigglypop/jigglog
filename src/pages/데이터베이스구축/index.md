---
path: "/데이터베이스구축/"
category: "Certificate"
tags: ["Certificate"]
title: "2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축"
date: "2018-01-10T00:00:00.000Z"
summary: "2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축"
images: ["images/1.jpg"]
---



# 1. 논리 데이터베이스 설계



### 데이터베이스 설계

---



사용자의 요구를 분석하여 그것에 맞게 설계하고 특정 DBMS로 데이터베이스를 구현하여 사용자들이 사용하는 것

##### 데이터베이스 설계 순서(요구 조건 , 개념적, 논리적, 물리적, 구현)

- 요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현

+

- 요구 조건 분석 : 요구 조건 명세서 작성

* 개념적 설계 : 개념 스키마, E-R 모델, 트랜잭션 모델링
* 논리적 설계 : 논리 스키마 설계 ,  트랜잭션 인터페이스 설계
* 물리적 설계 : 물리적 구조의 데이터로 변환
* 구현 : DDL 로 데이터베이스 생성, 트랜잭션 작성



##### 데이터베이스 설계 시 고려사항

- 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장





### 데이터 모델의 개념

---



현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형



##### 데이터 모델의 구성 요소

- 개체(Entity), 속성(Attribute), 관계(Relation)



##### 데이터 모델의 종류

- 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델



##### 데이터 모델에 표시할 요소(구조, 연산, 제약 조건)

- 구조(Structure) : 개체 타입들 간의 관계, 데이터 구조 및 정적 성질 표현

- 연산(Operation) : 저장된 데이터를 처리하는 작업에 대한 명세, DB를 조작하는 기본 도구

- 제약 조건(Constraint) : 데이터의 논리적인 제약 조건





### 데이터 모델의 구성 요소 - 개체, 속성, 관계

<img src="https://k.kakaocdn.net/dn/be49gG/btqBYuEauiK/AuIgZ7dl1bIFRYnj1qHnPK/img.png" alt="img" style="zoom:67%;" />*

데이터베이스의 표현하려는 정보



##### 개체의 특징

- 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 이루어짐

- 유일한 식별자에 의해 식별이 가능

- 개체(튜플)의 수를 카디널리티라고 함

- 개체 인스턴스 : 개체를 구성하고 있는 속성들이 값을 가져 하나의 개체를 나타내는 것. 개체 어커런스라고도 함

- 자료 흐름도(DFD)를 통해 업무 분석을 했을 경우는 자료 저장소(Data Store)를 이용함.



##### 속성의 정의

DB를 구성하는 가장 작은 논리적인 단위(데이터 항목 또는 데이터 필드)

(속성 = 차수= 디그리)



##### 속성의 특징

- 개체의 특성을 기술함

- 속성의 수를 차수 혹은 디그리(Degree)라고 함



##### 속성의 종류

- 기본 속성 : 업무 분석을 통해 정의한 속성. 가장 많고 일반적 ex) 제품명
- 설계 속성 : 업무상 존재하지 않지만 설계 과정에서 도출해내는 속성 ex) 제품 코드
- 파생 속성 : 다른 속성으로부터 계산되거나 파생된 속성 ex) 제품 판매량, 판매 수익



##### 속성의 분류

- 기본키 속성(Primary Key Attribute) : 개체를 식별할 수 있는 속성 ex) 학번

- 외래키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성

- 일반 속성 : 개체에 포함되어 있지만 기본키, 외래키가 아닌 속성

<img src="https://k.kakaocdn.net/dn/s3t52/btqBYeO5Nfk/JNSpeHmn7krihj0KufbKGk/img.png" alt="img" style="zoom:67%;" />*

개체 간의 관계는 점선, 속성 간의 관계는 실선으로 표현



##### 관계의 정의

- 개체 간의 논리적인 연결



##### 관계의 형태

- 1:1, 1:N, N:M



##### 식별 / 비식별 관계

- 식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키면서 동시에 기본인 것
- 비식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키이지만 기본키는 아닌 것

  



### 식별자

---



하나의 개체 내에서 각각의 인스턴스(구체적인 데이터 값)를 유일하게 구분 지을수 있는 것



##### 식별자의 분류

- 대표성 여부 : 개체를 유일하게 식별할 수 있음
- 주 식별자(유일성, 최소성, 불변성, 존재성) : 개체를 대표하는 유일한 식별자 ex) 학번
- 보조 식별자 : 주 식별자를 대신하여 개체를 식별할 수 있는 것 ex) 주민번호



<img src="https://k.kakaocdn.net/dn/bnESLx/btqB10vXHT6/91iT6rOzGqTHKm2YgepGk0/img.png" alt="img" style="zoom: 50%;" />*



- 스스로 생성 여부

  - 내부 식별자 : 개체 내에서 스스로 만들어지는 식별자
  - 외부 식별자 : 다른 개체와의 관계에서 만들어지는 식별자

  

- 단일 속성 여부

  - 단일 식별자 : 주 식별자가 한 가지 속성으로 구성된 식별자
  - 복합 식별자 : 주 식별자가 두 개 이상의 속성으로 구성된 식별자

  

- 대체 여부

  - 원조 식별자(=본질 식별자) : 업무에 의해 만들어지는 가공되지 않은 원래의 식별자
- 대리 식별자(=대리 식별자) : 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자



### E-R(개체-관계) 모델

---



##### E-R 모델의 개요

- E-R 모델은 개념적 데이터 모델의 가장 대표적인 것

- 피터첸에 의해 제안되어 기본적인 구성 요소가 적립
- 데이터를 개체, 관계, 속성으로 묘사



##### E-R 다이어그램

E-R 모델의 기본 아이디어를 쉽게 기호를 사용하여 시각적으로 표현한 것

- 피터 첸 표기법, 정보 공학 표기법



##### 피터 첸 표기법

- 사각형 : 개체 타입

- 마름모 : 관계 타입

- 타원 : 속성 타입

- 이중 타원 : 복합 속성

- 밑줄 타원 : 기본키 속성

- 복수 타원 : 복합 속성

- 관계 : 1:1, 1:N, N:M 같은 관계에 대한 대응 수

<img src="https://k.kakaocdn.net/dn/eggVok/btqBYtUoLLq/5lfx6zaGyf4q6j5EDGyhck/img.png" alt="img" style="zoom: 50%;" />*

교수와 학생이 1:N 관계



##### 정보 공학 표기법

- 관계 표시 기호

  | : 1, O : 0, < : N

<img src="https://k.kakaocdn.net/dn/88hSB/btqCl9Op22z/wLAkFhtYtgYvMiHm02RiCk/img.png" alt="img" style="zoom:67%;" />*

교수와 학생이 1:N 관계





### 관계형 데이터베이스의 구조

---

개체, 속성, 관계를 모두 표로 표현, 간결하고 보기 편하며 다른 데이터베이스로의 변환이 용이



##### 관계형 데이터베이스의 구조

- 튜플

  - 릴레이션을 구성하는 각각의 행
  - 튜플의 수를 카디널리티(Cardinality)라고 함

  

- 속성

  - 데이터베이스를 구성하는 가장 작은 논리적인 단위
- 개체의 특성을 기술
  - 속성의 수를 디그리(Degree) 또는 차수라고 함

  

- 도메인

  - 속성이 취할 수 있는 값의 범위

  - ex) 학년의 도메인 : 1~4

<img src="https://k.kakaocdn.net/dn/dGvgtu/btqB2ucwMwn/2q719BsLFkv7rFSddIkSwK/img.png" alt="img" style="zoom: 50%;" />*



##### 릴레이션의 특징



- 튜플

  - 똑같은 튜플이 있을 수 없음. 모두 상이하다
- 튜플에는 순서가 없음
  - 튜플의 삽입, 삭제로 인해 시간에 따라 변함

  

- 속성

  - 속성의 명칭은 유일해야 하지만 속성을 구성하는 값은 다를 수 있음
- 속성에는 순서가 없음
  - 속성들은 원자 값(Atomic-Value)를 가짐





### 관계형 데이터베이스의 제약 조건 - Key

___

key는 데이터베이스에서 조건에 맞는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 속성



##### Key의 종류

- 후보키

  - 기본키로 사용할 수 있는 속성
  - 유일성과 최소성의 성질을 만족

  

- 기본키

  - 후보 키 중에서 선정된 Main Key로 중복된 값을 가질 수 없음

  - 후보 키의 부분집합

  - NULL 값을 가질 수 없음(=개체 무결성), 정보의 부재를 나타내기 위해 사용하는 값. 0의 값이 아님

    

- 대체키

  - 후보 키가 둘 이상일 때 기본키를 제외한 나머지 후보키

  

- 슈퍼키

  - 한 가지 속성일 땐 Key가 될 수 없지만 여러 속성이 뭉쳐서 Key의 속성을 가짐
  - 유일성의 성질을 만족

  

- 외래키

  - 다른 릴레이션의 기본 키를 참조한 것

  - 외래 키의 값은 참조한 릴레이션의 기본키 값과 동일해야 함(=참조 무결성)

<img src="https://k.kakaocdn.net/dn/xd7ex/btqB4Z5DBmW/QZd3KmI82FvkkabIE10ifK/img.png" alt="img" style="zoom:67%;" />*





### 관계형 데이터베이스의 제약조건 - 무결성

___



무결성은 데이터베이스의 저장된 데이터 값과 그것이 표현하는 실제 값이 일치하는 정확성을 의미



##### 무결성의 종류

- 개체 무결성 : 기본키를 구성하는 어떤 속성도 NULL 값이나 중복 값이면 안됨
- 도메인 무결성 : 속성의 값이 도메인에 속한 값이어야 함
- 참조 무결성 : 외래 키의 값은 참조한 릴레이션의 기본키 값과 동일해야 함
- 사용자 정의 무결성 : 속성 값들은 사용자가 정의한 제약 조건에 만족해야 함



##### 무결성 강화



- 애플리케이션

  - 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가
  - 사용자 정의 같은 복잡한 무결성 조건의 구현이 가능

  

- 데이터베이스 트리거

  - 트리거 : 데이터베이스 시스템에 이벤트가 발생할 때마다 자동으로 수행되는 절차형 SQL

  

- 제약 조건

  - 데이터베이스 제약 조건을 설정하여 무결성을 유지





### 관계 대수 및 관계 해석

---



##### 관계 데이터 언어

- 관계 대수 : 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해 유도하는 것을 기술하는 절차적 언어
- 관계 해석 : 관계 데이터의 연산을 표현하는 비절차적 언어



##### 관계 대수의 연산자

- Select(σ, σ<조건\*(R), R은 릴레이션을 의미)

  조건을 만족하는 튜플을 구하여 새로운 릴레이션을 만드는 연산(수평 연산)

  - ex) σ평균\*80 (성적) : 성적 릴레이션에서 평균값이 80 이상인 튜플을 구함

<img src="https://k.kakaocdn.net/dn/3eZ6a/btqB3qbyXHq/5YjyfQkNDYuMVa2ZTqKJMK/img.png" alt="img" style="zoom:67%;" />*



- Project(π, π<조건\*(R))

  속성만 추출하여 새로운 릴레이션을 만드는 연산(=수직연산)

  연산 결과에 중복이 발생하면 제거

  - ex) π이름, 평균(성적) : 성적 릴레이션에서 이름, 평균 속성을 추출

<img src="https://k.kakaocdn.net/dn/bl9v71/btqB5F6IJFf/EKJipEdOP47X65XiK3yabk/img.png" alt="img" style="zoom:67%;" />*



- Join(⋈, R⋈키 속성 r=키 속성 sS )

  두 릴레이션을 합쳐서 새로운 릴레이션을 만드는 연산

  Join의 결과로 만들어진 릴레이션의 차수는 두 차수의 합

  Join의 결과는 교차곱(Cartesian Product)을 수행 후 Select 한 것과 같음

  - ex) 성적⋈이름=이름 명부 : 성적 릴레이션과 명부 릴레이션을 이름 속성을 기준으로 합침

  * 자연 조인 : Join의 조건이 같을 때 동일한 속성이 두 번 나타나 중복된 속성을 제거하여 한번만 표기하는 방법

  * 자연 조인이 성립되려면 두 릴레이션의 속성명과 도메인이 같아야 함

<img src="https://k.kakaocdn.net/dn/bUnuMQ/btqB6jbjaGg/nu18ceMDzQbDL4WKv73pN1/img.png" alt="img" style="zoom:67%;" />*



- Division(÷, R [속성 r ÷ 속성 s] S)

  R ⊃ S인 두 릴레이션이 있을 때, R의 속성이 S의 속성의 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

  - ex) 성적 [평균 ÷ 기준] 기준

<img src="https://k.kakaocdn.net/dn/bljHpt/btqB5gTEtdO/c3FjWsNyBZYkXEga1KsPv0/img.png" alt="img" style="zoom:67%;" />*



- 일반 집합 연산자

  - 합집합(∪) : 두 릴레이션의 튜플의 합집합. 중복되는 튜플은 제거

  - 교집합(∩) : 두 필레이션의 튜플의 교집합.

  - 차집합(-) : 두 릴레이션의 튜플의 차집합.

  - 교차곱(×) : 두 릴레이션의 튜플들의 순서쌍. 차수(Degree)는 서로 더한 값 카디널리티(Cardinality)는 서로 곱한 값

<img src="https://k.kakaocdn.net/dn/LhuM2/btqB5hE0eTx/uzxQLzr4KWeQ80kg6vc3Tk/img.png" alt="img" style="zoom:67%;" />*





### 정규화(Normalization)

---



관계형 데이터베이스에서 정확성을 더욱 유지하기 위해 스키마를 쪼개는 과정, 데이터베이스의 논리적 설계 단계에서 수행



##### 정규화의 목적

- 데이터 구조의 안정성 및 무결성을 유지
- 이상의 발생을 방지 및 자료 저장 공간의 최소화



##### 이상(Anomaly)

- 사용자의 의도와는 상관없이 데이터가 삽입, 삭제, 갱신되는 현상



##### 정규화 과정

- 1NF _ 2NF _ 3NF _ BCNF _ 4NF \* 5NF

- 1NF(제1 정규형)

  - 릴레이션에 속한 모든 값들이 원자 값으로만 구성

- 2NF(제2 정규형)

  - 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족

  - 완전 함수적 종속 : 기본키에 의해서 속성이 결정

  - 부분 함수적 종속 : 기본키의 일부에 의해 속성이 결정

  - 아래와 같이 학번과 과목 코드가 기본키인 릴레이션이 있을 때

  - 과목 점수는 기본키(학번, 과목 코드)를 가지고 알 수 있음 = 완전 함수적 종속

  - 이름은 기본키의 일부(학번)를 가지고 알수 있음 = 부분 함수적 종속

<img src="https://k.kakaocdn.net/dn/xkNP8/btqB6IWeNsO/On3jgdQ2LT1Q87ZiXO6020/img.png" alt="img" style="zoom:67%;" />*



- 3NF(제3 정규형)

  - 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음
  - 이행적 종속 : A → B, B → C 일 때 A → C를 만족하는 관계

  

- BCNF(Boyce-Codd정규형)

  - 결정자가 모두 후보키

  

- 4NF(제4 정규형)

  - 릴레이션에 다치 종속이 성립하는 경우 모든 속성이 함수적 종속 관계를 만족

  

- 5NF(제5 정규형)

  - 모든 조인 종속이 후보키를 통해서만 성립

<img src="https://k.kakaocdn.net/dn/btd7lf/btqB2vkfpUj/DkFNmBoJ0r2L9Zvap5oJKK/img.png" alt="img" style="zoom:50%;" />*



* 도부이걸다조



### 반정규화(Denormalization)

---



정규화된 데이터를 다시 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위해, 과도한 정규화로 성능이 떨어졌을 때 실행



##### 반정규화의 종류

- 테이블 통합

  - 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행

  - Not NULL, Default, Check 등의 제약조건을 설계하기 어려움

- 테이블 분할

  - 테이블을 수평 또는 수직으로 분할

- 중복 테이블 추가

  - 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 수행

- 중복 속성 추가

  - 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가
  
  

### 시스템 카탈로그

---



##### 시스템 카탈로그의 의미

- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 데이터 사전(Data Dictionary)이라고도 함



##### 시스템 카탈로그 저장 정보

- 시스템 카탈로그에 저장되는 정보를 메타 데이터라고 함

- 메타 데이터 : 데이터에 대한 설명. 메타 데이터가 모이면 데이터 사전이 됨

- 메타 데이터의 유형

  - 데이터 베이스 객체 정보 : Table, Index, View 등의 구조 및 통계 정보

* 사용자 정보
  - 테이블의 무결성 제약 조건 정보
* 함수, 프로시저, 트리거 등에 대한 정보



##### 시스템 카탈로그의 특징

- 시스템 테이블로 구성되어 있어 SQL문으로 검색해 볼 수 있음
- DML(INSERT, DELETE, UPDATE) 문으로 갱신이 불가능







# 2. 물리 데이터베이스 설계



### 사전 조사 분석

---



##### 물리 데이터베이스 설계

- 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변화하는 과정

- 물리적 설계 단계에서 수행해야 할 것

  * 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계

- 물리적 설계 옵션

  - 반응시간 : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과 시간
  
  - 공간 활용도 : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장공간의 양
  - 트랜잭션 처리량 : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수
  
  

##### 데이터 명명 규칙 파악

- 물리 데이터 모델에 적용해야하는 규칙
- 데이터 표준화 및 논리 데이터베이스 설계의 결과물들을 통해 파악
- 물리-논리 데이터베이스 설계 적용되는 명명규칙은 일관성 유지
- 명명 규칙을 파악하기 위해선 도메인과 데이터 사전에 대한 지식 필요



##### 시스템 자원 파악

- 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소
- 하드웨어 자원, 운영체제 및 DBMS의 버전, DMBS 파라미터 정보 등으로 구분



##### 데이터베이스 관리 요소 파악

- 데이터베이스 운영과 관련된 관리요소

- 데이터베이스 관리 요소를 파악한 후 이를 기반으로 시스템 조사 분석서를 작성

- 시스템 조사 분석서를 기반으로 다음과 같은 요소들을 파악

  - 데이터베이스 구조 : 데이터베이스 구조에 따라 문제 발생 시 대응 방법이 다름

  - 이중화 구성 : 문제 발생에 대비하여 동일한 데이터베이스를 복제하여 관리

  - 분산 데이터베이스 : 물리적인 피해에 데이터 유실을 최소화할 수 있고 장애로 인한 데이터 유실 복구에 효과적

  - 접근 제어 / 통제 : 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 빈번하게 발생

* DB암호화 : 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 함





### 데이터베이스 저장 공간 설계

----



##### 테이블

- 데이터베이스의 가장 기본적인 객체로써 행(Row)과 열(Column)으로 구성됨
- 논리 설계 단계의 개체(Entity)에 대응하는 객체
- 일반 테이블, 클러스터 인덱스 테이블, 파티셔닝 테이블, 외부 테이블, 임시 테이블 



##### 일반 테이블

- 현재 사용되는 대부분의 DBMS(DataBase Management System)에서 표준 테이블로 사용되는 테이블

<img src="https://k.kakaocdn.net/dn/G9QrY/btqCgSFgXbM/BKbTHTqsG3rKPE54FuUbN1/img.png" alt="img" style="zoom:50%;" />*



##### 클러스터드 인덱스 테이블

- 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블

- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축

<img src="https://k.kakaocdn.net/dn/cE6yXQ/btqCiowTfuB/NxaeWspvpJtWqU6lcdk3s0/img.png" alt="img" style="zoom:50%;" />*



##### 파티셔닝 테이블

- 대용량의 테이블을 작은 논리적인 단위인 파티션으로 나눈 테이블

- 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등 역효과를 초래할 수 있음

- 방식에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉨

  * 범위 분할 : 지정한 열의 값을 기준으로 분할

  * 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할

  * 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

<img src="https://k.kakaocdn.net/dn/npi3j/btqCdhzpT0L/BL2Oc8u1ALkaHpJ7uqDxPK/img.png" alt="img" style="zoom:50%;" />*



##### 외부 테이블

- 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로 데이터베이스 내에 객체로 존재
- 데이터 쉐어하우스, ETL(Extraction Transformation Loading, 추출 변환 적재) 등의 작업에 사용



##### 임시 테이블

- 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
- 절차적인 처리를 위해 임시로 사용
- 저장된 데이터는 트랜잭션이 종료되면 삭제



##### 칼럼

- 테이블의 열을 구성하는 요소로 데이터 타입과 길이 등으로 정의
- 데이터 타입은 데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것
- 도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이가 정의
- 두 칼럼을 비교하는 연산에서 두 칼럼의 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입 변화 후 비교 연산 수행
- 참조 관계인 칼럼들은 데이터 타입과 길이가 일치해야 함



##### 테이블스페이스

- 테이블이 저장되는 논리적인 영역으로 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있음
- 테이블을 저장하면 논리적으론 테이블스페이스에 물리적으론 연관된 데이터 파일에 저장됨
- 테이블스페이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨

  - 투명성 : 사실의 존재 여부를 염두에 두지 않아도 되는 성질
- 데이터베이스에 저장되는 내용에 따라 테이블, 인덱스, 임시 등의 용도로 구분하여 설계





### 트랜잭션 및 CRUD 분석

---



데이터베이스의 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 작업 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미

데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적인 단위

사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위



##### 트랜잭션의 특성

- 원자성(Atomicity)

  * 데이터베이스에 반영되도록 완전히 완료 아니면 전혀 반영되지 않도록 복구되어야 함
* 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
  
- 일관성(Consistency)

  * 문법을 일괄적으로 맞춰야 함
* 트랜잭션을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환
  * 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후가 상태가 같아야 함

- 독립성(Isolation)

  * 하나의 트랜잭션 연산 중에는 다른 트랜잭션이 관여하면 안 됨

  * 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음

- 지속성(Durability)

  * 성공적으로 완료된 트랜잭션의 결과는 영구적으로 유지, 반영되어야 함
  
  

##### CRUD 분석

- 데이터베이스의 테이블에 변화를 주는 트랜잭션 연산 중 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것
- 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있음





##### CRUD 매트릭스

- 2차원 표로 행에는 프로세스 열에는 테이블을 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분석표

- CRUD 매트릭스를 통해 프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증

- CRUD 매트릭스의 각 셀에는 C, R, U, D가 들어가고 복수의 작업 시에는 우선순위는 C >D > U > R를 적용

- CRUD 매트릭스가 완성되면 C, R, U, D 중 어느 것도 적히지 않는 행이나 열, C나 R이 없는 행을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾음

<img src="https://k.kakaocdn.net/dn/rDa6p/btqCinx0CJT/k3CKsAsKJWN2Dpa28rUVv0/img.png" alt="img" style="zoom:50%;" />*



##### 트랜잭션 분석

- CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하고 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB용량을 산정, DB 구조를 최적화하는 것



##### 트랜잭션 분석서

- 단위 프로세스와 CRUD 매트릭스를 이용하여 작성

- 구성 요소에는 단위 프로세스, CRUD 연산, 테이블 명, 칼럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등

<img src="https://k.kakaocdn.net/dn/dI5d1M/btqCeuSETbH/u9smlvIDB2MRPQSqPVcppK/img.png" alt="img" style="zoom:50%;" />*



### 인덱스 설계

---



##### 인덱스의 개념

- 데이터 레코드를 빠르게 접근하기 위해 키값, 포인터 쌍으로 구성되는 데이터 구조

- 책의 목차와 유사

- 데이터가 저장된 물리적 구조와 밀접한 관계가 있음

- 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있음

- 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생

  - TABLE SCAN : 데이터가 나올 때까지 모든 레코드를 순차적으로 읽는 것

- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적

- 클러스터드 인덱스 : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식

- 넌클러스터드 인덱스 : 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식

<img src="https://k.kakaocdn.net/dn/bmbstJ/btqCjffJ9AL/tq3kDZ3ky1FAp9HeQZSp21/img.png" alt="img" style="zoom:50%;" />*



##### 트리 기반 인덱스

- 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용

- B 트리 인덱스

  - 일반적으로 사용하는 인덱스 방식

  - 루트 노드에서 하위 노드로 키값의 크기를 비교하면서 데이터를 검색

  - 모든 리프 노드의 레벨은 같음

- B+ 트리 인덱스

  - 단말 노드가 아닌 노드로 구성된 인덱스 세트,  단말 노드로만 구성된 순차 세트로 구분
- 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공
  - 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
- 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드 만을 이용한 순차 처리 가능
  


##### 비트맵 인덱스

- 인덱스 칼럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
- 키 값을 포함하는 로우(Row)의 주소를 제공
- 데이터가 Bit로 구성되어 있어 효율적인 논리 연산이 가능하고 저장공간이 작음



##### 함수 기반 인덱스

- 칼럼의 값 대신 칼럼의 특정 함수나 수식을 적용하여 산출된 값을 사용
- B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
- 데이터를 입력하거나 수정할 때 함수를 적용하기 때문에 부하가 발생할 수 있음
- 사용자 정의 함수를 사용했을 경우 시스템 함수보다 부하가 더 크다
- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 



##### 비트맵 조인 인덱스

- 다수의 조인된 객체로 구성된 인덱스

##### 도메인 인덱스

- 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로 확장형 인덱스라고도 함

##### 인덱스 설계 순서

- 인덱스의 대상 테이블이나 칼럼 등을 선정 → 인덱스의 효율성을 검토하여 인덱스 최적화 수행 → 인덱스 정의서 작성



##### 인덱스 테이블 선정 기준

- MULTI BLOCK READ 수에 따라 판단

  - MULTI BLOCK READ : 테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수
- 랜덤 액세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블



##### 인덱스 설계 시 고려사항

- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음
- 인덱스를 지나치게 만들면 오버헤드 발생
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생
- 인덱스를 만들면 추가적인 저장공간 필요
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계





### 뷰 설계

---



##### 뷰의 개요

- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블

- 물리적으로 존재하지는 않지만 사용자에게는 있는 것처럼 간주됨

- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용

- 조인문의 최소화로 사용자 편의성을 최대화함

<img src="https://k.kakaocdn.net/dn/8DeDC/btqCe47C7yk/iYx2xC0dIfvx3ryKZnA8gk/img.png" alt="img" style="zoom:50%;" />*



##### 뷰의 특징

- 기본 테이블과 같은 형태의 구조를 사용하고 조작도 기본 테이블과 거의 같음
- 가상테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 논리적 독립성을 제공할 수 있음
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
- 뷰를 통해서만 데이터에 접근하게 되면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제 시 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제



##### 뷰의 장단점

- 장점

  - 논리적 데이터 독립성 제공

  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구를 지원

  - 사용자의 데이터 관리가 용이

  - 접근 제어를 통한 자동 보안 제공

- 단점

  - 독립적인 인덱스를 가질 수 없음
- 뷰의 정의 변경 불가
  - 뷰로 구성된 내용에 대해 INSERT, DELETE, UPDATE 연산에 제약이 따름

  

##### 뷰 설계 순서

- 대상 테이블 선정 → 대상 칼럼 선정 → 정의서 작성



##### 뷰 설계 시 고려사항

- 테이블 구조가 단순화될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
- 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시
- 데이터의 보안을 유지하며 설계





### 클러스터 설계

---



##### 클러스터의 개요

- 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 데이터 블록에 저장하는 물리적 저장 방법

- 클러스터링키로 지정된 칼럼 값의 순서대로 저장되고 여러 개의 테이블이 하나의 클러스터에 저장



##### 클러스터의 특징

- 데이터 조회 속도는 향상시키지만 데이터 입력 수정 삭제에 대한 성능은 저하시킴

- 데이터의 분포도가 넓을수록 유리

- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 지양

- 파티셔닝 된 테이블에는 적용할 수 없음



##### 클러스터 대상 테이블

- 분포도가 넓은 테이블
- 대량의 범위를 자주 조회하는 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블
- ORDER BY, GROUP BY, UNION이 빈번한 테이블
  - ORDER BY : 특정 속성을 기준으로 정렬하여 검색
  - GROUP BY : 특정 속성을 기준으로 그룹화하여 검색할 때 사용. 그룹 함수와 같이 사용
  - UNION : 두 SELECT 문의 결과를 통합하고 중복된 행은 한 번만 출력





### 파티션 설계

---



##### 파티션의 개요

- 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
- 대용량 DB의 경우 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지하고 데이터 관리가 용이함
- 데이터 처리는 테이블 단위, 데이터 저장은 파티션 별로 수행



##### 파티션의 장단점

- 장점

  - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상
- 데이터가 분산되어 저장되므로 디스크 성능 향상
  - 파티션별로 백업 및 복구를 수행하므로 속도 향상
- 시스템 장애 시 데이터 손상 정도 최소화
  - 데이터 가용성 향상
- 파티션 단위로 입출력 분산
  

  
- 단점

  - 하나의 테이블을 세분화하여 관리하기 때문에 세심한 관리가 요구됨
- 테이블 간 조인에 대한 비용이 증가
  - 용량이 작은 테이블에 파티셔닝을 수행하면 성능이 저하됨

  

##### 파티션의 종류

- 범위 분할 : 지정한 열의 값을 기준으로 분할
- 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
- 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할



##### 파티션 키 선정 시 고려사항

- 파티션 키는 테이블 접근 유형에 따라 파티셔닝이 이루어지도록 선정
- 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성 주기와 소멸 주기를 일치시켜야 함
- 매일 생성되는 날짜 칼럼, 백업의 기준이 되는 날짜 칼럼, 파티션 간 이동이 없는 칼럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 칼럼 등을 파티션 키로 선정



##### 인덱스 파티션

- 파티션 된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

- 파티션된 테이블의 종속 여부에 따른 구분

  - Local Partitioned Index : 테이블 파티션, 인덱스 파티션이 1:1 대응(관리 용이)
- Global Partitioned Index : 테이블 파티션, 인덱스 파티션이 독립적
- 인덱스 파티션 키 칼럼의 위치에 따른 구분

  - Prefixed Partitioned Index : 인덱스 파티션 키와 인덱스 첫 번째 칼럼이 같음
- Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 칼럼이 다름





### 데이터베이스 용량 설계

---



##### 데이터베이스 용량 설계

- 데이터가 테이블에 저장될 공간을 정의
- 테이블에 저장할 데이터양, 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영



##### 데이터베이스 용량 설계의 목적

- 디스크의 저장공간을 효과적으로 사용하고 확장성 및 가용성을 높임

- 디스크의 입출력 부하를 분산시키고 채널의 병목현상 최소화

- 디스크에 대한 입출력 경합이 최소화되도록 설계함으로써 데이터 접근성이 향상

- 데이터베이스에 생성되는 오브젝트의 익스텐트 발생을 최소화하여 성능을 향상

- 테이블과 인덱스에 적합한 저장 옵션을 지정

- 데이터 접근성을 향상시키는 설계 방법

  - 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리하여 구성
- 테이블스페이스와 임시 테이블스페이스를 분리하여 구성
  - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

  

##### 데이터베이스 용량 분석 절차

- 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량 분석
- 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정
- 테이블과 인덱스의 테이블스페이스 용량을 산정
- 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량 산정





### 분산 데이터베이스 설계

---



##### 분산 데이터베이스 정의

- 논리적인 하나의 시스템이지만 물리적으로는 네트워크로 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스
- 데이터베이스를 네트워크를 이용해 나눠놓음



##### 분산 데이터베이스의 구성 요소

- 분산 처리기 : 지리적으로 분산되어 있는 컴퓨터 시스템
- 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이스
- 통신 네트워크 : 분산 처리기들을 네트워크로 연결하여 하나의 시스템처럼 동작할 수 있도록 하는 통신 네트워크



##### 분산 데이터베이스 설계 시 고려사항

- 작업 부하의 노드별 분산 정책
- 지역의 자치성 보장 정책
- 데이터의 일관성 정책
- 사이트나 회선의 고장으로부터의 회복 기능
- 통신 네트워크를 통한 원격 접속 기능



##### 분산 데이터베이스의 목표

- 위치 투명성 : 접근하려는 데이터베이스의 실제 위치를 알 필요 없이 논리적인 명칭만으로 접근 가능

- 중복 투명성 : 동일 데이터가 여러 곳에 중복되어 있어도 사용자는 하나의 데이터만 존재하는 것처럼 사용 가능

* 병행 투명성 : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
* 장애 투명성 : 트랜잭션, DBMS, 네트워크, 컴퓨터 등 장애에도 트랜잭션을 정확하게 처리
* 투명성 : 사실 존재 여부를 염두에 두지 않아도 되는 성질



##### 분산 데이터베이스의 장점

- 장점

  - 지역 자치성이 높음

  - 자료의 공유성 향상

  - 분산 제어 가능

  - 시스템 성능 향상

  - 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음

  - 효용성과 융통성이 높음

  - 신뢰성 및 가용성이 좋음

  - 점진적 시스템 용량 확장 용이

- 단점

  - DBMS가 수행할 기능이 복잡

  - DB 설계가 어려움

  - 소프트웨어 개발 비용 증가

  - 처리 비용 증가

  - 잠재적 오류 증가

##### 분산 데이터베이스 설계

- 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하는 것이 목적
- 전역 관계망을 논리적 측면에서 소규모 단위로 분할, 분할된 결과를 복수의 노드에 할당
- 분산 설계 방법에는 테이블 위치 분산, 분할, 할당이 있음



##### 테이블 위치 분산

- 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치
- 테이블의 구조를 변경시키지 않고 다른 데이터베이스의 테이블과 중복되지 않게 배치



##### 분할

- 테이블의 데이터를 분할하여 분산

- 분할 규칙

  - 완전성 : 전체 데이터를 대상으로 분할해야 함

  - 재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성이 가능해야 함

  - 상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 함

- 분할 방법

  - 수평 분할 : 행 단위로 분할

  - 수직 분할 : 속성 단위로 분할

<img src="https://k.kakaocdn.net/dn/dpAf2F/btqCkRer3Xn/j1Wv8RzXPxT7vsVSZYvpeK/img.png" alt="img" style="zoom:50%;" />*



##### 할당

- 동일한 분할을 여러 개의 서버에 생성하는 분산 방법

- 비중복 할당 방식

  - 최적의 노드를 선택해서 분산 데이터베이스의 단일 노드에서만 분할이 존재

- 중복 할당 방식

  - 동일한 테이블을 다른 서버에 복제하는 방식



### 데이터베이스 이중화 / 서버 클러스터링

---



##### 데이터베이스 이중화

- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것
- 하나 이상의 데이터베이스가 항상 같은 상태를 유지
- 데이터베이스가 문제가 생기면 즉시 해결 가능
- 사용자가 작업을 수행하면 이중화 시스템에 연결된 다른 데이터베이스도 동일하게 적용
- 애플리케이션을 여러 개의 데이터베이스로 분산시켜 처리해 데이터베이스의 부하를 감소



##### 데이터베이스 이중화의 분류

- 내용 전달 방식에 따른 분류
- Eager 기법 : 트랜잭션 수행 중 데이터 변경 발생 시 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용
- Lazy 기법 : 트랜잭션 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달하여 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주



##### 데이터베이스 이중화 구성 방법

- 활동-대기 방법

  - 한 DB가 서비스 시 다른 DB는 대기

  - 활성 DB에 장애 발생 시 대기 중이었던 DB가 모든 서비스를 대신 수행

  - 구성 방법 및 관리가 쉬워 많은 기업에서 사용

- 활동-활동 방법

  - 두 개의 DB가 서로 다른 서비스를 제공

* 한쪽 DB에 장애 발생 시 다른 DB가 서비스를 제공

  - 두 DB가 모두 처리를 해 처리율이 높지만 구성 방법 및 설정이 복잡



##### 클러스터링

- 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
- 서버 이중화 및 공유 스트로지를 사용하여 서버의 고가용성을 제공

  - 고가용성 : 시스템을 오랜 시간 동안 계속해서 정상적으로 운영이 가능한 성질
- 병렬 처리 클러스터링 : 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리
- 고가용성 클러스터링 : 하나의 서버에 장애가 발생 시 다른 서버가 받아서 처리하여 서비스 중단을 방지하는 방식





### 데이터베이스 보안 / 암호화

---



데이터베이스의 일부분 또는 전체에 권한이 없는 사용자가 액세스 하는 것을 금지하기 위해 사용



##### 암호화 / 복호화

- 암호화는 데이터를 보낼 때 송신자가 지정한 수신자 외는 그 내용을 알 수 없도록 평문을 암호문으로 변환
- 암호화 과정 : 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꿈
- 복호화 과정 : 암호문을 원래의 평문으로 바꿈



##### 개인키 / 공개키 암호 방식

- 암호화 방식의 키와 복호화 방식의 키가 같을 때

  - 개인키 / 비밀키 / 대칭키 암호 방식

  - 종류 : 전위 기법, 대수 기법, 합성 기법(DES)

- 암호화 방식의 키와 복호화 방식의 키가 다를 때

  - 공개키 / 비대칭키
- RSA 기법



### 데이터베이스 보안 - 접근통제

---



##### 접근통제

- 데이터가 저장된 객체와 사용하려는 주체 사이의 정보 흐름을 제한

- 데이터에 대해 통제를 함으로써 자원의 불법적인 접근 및 파괴를 예방

- 임의 접근통제(Discretionary Access Control)

  - 데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여

  - 통제 권한이 주체에 있어 접근통제 권한을 주체가 지정하고 제어

  - 객체를 생성한 사용자가 객체에 대한 모든 권한을 부여받고 다른 사용자에게 허가 가능

  - SQL 명령어로는 GRANT, REVOKE가 있음

- 강제 접근통제(Mandatory Access Control)

  - 주체와 객체의 등급을 비교하여 접근 권한을 부여
  
  - 제 3자가 접근통제 권한 지정
  - 객체별로 보안 등급을 부여할 수 있으며 사용자별로 인가 등급을 부여할 수 있음
  - 주체의 보안 등급이 자신의 보안등급보다 높으면 읽기, 수정, 등록이 모두 불가하고 동등하면 읽기, 수정, 등록이 모두 가능하며 낮으면 읽기만 가능

##### 접근통제 정책

- 어떤 주체(Who)가 언제(When) 어디서(Where) 어떤 객체(What)에게 어떤 행위(How)에 대한 허용 여부를 정의하는 것

- 신분 기반 정책

  - 주체나 그룹의 신분에 근거하여 객체의 접근을 제한

  - IBP(Individual-Based Policy) : 최소 권한 정책, 단일 주체에게 하나의 객체에 대한 허가를 부여

  - GBP(Group-Based Policy) : 복수 주체에 대한 허가를 부여

- 규칙 기반 정책

  - 주체가 갖는 권한에 근거하여 객체의 접근을 제한

  - MLP(Multi-Level Policy) : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책

  - CBP(Compartment-Based Policy) : 집단별로 지정된 기밀 허가에 따른 정책

- 역할 기반 정책

  - 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한

##### 접근통제 매커니즘

- 정의된 접근통제 정책을 구현하는 기술적인 방법
- 접근통제 목록 : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지 기록한 목록
- 능력 리스트 : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록
- 보안 등급 : 주체나 객체에 부여된 보안 속성의 집합
- 패스워드 : 주체가 자신임을 증명할 때 사용하는 인증 방법
- 암호화 / 복호화
  - 암호화는 데이터를 보낼 때 송신자가 지정한 수신자 외는 그 내용을 알 수 없도록 평문을 암호문으로 변환
  - 암호화 과정 : 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꿈
  - 복호화 과정 : 암호문을 원래의 평문으로 바꿈



##### 접근통제 보안 모델

- 보안 정책을 구현하기 위한 정형화된 모델

- 기밀성 모델

  - 군사적인 목적으로 개발된 최초의 수학적 모델로 기밀성 보장이 최우선

- 무결성 모델

  - 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델

  - 데이터 일관성 유지에 중점을 두어 개발

- 접근통제 모델

  - 접근통제 매커니즘을 보안 모델로 발전시킨 것

  - 접근통제 모델 : 임의적인 접근 통제를 관리하기 위한 모델로 행은 주체 열은 객체를 의미

  - R : 읽기 권한

  - W : 쓰기 권한

  - ALL : 모든 권한

<img src="https://k.kakaocdn.net/dn/rta76/btqCl98Jb6d/5pgW3PFCpUnO7ngPQQotqK/img.png" alt="img" style="zoom:50%;" />*



##### 접근통제 조건

- 접근통제 매커니즘의 취약점을 보안하기 위해 접근 통제 정책에 부가하여 적용할 수 있는 조건
- 값 종속 통제 : 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우
- 다중 사용자 통제 : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우
- 콘텍스트 기반 통제 : 특정 시간, 네트워크 주소, 접근 경로, 인증 경로 등에 근거하여 접근을 제어하는 방식



##### 감사 추적

- 사용자나 애플리케이션의 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능
- 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용





### 데이터베이스 백업

---



전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업

##### 데이터베이스 장애 유형

- 사용자 실수 : 사용자의 실수로 인한 오류
- 미디어 장애 : 하드웨어 장애나 데이터가 파손된 경우
- 구문 장애 : 프로그램 오류나 사용 공간의 부족으로 발생하는 장애
- 사용자 프로세스 장애 : 프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 장애
- 인스턴스 장애 : 하드웨어 장애, 정전, 시스템 파일 파손 등 비정상적 요인으로 메모리나 데이터베이스 서버의 프로세스가 중단된 경우



##### 로그 파일

- 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 파일
- 로그 파일을 기반으로 과거 상태로 복귀(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지



##### 데이터베이스 복구 알고리즘

- NO-UNDO/REDO : 비동기적으로 갱신한 경우
- UNDO/NO-REDO : 동기적으로 갱신한 경우
- UNDO/REDO : 동기/비동기적으로 갱신한 경우
- NO-UNDO/NO-REDO : 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우



##### 백업 종류

- 물리 백업 : 데이터베이스 파일을 백업하는 방법
- 논리 백업 : 데이터베이스 내의 논리적 객체들을 백업하는 방법



### 

### 스토리지

---



단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술\



##### DAS(Direct Attached Storage)

- 서버와 저장장치를 전용 케이블로 직접 연결하는 방식
- 서버에서 저장장치를 관리
- 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움
- 다른 서버에서 스토리지에 접근하여 사용 불가



##### NAS(Network Attacked Storage)

- 서버와 저장장치를 네트워크를 통해 연결하는 방식
- 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 고나리
- DAS에 비해 확장성 및 유연성이 좋음
- 서버들이 자유롭게 스토리지에 접근하여 파일 공유



##### SAN(Storage Area Network)

- DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식

- 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성

- 파이버 채널(FC) 스위치를 이용하여 네트워크를 구성

  - 파이버 채널 : 장치 간 데이터 전송 속도를 기가바이트로 높이기 위한 네트워크 기술

- 서버나 저장장치를 광케이블로 연결하므로 처리 속도가 빠름

- 서버들이 저장장치 및 파일을 자유롭게 공유





### 논리 데이터 모델의 물리 데이터 모델 변환

---



##### 테이블

- 데이터를 저장하는 데이터베이스의 가장 기본적인 오브젝트

##### 엔티티를 테이블로 변환

- 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환

<img src="https://k.kakaocdn.net/dn/bHJDlo/btqCsIhmXiL/S9aNrAuRpYwFdIgZo3KSQ1/img.png" alt="img" style="zoom:50%;" />*



- 테이블과 엔티티 명칭은 동일하게 하는 것을 권고

- 테이블은 소스코드 가독성을 위해 영문명을 사용

- 표준화된 용어 사용 지향

- 변환 규칙

<img src="https://k.kakaocdn.net/dn/bX6D6R/btqCsGX1OZ5/K3mTePOnFtYhFUQeyENej1/img.png" alt="img" style="zoom:50%;" />*



##### 슈퍼타입/서브타입을 테이블로 변환

- 슈퍼타입과 서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 테이블로 변환

- 슈퍼타입 기준 테이블 변환

  - 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만듦

  - 데이터의 액세스가 상대적 용이

  - 뷰를 이용하여 각각의 서브타입만을 액세스 하거나 수정할 수 있음

  - SQL 문장 구성이 단순

  - 디스크 저장 공간이 증가

  - 인덱스의 효율이 떨어짐

<img src="https://k.kakaocdn.net/dn/dEeHfX/btqCl9HJa8H/NMRnXl9nkYjmwK5L9wsRxk/img.png" alt="img" style="zoom:50%;" />*



- 서브타입 기준 테이블 변환

  - 슈퍼타입의 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만듦

  - 각 서브타입 속성들의 선택 사양이 명확한 경우 유리

  - 여러 개의 테이블로 통합하므로 테이블당 크기가 감소하여 전체 테이블 스캔 시 유리

  - 수행 속도 감사

  - 복잡한 처리를 하는 SQL의 통합이 어려움

<img src="https://k.kakaocdn.net/dn/cJqLon/btqCl9npb67/qh16nLenZmr3gk9ywqXZik/img.png" alt="img" style="zoom:50%;" />*



- 개별타입 기준 테이블 변환

  - 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환

  - 슈퍼타입과 서브타입 테이블 사이에는 각각 1:1 관계가 형성

  - 저장공간이 상대적으로 작음

<img src="https://k.kakaocdn.net/dn/b75tUi/btqCl89RJdt/IPILGL0AvwjjlCr6Czshn0/img.png" alt="img" style="zoom:50%;" />*



##### 속성을 칼럼으로 변환

- 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환

- 일반 속성 변환

  - 엔티티의 속성을 테이블의 각각의 컬럼으로 변환

  - 칼럼명은 SQL 예약어 사용을 피하고 가능한 한 짧게 지정

<img src="https://k.kakaocdn.net/dn/Lt7Wd/btqCtYK0MvF/XaKuZXtlbwgPL4an6TSi3K/img.png" alt="img" style="zoom:50%;" />*



##### 관계를 외래키로 변환

- 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 기본키로 변환

<img src="https://k.kakaocdn.net/dn/cvyPeM/btqCsGqifKi/Y9y5nXQfuqycektaKKbkNk/img.png" alt="img" style="zoom:50%;" />*



##### 관리 목적의 테이블/칼럼 추가

- 논리 데이터 모델에는 존재하지 않는 테이블이나 칼럼을 데이터베이스 관리 혹은 이용하는 프로그래밍의 수행 속도를 향상시키기 위해 물리 데이터 모델에 추가할 수 있음



##### 데이터 타입 선택

- 정의된 논리적인 데이터 타입을 물리적인 DBMS의 물리적 특성과 성능을 고려하여 최적의 데이터 타입과 데이터의 최대 길이를 선택

- Oracle에서 자주 사용되는 데이터 유형

  - CHAR : 고정길이 문자열
- VARCHAR : 가변 길이 문자열
  - NUMBER : 38 자릿수의 숫자 저장 가능
- DATE : 날짜 저장



# 3. SQL 응용

### SQL 개념

---



국제 표준 데이터베이스 언어이며 많은 관계형 데이터베이스(RDB)를 지원하는 언어로 채택

##### SQL의 분류

- DDL(Data Define Language, 데이터 정의어): 스키마, 도메인, 테이블, 뷰, 인덱스를 정의, 변경, 삭제할 때 사용하는 언어

  CREATE : 스키마, 도메인, 테이블, 뷰, 인덱스를 정의

  ALTER : 테이블에 대한 정의를 변경

  DELETE : 스키마, 도메인, 테이블, 뷰, 인덱스를 삭제

* DML(Data Manipulation Language, 데이터 조작어) : 사용자가 저장된 데이터를 실질적으로 처리하는 데 사용

  SELECT : 테이블에서 조건에 맞는 튜플 검색

  INSERT : 테이블에 새로운 튜플 삽입

  DELETE : 테이블에서 조건에 맞는 튜플 삭제

  UPDATE : 테이블에서 조건에 맞는 튜플의 내용 변경

- DCL(Data Control Language, 데이터 제어어) : 데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용하는 언어

  COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고 데이터베이스 조작 작업이 정상적으로 완료되었음을 알려줌

  ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구

  GRANT : 데이터베이스 사용자에게 사용 권한을 부여



### DDL

---



DDL(데이터 정의어)는 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어



##### CREATE

- CREATE SCHEM : 스키마(데이터베이스 구조와 제약 조건에 관한 전반적인 명세를 기술한 것)를 정의

```
CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_id;
```

```
CREATE SCHEMA 성적 AUTHORIZATION 김이박;
소유권자의 사용자 ID가 '김이박'이고 스키마 '성적'을 정의하는 SQL문
```

- CREATE DOMAIN : 도메인을 정의(대괄호는 생략 가능)

```
CREATE DOMAIN 도메인명 [AS] 데이터_타입
	[DEFAULT 기본값]
	[CONSTRAINT 제약조견명 CHECK (범위값)];
```

```
CREATE DOMAIN [AS] CHAR(1)
	DEFAULT '남'
    CONSTRAINT VALID-GENDER CHECK(VALUE IN('남','여');
성별을 '남' 또는 '여'와 같이 정해진 1개 문자로 표현되는 도메인 GENDER를 정의하는 SQL문
```

- CREATE TABLE : 테이블을 정의

```
CREATE TABLE 테이블명
    (속성명 데이터_타입 [DEFAULT 기본값][NOT NULL], ...
    [, PRIMARAY KEY(기본키_속성명), ...)]
    [, UNIQUE(대체키_속성명), ...)]
    [, FOREIGN KEY(외래키_속성명, ...)]
    	REFERENCES 참조테이블(기본키_속성명, ...)]
        [ON DELETE 옵션]
        [ON UPDATE 옵션]
    [, CONSTRAINT 제약조건명][CHECK (조건식)]);
```

- '이름', '학번', '전공', '성별', '생년월일'로 구성된 학생 테이블을 정의하는 SQL문
- 제약조건
  - '이름'은 NULL 일 수 없음
  - '학번'은 기본키
  -  '전공'은 학과 테이블의 '학과 코드'를 참조하는 외래키로 사용
  - 학과 테이블에서 삭제가 일어나면 관련된 튜플들의 전공 값을 NULL로 만듦
  - 학과 테이블에서 '학과 코드'가 변경되면 전공 값도 같은 값으로 변경
  - '생년월일'은 1980-01-01 이후의 데이터
  -  제약 조건의 이름은 '생년월일 제약'
  -  각 속성의 데이터 타입은 적당하게 지정
  -  '성별'은 도메인 GENDER 사용

```
CREATE TABLE 학생
    (이름 VARCHAR(15) NOT NULL,
    학번 CHAR(8)
    전공 CHAR(5)
    성별 GENDER
    생년월일 DATE
    PRIMARY KEY(학번)
    FOREIGN KEY(전공) REFERENCES 학과(학과코드)
    	ON DELETE SET NULL
        ON UPDATE CASCADE
    CONSTRAINT 생년월일제약 CHECK(생년월일*='1980-01-01'));
```

- CREATE VIEW

  - 뷰(하나 이상의 기본 테이블로부터 유도되는 이름을 갖는 가상 테이블)를 정의

  - SELECT문의 결과로써 뷰를 생성

```
CREATE VIEW 뷰명[(속성명[, 속성명, ...])]
AS SELECT문;
```

- 고객 테이블에서 '주소'가 '포천시'인 고객들의 '이름'과 '전화번호'를 '포천 고객'이라는 뷰로 정의하는 SQL문

```
CREATE VIEW 포천고객(이름, 전화번호)
AS SELECT 이름,전화번호
FROM 고객
WHERE 주소 = '포천시';
```

- CREATE INDEX

  - 인덱스(검색 시간을 단축시키기 위해 만든 보조적인 데이터 구조)를 정의

  - ASC : 오름차순 정렬, 생략 시 기본 값 / DESC : 내림차순 정렬

  - CLUSTER : 사용 시 인덱스를 클러스터드 인덱스로 지정

  - 클러스터드 인덱스 : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식

```
CREATE [UNIQUE] INDEX 인덱스명
ON 테이블명(속성명 [ASC|DESC][,속성명 [ASC|DESC]])
[CLUSTER];
```

- 고객 테이블에서 UNIQUE 한 특성을 갖는 '고객번호'속성에 대해 내림차순으로 정렬하여 '고객번호\_idx'라는 이름으로 인덱스를 정의하는 SQL문

```
CREATE UNIQUE INDEX 고객번호_idx
ON 고객(고객번호 DESC);
```

##### ALTER

- ALTER TABLE

  - 테이블에 대한 정의를 변경

```
ALTER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT '기본값'];
ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];
ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];
```

- 학생 테이블에 최대 3 문자로 구성되는 '학년' 속성을 추가하는 SQL문

```
ALTER TABLE 학생 ADD 학년 VARCHAR(3);
```

- 학생 테이블의 학년 필드의 데이터 타입과 크기를 최대 10글자로 하고 NULL값이 입력되지 않게 하는 SQL문

```
ALTER TABLE 학생 ALTER 학년 VARCHAR(10) NOT NULL;
```

##### DROP

- 스키마, 도메인, 기본 테이블, 튜 테이블, 인덱스, 제약 조건 등을 제거하는 명령문

```
DROP SCHEMA 스키마명 [CASCADE | RESTRICTED];
DROP DOMAIN 도메인명 [CASCADE | RESTRICTED];
DROP TABLE 테이블명 [CASCADE | RESTRICTED];
DROP VIEW 뷰명 [CASCADE | RESTRICTED];
DROP INDEX 인덱스명 [CASCADE | RESTRICTED];
DROP CONSTRAINT 제약조건명
```

- CASCADE : 제거할 때 참조 관계에 있는 테이블의 데이터도 연쇄 삭제

- RESTRICTED : 제거할 때 참조하고 있는 테이블이 있다면 삭제를 취소



### DCL

---



DCL(데이터 제어어)는 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어

##### GRANT

- 데이터베이스 관리자가 사용자에게 권한 부여

##### REVOKE

- 데이터베이스 관리자가 사용자에게 권한 취소

##### COMMIT

- 트랜잭션이 성공적으로 끝난 후 변경된 내용을 데이터베이스에 반영

##### ROLLBACK

- COMMIT 되지 않은 변경된 내용을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령

##### SAVEPOINT

- 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 저장



### DML

---



##### DML의 개념

- DML(데이터 조작어)는 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 관리하는 데 사용하는 언어

##### INSERT

- 테이블에 새로운 튜플을 삽입

```
INSERT INTO 테이블명([속성명1, 속성명2, ...])
VALUES (데이터1, 데이터2, ...)
```

- 사원 테이블에 (이름 - 김이박, 부서 - 개발)을 삽입하는 SQL문

```
INSERT INTO 사원(이름, 부서) VALUE(김이박, 개발);
```

- 사원 테이블에 있는 개발의 모든 튜플을 개발 부원(이름, 생일) 테이블에 삽입하는 SQL문

```
INSERT INTO 개발부원(이름, 주소)
SELECT 이름, 주소
FROM 사원
WHERE 부서 = "개발"
```

##### DELETE

- 테이블의 튜플 중 특정 튜플을 삭제

```
DELETE
FROM 테이블명
[WHERE 조건]
```

- 사원 테이블에서 부서가 개발인 튜플을 삭제하는 SQL문

```
DELETE FROM 사원 WHERE 부서 = "개발";
```

##### UPDATE

- 테이블의 튜플 중 특정 튜플의 내용을 변경

```
UPDATE 테이블명
SET 속성명 = 데이터[, 속성명=데이터, ...]
[WHERE 조건];
```

- 사원 테이블에서 김이박의 부서를 IT로 변경하는 SQL문

```
UPDATE 사원
SET 부서 = "IT"
WHERE 이름 = "김이박";
```



##### SELECT

- 테이블에서 튜플을 검색

```
SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...]
FROM 테이블명[, 테이블명, ...]
[, WINDOW 함수 OVER (PARTITION BY 속성명1, 속성명2, ... ORDER BY 속성명3, 속성명4, ...) [AS 별칭]]
[WHERE 조건]
[GROUP BY 속성명, 속섬영, ..]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
```

- ORDER BY : 특정 속성을 기준으로 정렬하여 검색

  ASC : 오름차순

  DESC : 내림차순

* WINDOW 함수 : GROUP BY 절을 이용하지 않고 속성의 값을 집계할 함수를 기술

  PARTITION BY : WINDOW 함수가 적용될 범위로 사용할 속성을 지정

  ORDER BY : PARTITION 안에서 정렬 기준으로 사용할 속성을 지정

  ROW_NUMBER() : 각 레코드에 대한 일련번호 반환

  RANK() : 순위를 반환하되 공동 순위를 반영

  DENSE_RANK() : 순위를 반환하되 공동 순위를 반영하지 않음

- GROUP BY : 특정 속성을 기준으로 그룹화하여 검색할 때 사용. 그룹 함수와 같이 사용

  COUNT(속성명) : 그룹별 튜플 수를 구하는 함수

  SUM(속성명) : 그룹별 합계를 구하는 함수

  AVG(속성명) : 그룹별 평균을 구하는 함수

  MAX(속성명) : 그룹별 최대값을 구하는 함수

  MIN(속성명) : 그룹별 최소값을 구하는 함수

  ROLLUP(속성명, 속성명, ...) : 인수로 주어진 속성을 대상으로 그룹별 소계를 구하는 함수

  CUBE(속성명, 속성명, ...) : 인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구함

* HAVING : GROUP BY와 함께 사용하여 그룹에 조건을 지정

##### SELECT 예제

<img src="https://k.kakaocdn.net/dn/1E1NK/btqCcBRRfmo/XD0DZV4tJEJVgBy8ACxF8K/img.png" alt="img" style="zoom:50%;" />*



- 기본 검색 : 사원 테이블에 있는 모든 튜플을 검색하는 SQL문

```
SELETE * FROM 사원;
```

<img src="https://k.kakaocdn.net/dn/bLSbZ6/btqCcVvR4ry/7HeIVmgUxEjkvy9I92v481/img.png" alt="img" style="zoom:50%;" />*



```
SELECT DISTINCT 부서 FROM 사원;
사원 테이블에서 부서를 중복없이 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/bG0ynK/btqCcCiZufW/JqyR0s4W9K7jAZgrGjeTY1/img.png" alt="img" style="zoom:50%;" />*



- 조건 지정 검색

```
SELECT * FROM 사원 WHERE 부서 = "개발";
사원 테이블에서 부서가 개발인 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/PsTAx/btqCevJZ4p1/UYkBUTlWWRAfIIflVRg8Sk/img.png" alt="img" style="zoom:50%;" />*



```
SELECT * FROM 사원 WHERE 부서 = "개발" OR 부서 = "IT";
SELECT * FROM 사원 WHERE 부서 IN("개발","IT");
사원 테이블에서 부서가 개발 혹은 IT인 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/bS079d/btqCcBYKMA5/8Ze1MmcXQhKKuriZYoZEQ0/img.png" alt="img" style="zoom:50%;" />*



```
SELECT * FROM 사원 WHERE 이름 LIKE "김%";
사원 테이블에서 성이 김인 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/rpbge/btqCcUX4XdU/zswQIP3KHbcQRADBUknxh0/img.png" alt="img" style="zoom:50%;" />*



```
SELECT * FROM 사원 WHERE 부서 IS NULL;
사원 테이블에서 부서가 NULL인 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/nvIyD/btqCgRewrdi/1v1qHuykYWhEdS6qFePH8K/img.png" alt="img" style="zoom:50%;" />*



- 정렬 검색 : ORDER BY를 이용한 검색

```
SELECT * FROM 사원 ORDER BY 이름 ASC;
사원 테이블에서 이름을 오름차순으로 정렬하여 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/dKNwfJ/btqCdh6xBN4/qXJDsvkvp8Y1GGNSL5adkk/img.png" alt="img" style="zoom:50%;" />*



- 하위 질의 : 조건절에 다시 SELECT문을 넣어 그 결과를 조건으로 검색

```
SELECT 이름 FROM 사원 WHERE 이름 = (SELECT 이름 FROM 취미 WHERE 취미활동 = "축구");
취미 테이블에서 취미활동이 축구인 사원 이름의 튜플을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/cfdW9Y/btqCe30MC0G/M6mKZ1nqvCpNUVV4wAqP20/img.png" alt="img" style="zoom:50%;" />*



- 복수 테이블 : 여러 테이블을 대상으로 검색

```
SELECT 사원.이름, 사원.부서
FROM 사원, 취미
WHERE 사원.경력 *= 10 AND 사원.이름 = 취미.이름;
경력이 10년 이상인 사원의 이름, 부서, 취미활동을 검색하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/boWh8o/btqCd1CnEgM/w0pfFPJl0A8aGqhIzJKjdK/img.png" alt="img" style="zoom:50%;" />*



##### SELECT 예제 2

<img src="https://k.kakaocdn.net/dn/wHR7r/btqCeuEhuZz/XFRpIe2TAvBXfbgBLYiix1/img.png" alt="img" style="zoom:50%;" />*



- WINDOW 함수 이용

```
SELECT 부서, 경력
    ROW_NUMBER() OVER (PARTITION BY 부서 ORDER BY 경력 DESC) AS 짬순
FROM 사원;
사원 테이블에서 부서 별로 경력에 대한 일련번호를 구하여 짬순이라는 이름을 붙이는 SQL문
```

<img src="https://k.kakaocdn.net/dn/bDzv2a/btqCgnSemIS/z1qFgOzdE1fkMpcwgsuSkK/img.png" alt="img" style="zoom:50%;" />*



- GROUP BY : 그룹 지정 검색

```
SELECT 부서, AVG(경력) AS 평균
FROM 사원
GROUP BY 부서;
사원 테이블에서 부서별 경력의 평균을 구하는 SQL문
```

<img src="https://k.kakaocdn.net/dn/cKHnAP/btqCgSqWxVR/FykcN2yB4opD46BsQ0Bk41/img.png" alt="img" style="zoom:50%;" />*



- 집합 연산자를 이용한 통합 질의

```
SELECT 속성명1, 속성명2, ...
FROM 테이블명
UNION | UNION ALL | INTERSECT | EXCEPT
SELECT 속성명1, 속성명2, ...
FROM 테이블명
[ORDER BY 속성명 [ASC | DESC]];
```

- UNION : 두 SELECT 문의 결과를 통합하고 중복된 행은 한 번만 출력
- UNION ALL : 두 SELECT 문의 결과를 통합하고 중복된 행도 그대로 출력
- INTERSECT : 두 SELECT 문의 결과 중 공통된 행만 출력
- EXCEPT : 첫번째 SELECT 문의 결과에서 두 번째 SELECT 문의 결과를 제외한 행을 출력



# 4. SQL 활용

### 프로시저

---



##### 프로시저의 개요

- 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어
- 호출을 통해 실행되어 미리 저장해놓은 SQL 작업 수행
- 여러 프로그램에서 호출하여 사용 가능
- 데이터베이스에 저장되어 수행되기 때문에 스토어드 프로시저라고도 함
- 시스템의 일일 마감 작업, 일괄 작업 등에 사용



##### 프로시저의 구성

<img src="https://k.kakaocdn.net/dn/b3mXZa/btqCsHcsZK3/cYrQt6mv8KyuAEz9ayide0/img.png" alt="img" style="zoom:50%;" />*



- DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부
- BEGIN / END : 프로시저의 시작과 종료를 의미
- CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리
- SQL : DML, DCL이 삽입되어 데이터 관리를 위한 작업(조회, 추가, 수정, 삭제) 수행
- EXCPETION : BEGIN ~ END 안의 구문 실행 시 예외 처리
- TRANSACTION : 수행된 데이터 작업들을 DB에 저장할지 취소할지 결정



##### 프로시저 생성

```
CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)
[지역번수 선언]
BEGIN
    프로시저 BODY;
END;
```

- OR REPLACE : 동일한 프로시저 이름이 이미 존재하는 경우 기존의 프로시저를 대체

- 파라미터

  - IN : 호출 프로그램이 프로시저에게 값을 전달할 때 사용

  - OUT : 프로시저가 호출 프로그램에게 값을 전달할 때 사용

  - INOUT : 호출 프로그램이 프로시저에게 값을 전달하고, 프로시저 실행 후 호출 프로그램에게 값을 반환할 때 지정

  - 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정

  - 자료형 : 변수의 자료형을 지정

- 프로시저 BODY

  - 프로시저의 코드를 기록

  - BEGIN과 END 사이에 적어도 하나의 SQL 문이 존재해야 함

- 사원번호를 입력받아 해당 사원의 지급방식을 S로 변경하는 프로시저

```
CREATE OR REPLACE PROCEDURE emp_change_s(i_사원번호 IN INT)
IS
BEGIN
    UPDATE 급여 SET 지급방식 = 'S' WHERE 사원번호 = i_사원번호;
    EXCEPTION
        WHEN PROGRAM_ERROR THEN
            ROLLBACK;
    COMMIT;
END;
```

##### 프로시저 실행

```
EXECUTE 프로시저명;
EXEC 프로시저명;
CALL 프로시저명;
```

- 위 3가지 명령어 중 하나를 사용

- 위에 정의한 emp_change_s 프로시저를 사원번호 32를 인수로 하여 실행

```
EXECUTE emp_change_s(32);
EXEC emp_change_s(32);
CALL emp_change_s(32);
```

##### 프로시저 제거

```
DROP PROCEDURE 프로시저명;
```

- 위에 정의한 emp_change_s 프로시저를 제거

```
DROP PROCEDURE emp_change_s;
```





### 트리거

---



##### 트리거의 개요

- 데이터베이스 시스템에서 데이터의 삽입 갱신 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL

- 데이터베이스에 저장

- 데이터 변경 및 무결성 유지 로그 메시지 출력 등의 목적으로 사용

- DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류 발생

- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미침

##### 트리거의 구성

<img src="https://k.kakaocdn.net/dn/b1SOap/btqCtYSzWrt/IAtZiJtHTnx6QE4kcQwQhk/img.png" alt="img" style="zoom:50%;" />*



- DECLARE : 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의

- EVENT : 트리거가 실행되는 조건

- BEGIN / END : 트리거의 시작과 끝

- CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리

- SQL : DML문이 삽입되어 데이터 관리를 위한 작업(조회, 추가, 수정, 삭제) 수행

- EXCEPTION : BEGIN ~ END 안의 구문에서 예외가 발생 시 처리

##### 트리거의 생성

```
CREATE [OR REPLACE] TRIGGER 트리거명 [동작시기 옵션][동작 옵션] ON 테이블명
REFERENCING [NEW | OLD] AS 테이블명
FOR EACH ROW
[WHEN 조건식]
BEGIN
    트리거 BODY;
END;
```

- 동작 시기 옵션 : 트리거가 실행될 때를 지정

  - AFTER : 테이블이 변경된 후

  - BEFORE : 테이블이 변경되기 전

- 동작 옵션 : 트리거가 실행되게 할 작업의 종류를 지정

  - INSERT : 새로운 튜플을 삽입할 때

  - DELETE : 튜플을 삭제할 때

  - UPDATE : 튜플을 수정할 때

- NEW | OLD : 트리거가 적용될 테이블의 별칭을 지정

  - NEW : 추가되거나 수정에 참여할 튜플들의 집합(테이블)을 의미

  - OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미

- FOR EACH ROW : 각 튜플마다 트리거를 적용한다는 의미

- WHEN 조건식 : 트리거를 적용할 튜플의 조건을 지정

- 학생 테이블에 새로운 튜플이 삽입될 때 튜플에 학년 정보가 누락되었으면 학년 필드에 신입생을 치환하는 트리거를 학년 정보\_tri라는 이름으로 정의

```
CREATE TRIGGER 학생정보_tri BEFORE INSERT ON 학생
REFERENCING NEW AS new_table
FOR EACH ROW
WHEN (new_table.학년 IS NULL)
BEGIN
    :new_table.학년 := '신입생';
END;
```

##### 트리거의 제거

```
DROP TRIGGER 트리거명;
```

- 위에 정의한 학생정보\_tri를 제거

```
DROP TRIGGER 학생정보_tri;
```



### 사용자 정의 함수

---



##### 사용자 정의 함수의 개요

- 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하여 종료 시 처리 결과를 단일 값으로 반환하는 절차형 SQL

- 데이터베이스에 저장되어 DML문의 호출에 의해 실행

- 예약어 RETURN을 통해 값이 반환되기 때문에 출력 파라미터가 없음

- 테이블 조작은 할 수 없고 SELECT를 통해 검색만 할 수 있음

- 프로시저를 호출하여 사용할 수 없음

##### 사용자 정의 함수의 구성

<img src="https://k.kakaocdn.net/dn/PrIeI/btqCrPWdc3a/2xNz3k7BOigKWrbya5UeH1/img.png" alt="img" style="zoom:50%;" />*



- 프로시저의 구성과 유사

- RETURN : 호출 프로그램에 반환할 값이나 변수를 정의

##### 사용자 정의 함수 생성

```
CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
[지역변수 선언]
BEGIN
    사용자 정의 함수 BODY;
    RETURN 반환;
END;
```

- 프로시저와 유사하며 파라미터에의 구성요소는 IN, 매개변수명, 자료형이 있음

- RETURN 반환값 : 반환할 값이나 반환할 값이 저장된 변수를 호출 프로그램으로 돌려줌

- i*성별코드를 입력받아 1이면 남자, 2면 여자를 반환하는 사용자 정의 함수를 Get_S*성별로 정의

```
CREATE FUNCTION Get_S_성별(i_성별코드 IN INT)
RETURN VARCHAR2
IS
BEGIN
    IF (i_성별코드 = 1) THEN
        RETURN '남자';
    ELSE
        RETURN '여자';
    END IF;
END;
```

##### 사용자 정의 함수 실행

```
SELECT 사용자 정의 함수명 FROM 테이블명;
INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명);
DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명;
UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;
```

##### 사용자 정의 함수 제거

```
DROP FUNCTION 사용자 정의 함수명;
```

- 위에 정의한 Get*S*성별을 제거

```
DROP FUNCTION Get_S_성별;
```





### DBMS 접속 기술

---



##### DBMS 접속 기술의 개요

- 사용자가 데이터를 접속하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것

- 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달

- 웹 응용프로그램은 웹 응용 시스템을 통해 DBMS에 접근

- 웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버(WAS)로 구성

  - 사용자 ↔ 웹 서버 ↔ WAS ↔ DBMS
  
  

##### DBMS 접속 기술

- DBMS에 접근하기 위해 사용하는 API 또는 프레임워크를 의미

  - API(Application Programming Interface) : 응용 프로그램 개발 시 운영 체제나 DBMS 등을 이용할 수 있도록 규칙 등에 대해 정의해 놓은 인터페이스
  - 프레임워크 : 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체

  

- JDBC(Java DataBase Connectivity)

  - Java 언어
- 썬 마이크로시스템에서 출시
  - Java SE에 포함되어 있고 JDBC 클래스는 java.sql, javax.sql에 포함
- 접속하려는 DBMS에 대한 드라이버 필요
  

  
- ODBC(Open DataBase Connectivity)

  - 개발 언어와 상관 없음
- 마이크로소프트에서 출시
  - MS-Access, DBase, DB2, Excel, Text 등 다양한 데이터베이스에 접근 가능

  

- MyBatis

  - JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈소스 접속 프레임워크
- SQL 문장을 분리하여 XML 파일을 만들고 Mapping을 통해 SQL을 실행
  - SQL을 거의 그대로 사용할 수 있어 국내 환경에 적합

  

##### 동적 SQL

- 개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처리하는 것
- 조건에 따라 SQL 구문을 동적으로 변경하여 처리 가능
- NVL 함수를 사용할 필요가 없음
- 응용 프로그램 수행 시 SQL이 변형될 수 있어 프리컴파일할 때 구문 분석, 접근 권한 확인 등을 할 수 없음



### SQL 테스트

---



##### SQL 테스트의 개요

- SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정
- 단문 SQL은 코드를 직접 실행한 후 결과를 확인
- 절차형 SQL은 테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인
- 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고 결과를 통해 최종 확인



##### 단문 SQL 테스트

- DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 직접 실행하여 테스트

- DESCRIBE 명령어를 이용하면 DDL로 작성된 테이블이나 뷰의 속성, 자료형, 옵션들을 확인할 수 있음

- DCL로 설정된 사용자 권한은 사용자 권한 정보가 저장된 테이블을 SELECT문으로 조회하거나 SHOW 명령어로 확인할 수 있음

* Oracle : SELECT \* FROM DBA_ROLE_PRIVES WHERE GRANTEE = 사용자;
* MySQL : SHOW GRANTS FOR 사용자@호스트;



##### 절차형 SQL 테스트

- 프로시저, 사용자 정의 함수, 트리거 등의 절차형 SQL은 디버깅을 통해 기능의 적합성 여부 검증, 실행을 통해 결과를 확인하는 테스트를 수행

- SHOW 명령어를 통해 오류 내용을 확인

  - SHOW ERRORS;

- 데이터베이스에 변화를 줄 수 있는 SQL문은 주석 처리 후 출력문을 이용하여 결과 확인

  - Oracle : DBMS_OUTPUT.ENABLE; / DBMS_OUTPUT.PUT_LINE(데이터);
- MySQL : SELECT 데이터



### ORM

---



##### ORM(Object-Relational Mapping)의 개요

- 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술
- 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터 연결
- 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이
- SQL 코드를 직접 사용하지 않기 때문에 직관적이고 간단하게 데이터 조작 가능



##### ORM 프레임워크

- ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능들을 제공하는 소프트웨어
- JAVA : JPA, Hibernate, EclipseLink, DataNucleus, Ebean 등
- C++ : ODB, QxOrm 등
- Python : Django, SQLAlchemy, Storm 등
- iOS : DatabaseObjects, Core Data 등
- .NET : NHibernate, DatabaseObjects, Dapper 등
- PHP : Doctrine, Propel, RedBean 등



##### ORM의 한계

- 프레임워크가 자동으로 작성하기 때문에 의도대로 작성되었는지 확인할 필요가 있음
- 객체지향적 사용을 고려, 설계한 데이터베이스가 아닌 경우 프로젝트가 크고 복잡할수록 ORM 기술을 적용하기 어려움
- 기존의 기업들은 ORM 고려하지 않은 데이터베이스를 사용하고 있어 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요





### 쿼리 성능 최적화

---



##### 쿼리 성능 최적화의 개요

- 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화

- 최적화 전 APM을 사용하여 최적화할 쿼리 선정

  - APM(Application Performance Management/Monitoring) : 애플리케이션의 성능 관리를 위해 다양한 모니터링 기능을 제공하는 도구

- RBO(Rule Based Optimizer) : 규칙 기반 옵티마이저

- CBO(Cost Based Optimizer) : 비용 기반 옵티마이저

<img src="https://k.kakaocdn.net/dn/ckjOUW/btqCqMyPjBa/QrzfQlGSkvijENlO8ZQzZ1/img.png" alt="img" style="zoom: 80%;" />*



##### 실행 계획

- DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미
- EXPLAIN 명령어를 통해 확인
- 그래픽이나 텍스트로 표현
- 요구사항을 처리하기 위한 연산 순서가 적혀있고 연산에는 조인, 테이블 검색, 필터, 정렬 등이 있음



##### 쿼리 성능 최적화

- 실행 계획에 표시된 연산 순서, 조인 방식, 테이블 조회 방법 등을 참고하여 SQL문이 더 빠르고 효율적으로 작동하도록 코드와 인덱스를 재구성

- SQL 코드 재구성

  - WHERE 절을 추가하여 일부 레코드만 조회

  - WHERE 절에 연산자 사용 자제

  - 특정 데이터 확인 시 IN보다 EXISTS 사용

  - 힌트를 활용하여 실행 계획의 액세스 경로 및 조인 순서 변경

- 인덱스 재구성

  - SQL 코드에서 조회되는 속성과 조건들을 고려하여 인덱스 구성

  - 인덱스를 추가하거나 기존 인덱스의 열 순서 변경

  - 단일 인덱스로 쓰기나 수정 없이 읽기로만 사용되는 경우 IOT(Index-Organized Table)로 구성
