---
path: "/2020 정보처리기사 실기 요점 정리(2)-데이터 입출력 구현/"
category: "정보처리기사 실기"
tags: ["정보처리기사 실기", "정보처리기사"]
title: "2020 정보처리기사 실기 요점 정리(2)-데이터 입출력 구현"
date: "2020-06-02T22:06:00.000Z"
summary: "데이터 입출력 구현"
images: ["images/1.jpg"]
---

> 혼자 공부하면서 정리한 내용입니다. 자세한 내용은 책을 찾아서 공부하세요

# 01. 논리 데이터 저장소 확인

---

## 1. 논리 데이터 모델 검증

### (1) 논리 데이터 모델링 개념

현실 세계의 정보를 컴퓨터에 표현하기 위해 단순,추상화하여 체계적으로 표현한 개념적 모형

### (2) 논리 데이터 모델링 특성

- `정규화` : 모든 데이터를 정규화 하여 모델링

- `포용성` : 모든 엔티티 타입, 속성, 관계, 프로세스 등을 포함

- `완전성` : 모든 규칙과 관계를 완전하고 정확하게 표현

- `독립성` : 성능, 제약사항에 독립적인 모델

### (3) 논리 데이터 모델링 속성

- `개체` : 관리할 대상이 되는 실체
- `속성` : 관리할 정보의 구체적 항목
- `관계` : 개체 간의 대응 관계

### (4) 개체-관계(E-R) 모델

![img](https://lh3.googleusercontent.com/proxy/yvpENz_rpYNCdqi0sNW_oqK0n_X76JnjRsydg9EwwT4_rcQQBbm_ita_UaeWZ2jQU2kJcEMxorB-wF2-3Grbyq1O-TDhkehyJRUskJ5DDN5OejdHdwZ86XxEbnZrymuIHXhShAE6vzsXL-An2cth)\*

### (5) 정규화

#### 1) 정규화

- 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정

#### 2) 이상 현상

- 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상

* `삽입 이상` : 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입 불가
* `삭제 이상` : 연쇄 삭제 발생
* `갱신 이상` : 일부만 갱신되어 불일치성 발생

#### 3) 정규화의 단계

| 정규화   | 내용                                                                    |
| -------- | ----------------------------------------------------------------------- |
| 1 정규형 | 속성의 도메인은 `원자값`이여야 한다.                                    |
| 2 정규형 | `부분적 함수` 종속성 제거                                               |
| 3 정규형 | `이행적 함수` 종속 제거 (if A->B B->C then A->C)                        |
| BCNF     | `결정자`이면서 후보키 아닌 것 제거                                      |
| 4 정규형 | `다치 종속 존재` (복합 키 (A,B)->C일때, C가 A에만 영향을 받는것 A->->C) |
| 5 정규형 | `조인 종속성` 이용                                                      |

# 02. 물리 데이터 저장소 설계

---

## 1. 물리 데이터 모델 설계

### (1) 물리 데이터 모델링 개념

- 논리 모델을 적용하고자 하는 기술에 맞도록 상세화 해가는 과정

### (2) 물리 데이터 모델링 변환 절차

- 개체 - 테이블 변환 : 서브를 슈퍼에 통합해 테이블 1개, 엑세스 용이, 속도 향상, 가공 용이, 조인 감소,

​ 테이블 인덱스 크기 증가, 처리마다 서브타입 구분 필요

- 속성 - 컬럼 변환 : 엔티티의 PRIMARY UID는 PRIMARY KEY, SECONDARY UID는 UNIQUE KEY,

​ STRING -> VARCHAR, INT -> NUMBER

- UID를 기본키로 변환 : 개체의 UID에 해당하는 모든 속성에 대해 기본키로 선언

- 관계 - 외래키 변환 : 외래키명은 기본키 이름을 그대로 사용하나 다른 의미를 가질 경우 변경 가능

- 컬럼 유형과 길이 정의 : 적절한 유형을 정의하고, 데이터의 최대 길이를 파악하여 길이를 설정

- 반 정규화 수행 : 개발 편의성, 운영단순화를 위한 의도적 정규화 원칙 위배

  - `테이블 추가` : 중복테이블 추가(원격 조인 제거로 성능 향상), 통계테이블 추가(SUM, SVG 미리, 조회 시 성능 향상)
  - `테이블 조합` : 1:1, 1:M, 슈퍼/서브 타입 관계 테이블 병합
  - `테이블 분할` : 수직 분할 / 수평 분할
  - `테이블 제거` : 테이블 재정의, 접근하지 않는 테이블 제거
  - `컬럼 중복화` : 조인 성능 향상을 위한 중복 허용

## 2. 물리 데이터 저장소 구성

#### (1) 테이블 제약조건 설계

##### 1) 참조 무결성 제약조건

- `제한(Restricted)` : 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
- `연쇄(Cascade)`: 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제
- `널 값(Nullify)` : 참조되는 릴레이션에서 튜플을 삭제하고, 참조 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 Null값

#### (2) 인덱스(Index) 설계

##### 1) 인덱스 개념

- 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조

##### 2) 인덱스 적용 기준

- 인덱스 분포도가 10~15% 이내인 경우

  분포도 = (1/(컬럼 값의 종류)) _ 100
  분포도 = (컬럼 값의 평균 ROW 수) / (테이블의 총 Row 수) _ 100

##### 3) 인덱스 적용 대상 컬럼 선정

- MULTIBLOCK READ수가 16일 때, 테이블 크기가 16블록 이상일 경우

#### (3) 뷰 설계

##### 1) 뷰 속성

- `REPLACE` : 뷰가 이미 존재하는 경우 재생성
- `FORCE` : 본 테이블의 존재 여부에 관계없이 뷰 생성
- `NOFORCE`: 기본 테이블이 존재할 때 뷰 생성
- `WITH CHECK OPTION` : 서브 쿼리 내의 조건을 만족하는 행만 변경
- `WITH READ ONLY` : 데이터 조작어(DML) 작업 불가

#### (4) 클러스터 설계

- 데이터 접근 효율 향상을 위한 물리적 저장 방식, 검색효율 향상, 입력 수정 삭제시 부하 증가

- 분포도 넓을수록 유리, 저장공간 절약, 6블록이상 테이블, 대량 볌위를 자주 엑세스할 때

- 인덱스 사용 처리 부담되는 넓은 분포동에 활용, 빈번히 조인할 때, 반복컬럼이 정규화로 분할됐을 때

#### (5) 파티션 설계

- `레인지(범위) 파티셔닝` : 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝(1월, 2월)
- `해시 파티셔닝` : 파티션 키의 해시 함수 값에 의한 파티셔닝(#1, #2)
- `리스트 파티셔닝` : 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능한 파티셔닝(서울시, 경기도)
- `컴포지드 파티셔닝` : 범위 분할 이후 해시 함수를 적용하여 재분할하는 파티셔닝
- 파티션의 장점
  - `성능 향상`, `가용성 향상`, `백업 가능`, `경합 감소`

# 03. 물리 데이터 저장소 설계

---

## 1. 데이터 조작 프로시저 개발

### (1) 프로시저의 개념

- SQL을 이용해 생성된 데이터를 조작하는 프로그램
- 데이터베이스 내부에 저장되고 일정한 조건이 되면 자동 수행

### (2) PL/SQL의 개념

- 표준 SQL을 기본으로 Oracle에서 개발한 데이터 조작 언어
- Oracle기반의 모든 프로시저 작성에 사용되며 표준 SQL의 확장 기능 우수

### (3) PL/SQL 작성 절차

#### 1) 데이터 저장소 연결

- Java 환경의 경우 JDBC로 연결

- 드라이버 로딩
- 데이터베이스 연결
- 쿼리 전달
- 결과 수신

#### 2) 데이터 저장소 정의

- 생성 : 사번, 이름, 입사일 정보를 담은 사원 데이터 저장소를 정의하고 생성

```sql
CREATE TABLE EMPLOYEE
(
    EMPLOYEE_NO NUMBER,
    EMPLOYEE_NAME VARCHAR2(10),
    START_DATE DATE NOT NULL,
    CONSTRAINT NO_PK PRIMARY KEY(NO)
);
```

- 수정 : 부서 데이터 저장소의 부서명 속성을 변경

```sql
ALTER TABLE EMPLOYEE MODIFY (EMPLOYEE_NAME VARCHAR2(20));
```

- 삭제 : 부서 데이터 저장소를 삭제

```sql
DROP TABLE EMPLOYEE;
```

#### 3) 데이터 조작 프로시저 작성

- 사원 테이블의 정보를 입력

```sql
CREATE OR REPLACE PROCEDURE INPUT_EMPLOYEE
-- 프로시저명 : 해당 프로시저를 호출할 때 사용할 이름, 인수를 지정

(
    P_NO IN NUMBER,
    P_NAME IN VARCHAR2(10)
)
IS
BEGIN
	INSERT INTO EMPLOYEE(EMPLOYEE_NO,EMPLOYEE_NAME)
		VALUES (P_NO, P_NAME);
-- 기능 구현 : 사원 테이블의 이름, 사번을 저장하는 기능 구현

COMMIT;
END;
EXEC INPUT_EMPLOYEE('1','홍길동');
-- 프로시저 호출 : 프로시저에 IN이 있고 기본 값이 없어 인수 값 필요

```

#### 4) 데이터 검색 프로시저 작성

- 검색 조건에 맞는 데이터 조회

```sql
CREATE OR REPLACE PROCEDURE SEARCH_PROC
-- 프로시저명 : 해당 프로시저를 호출할 때 사용할 이름, 인수를 지정
(
    P_REG_DATE IN VARCHAR2, --등록일
    P_ITEM_CODE IN VARCHAR2,  --품목명
    P_COMPANY_CODE IN VARCHAR2,  --법인코드
)
IS
BEGIN
	SELECT A.REG_DATE, B._ITEM_CODE, B._COMPANY_CODE
	FROM COMPANY A LEFT OUTER JOIN ITEM B ON A.COMPANY_CODE = B.COMPANY_CODE
	WHERE P_REG_DATE = A.REG_DATE
-- 기능 구현 : 사원 테이블의 이름, 사번을 저장하는 기능 구현

COMMIT;
END;
EXEC INPUT_EMPLOYEE('1','홍길동');
-- 프로시저 호출 : 프로시저에 IN이 있고 기본 값이 없어 인수 값 필요

```
