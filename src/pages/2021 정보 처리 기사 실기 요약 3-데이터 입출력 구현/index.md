---

path: "/2021 정보 처리 기사 실기 요약 3-데이터 입출력 구현/"
category: "정보처리기사 실기 요약"
tags: ["정보처리기사 실기 요약", "정보처리기사", "정처기"]
title: "2021 정보 처리 기사 실기 요약 3-데이터 입출력 구현"
date: "2021-05-18T17:22:00.000Z"
summary: "2021 정보 처리 기사 데이터 입출력 구현 요약 입니다. 정처기 공부를 할 때 활용하세요."
images: ["images/1.jpg"]
---

> 정보처리기사 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 책을 참고해서 공부하세요

> 2021 정보 처리 기사 데이터 입출력 구현 요약 입니다. 정처기 공부를 할 때 활용하세요.

# 1. 데이터 모델의 개념

---
### 1) 데이터 모델
- `데이터 모델` : _현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형_
- 데이터 모델 구성 요소~~(계에속어관릴)~~
  - `개체(Entity)` : _관리할 대상이 되는 실체_
  - `속성(Attribute)`: _관리할 정보의 구체적 항목_
  - `관계(Relationship)` : _개체 간의 대응 관계_

### 2) 데이터 모델의 종류~~(개논물)~~
  * `개념적 데이터 모델` : 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
  * `논리적 데이터 모델` : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
  * `물리적 데이터 모델` : 실제 컴퓨터에 데이터가 저장되는 방법으로 정의하는 물리 데이터베이스 설계 과정

### 3) 데이터 모델에 표시할 요소~~(구연제물)~~
  * `구조(Structure)` : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
  * `연산(Operation)` : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
  * `제약 조건(Constraint)` : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
  * `물리적 데이터 모델` : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 데이터베이스 설계 과정




# 2. 정규화

---
### 1) 개요
* 정규화 : _관계형 데이터베이스의 설계에서 중복을 최소화하여 데이터를 구조화하는 프로세스_~~(관중데구)~~~~(도부이걸다조)~~
* 비정규 릴레이션 : `도메인`이 원자값
* 1NF : `부분적 함수` 종속 제거
* 2NF : `이행적 함수` 종속 제거
* 3NF : `결정자`이면서 후보키가 아닌 것 제거
* BCNF : `다치 종속`
* 4NF : `조인 종속성` 이용
* 5NF : 이행적 함수적 종속 (A → B이고 B → C일 때 A → C를 만족하는 관계)

### 2) 이상 현상~~(삽삭갱)~~
- `이상(Anomaly)`_데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상_~~(중릴비)~~
  - `삽입 이상` : 정보 저장 시 해당 정보의 불필요한 세부 정보를 입력해야 하는 경우
  - `삭제 이상` : 원치 않는 다른 정보가 같이 삭제되는 현상
  - `갱신 이상` : 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

### 3) 함수적 종속

#### (1) 함수적 종속

* 어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 때 _X의 값 각각에 대해 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속_
* 표현: X → Y


*  X를 *결정자(Determinant)*라 하고, Y를 *종속자(Dependent)*라고 함

|    id    | name |  department  |
| :------: | :--: | :----------: |
| 20800399 |  A   | 컴퓨터공학부 |
| 21300758 |  B   |   경영학부   |
| 21400001 |  C   |  기계공학부  |

* 학번에 의해서 학생이름과 학부는 고유하게 구분되므로 학생이름, 학부 속성은 학번에 함수적으로 종속
* 학번은 _결정자_, 학생이름과 학부는 _종속자_
* 학번 -> (학생이름, 학부)

* 속성 값은 계속 변할 수 있는 것이기 때문에 속성 자체가 가지는 특성과 의미를 기반으로 판단



#### (2) 완전 함수 종속(Full Functional Dependency)

* _종속자가 기본키에만 종속_ 
* 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우

#### (3) 부분 함수적 종속(Partial Functional Dependency)

* _릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속_
* 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속

#### (4) 이행적 함수 종속(Transitive Functional Dependency)

* _릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때_
* X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우



# 3. 정규화(Normalization)의 과정
---
### 1) 제 1정규형(1NF)
* `원자 값`
* _릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성_

#### 1) 변경 전

|   학번   |            과목코드             |   성적    | 이름 |
| :------: | :-----------------------------: | :-------: | :--: |
| 20800399 | CSE011101, CSE022202, CSE033303 | A+, A, B+ | YDH  |

#### 2) 변경 후

|   학번   | 과목코드  | 성적 | 이름 |
| :------: | :-------: | :--: | :--: |
| 20800399 | CSE011101 |  A+  | YDH  |
| 20800399 | CSE022202 |  A   | YDH  |
| 20800399 | CSE033303 |  B+  | YDH  |

### 2) 제 2정규형 (2NF)
* `부분 함수적 종속 제거`
* 제1정규형에 속하면서, _기본키가 아닌 모든 속성이 기본키에 완전 함수 종속_

#### 1) 변경 전

|  _학번_  | _과목코드_ | 성적 |     학부     | 등록금 |
| :------: | :--------: | :--: | :----------: | :----: |
| 20800399 | CSE011101  |  A+  | 컴퓨터공학부 |  350   |
| 20800399 | CSE022202  |  A   | 컴퓨터공학부 |  350   |
| 20800399 | CSE033303  |  B+  | 컴퓨터공학부 |  350   |
| 21300758 | MEC011101  |  F   |   경영학부   |  300   |
| 21400001 | POD032939  |  C+  |  기계공학부  |  400   |
| 21500399 | CSE011101  |  D   | 컴퓨터공학부 |  350   |

#### 2) 변경

* 테이블의 함수 종속 관계

```bash
학번, 과목코드 -> 성적
학번, 과목코드 -> 학부
학번, 과목코드 -> 등록금
학번 -> 학부
학번 -> 등록금
학부 -> 등록금
```

* 현재 학번->학부, 학번->등록금 두개의 부분 함수 종속성을 가지고 있고 이를 제거


#### 3) 변경 후

|  _학번_  |     학부     | 등록금 |
| :------: | :----------: | :----: |
| 20800399 | 컴퓨터공학부 |  350   |
| 21300758 |   경영학부   |  300   |
| 21400001 |  기계공학부  |  400   |
| 21500399 | 컴퓨터공학부 |  350   |

|  _학번_  | _과목코드_ | 성적 |
| :------: | :--------: | :--: |
| 20800399 | CSE011101  |  A+  |
| 20800399 | CSE022202  |  A   |
| 20800399 | CSE033303  |  B+  |
| 21300758 | MEC011101  |  F   |
| 21400001 | POD032939  |  C+  |
| 21500399 | CSE011101  |  D   |

### 3) 제 3 정규형 (3NF)
* `이행 함수 종속 제거`
* 제 2 정규형에 속하면서, _기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않음_


#### 1) 변경 전

|  _학번_  |     학부     | 등록금 |
| :------: | :----------: | :----: |
| 20800399 | 컴퓨터공학부 |  350   |
| 21300758 |   경영학부   |  300   |
| 21400001 |  기계공학부  |  400   |
| 21500399 | 컴퓨터공학부 |  350   |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
학번 -> 학부
학부 -> 등록금
학번 -> 등록금
```

* X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 (X, Y), (Y, Z) 두 릴레이션으로 분해


#### 3) 변경 후

|  _학번_  |     학부     |
| :------: | :----------: |
| 20800399 | 컴퓨터공학부 |
| 21300758 |   경영학부   |
| 21400001 |  기계공학부  |
| 21500399 | 컴퓨터공학부 |

|    _학부_    | 등록금 |
| :----------: | :----: |
| 컴퓨터공학부 |  350   |
|   경영학부   |  300   |
|  기계공학부  |  400   |


### 4) 보이스-코드 정규형(BCNF)
* `결정자 함수`

* _결정자 함수이면서 후보키가 아닌 것 제거_


#### 1) 변경 전

| _사용자 명_ | 책이름           | 배급사 |
| ----------- | ---------------- | ------ |
| 홍길동      | 블록체인 입문    | B      |
| 홍길동      | 자바 입문        | U      |
| 임꺽정      | 블록체인 입문    | B      |
| 임꺽정      | 자연어 처리 심화 | C      |
| 임꺽정      | 인공지능 입문    | K      |
| 성춘향      | 자바 입문        | U      |
| 성춘향      | 인공지능 입문    | K      |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
사용자명, 책이름 -> 배급사
배급사 -> 책이름
```

* 위 테이블의 후보키는 '사용자 명', '책이름' 이고 이 두 컬럼을 통해 레코드를 구별할 수 있지만 배급사에 의해 책이름이 결정되는 관계가 존재하여 BCNF 를 만족하지 않음


#### 3) 변경 후

| _사용자 명_ | 책이름           |
| ----------- | ---------------- |
| 홍길동      | 블록체인 입문    |
| 홍길동      | 자바 입문        |
| 임꺽정      | 블록체인 입문    |
| 임꺽정      | 자연어 처리 심화 |
| 임꺽정      | 인공지능 입문    |
| 성춘향      | 자바 입문        |
| 성춘향      | 인공지능 입문    |

| _배급사_ | 책이름           |
| -------- | ---------------- |
| B        | 블록체인 입문    |
| U        | 자바 입문        |
| C        | 자연어 처리 심화 |
| K        | 인공지능 입문    |



### 5) 4차 정규화(4NF)

* `다치 종속성 제거`
* 특정 속성값에 따라 선택적인 속성 분리

#### 1) 변경 전

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
개발자 -> 자격증
개발자 -> 언어
```

* 개발자마다 자격증 값들이 여러 개 존재하고, 특정 개발자마다 언어 값들이 여러 개 존재하는 경우
* 개발자별로 여러 자격증 값을 가지고 있고 개발자별로 여러 언어값을 가지고 있으므로 개발자, 자격증/ 개발자, 언어 테이블로 분리하여 관리하면 다치 종속 관계 제거

#### 3) 변경 후

| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |

| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
| 장길산 | JAVA |



### 6) 5차 정규화(5NF)

* `조인 종속성 제거`

#### 1) 변경 전

| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |

---



| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
|        | JAVA |

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |



#### 2) 변경

* 4차 정규화 테이블에 대해 조인 연산을 수행하면 4차 정규화 수행 전 데이터와 다르게 되는 문제인 조인 종속성 발생
* 조인 종속 관계를 제거하기 위해서는 모든 속성 관계인 _개발자, 자격증_, _개발자, 언어_ 뿐 아니라 _자격증, 언어_ 관계에 대한 테이블을 만들어 줌으로써 조인했을 때 정확히 원래의 데이터를 복원할 수 있음



#### 3) 변경 후

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |

---



| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |



| 자격증             | 언어 |
| ------------------ | ---- |
| 정보처리기사       | C    |
| 빅데이터 분석 기사 | C++  |
| 정보처리기사       | JAVA |

| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
| 장길산 | JAVA |



# 4. 논리 데이터 모델의 물리 데이터 모델로 변환

---

- `엔티티를 테이블로 변환` : 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- `슈퍼타입 기준 테이블 변환` : 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 변환
- `서브타입 기준 테이블 변환` : 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 변환
- `개별타입 기준 테이블 변환` : 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환
- `속성을 컬럼으로 변환` : 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
- `관계를 외래키로 변환` : 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환



# 5. 반정규화(Denormalization)

---

- `반정규화` : _정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위_ ~~(반정데통중분 의정위)~~
- _테이블 통합_ : 
  - 두 개의 테이블이 조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
- _테이블 분할_ :
  - `수평 분할` : 레코드를 기준으로 테이블을 분할하는 것으로, 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할
  - `수직 분할` : 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할



# 6. 설계

---

### 1) 인덱스 설계

* _데이터 레코드를 빠르게 접근하기 위해 키 값, 포인터 쌍으로 구성되는 데이터 구조_
* `클러스터드 인덱스` : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
* `넌클러스터드 인덱스` : 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식

#### (1) 트리 기반 인덱스

* _인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것_
* 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용

##### 1) B 트리 인덱스

* 일반적으로 사용되는 인덱스 방식으로 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고자 하는 데이터를 검색
* 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차손으로 저장
* 모든 리프노드는 같은 레벨

##### 2) B+ 트리 인덱스

* B 트리의 변형. 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분
* 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공
* 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
* 인덱스 세트에 잇는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리가 가능

#### (2) 비트맵 인덱스

* 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법

#### (3) 함수 기반 인덱스

* 컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용

#### (4) A비트맵 조인 인덱스

- 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름

#### (5) 도메인 인덱스

- 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스(Extensible Index)라고도 함

### 2) 뷰 설계

#### (1) 뷰

- _사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블_
- 저장장치 내에 물리적으로 존재하지 않지만 사용자에게는 있는 것처럼 간주
- CREATE문으로 정의하고, DROP문으로 제거
- 데이터의 논리적 독립성을 제공

### 3) 클러스터 설계

#### (1) 뷰

- _데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 방법_
- 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장
- 클러스터링된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하

- `단일 테이블 클러스터링` : 처리 범위가 넓은 경우
- `다중 테이블  클러스터링`: 조인이 많이 발생하는 경우 사용

### 4) 파티션 설계

#### (1) 파티션

* _대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것_ 

#### (2) 파티션의 종류

| 종류      | 분할 방법                                              |
| --------- | ------------------------------------------------------ |
| 범위 분할 | 지정한 열의 값을 기준으로 분할                         |
| 해시 분할 | 해시 함수를 적용한 결과 값에 따라 데이터를 분할        |
| 조합 분할 | 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할 |

* _인덱스 파티션_ : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

# 7. 트랜잭션(Transaction)

---

### 1) 개요

* _논리적 기능을 수행하기 위한 기본 단위_

-  데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

### 2) 트랜잭션의 속성~~(원일독지)~~

#### (1) 원자성(Atomicity)

* _한 트랜잭션 대의 모든 연산이 완전히 수행되거나 전혀 수행되지 않음_

* 트랜잭션의 모든 연산이 정상적으로 수행 완료되지 않거나 수행 중 오류가 발생할 경우 어떠한 연산도 반영하지 않음
#### (2) 일관성(Consistency)

* _트랜잭션이 수행되기 전과 후에도 데이터베이스는 일관된 상태를 유지_

-  트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환

#### (3) 독립성(Isolation)

* _하나의 트랜잭션의 실행은 동시에 실행중인 다른 트랜잭션의 간섭을 받아서는 안됨_

*  둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음

#### (4) 지속성(Durability)

* _성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함_






# 8. 데이터베이스

---

- `데이터베이스` : 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

- _데이터베이스의 정의_~~(통저운공)~~
  - `통합된 데이터` : 검색의 효율성을 위해 중복이 최소화된 데이터의 모임
  - `저장된 데이터` : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 데이터
  - `운영 데이터` : 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안될 반드시 필요한 데이터
  - `공용 데이터` : 여러 응용 시스템들이 공동 으로 소유하고 유지하는 데이터

- `DBMS(데이터베이스 관리 시스템)` : 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어

- _DBMS의 필수 기능_~~(정조제)~~
  - `정의(Definition) 기능` : 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용방식, 제약 조건 등을 명시하는 기능
  - `조작(Manipulation) 기능` : 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  - `제어(Control) 기능` : 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어하는 기능
  
- _DBMS의 종류_~~(계망관)~~
  - `계층형 DBMS` : 트리(Tree) 구조를 이용해서 데이터의 상호관계를 계층적으로 정의한 DBMS로, 개체 타입 간 에는 상위와 하위 관계가 존재하며, 일대다(1:N) 대응 관계만 존재
  - `망형 DBMS` : 그래프를 이용해서 데이터 논리 구조를 표현한 DBMS로, 상위와 하위 레코드 사이에서 1:1, 1:N, N:M(다대다) 대응 관계를 모두 지원
  - `관계형 DBMS` : 계층형과 망형 DBMS의 복잡한 구조를 단순화시킨 가장 널리 사용되는 DBMS로, 파일 구조처 럼 구성한 2차원적인 표(를 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
  
- 데이터가 저장될 공간을 정의하는 것, 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영

- 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 증가

- `데이터 접근성을 향상시키는 설계 방법`

  - 테이블의 테이블스페이스와 인덱스의 테이블 스페이스를 분리하여 구성
  - 테이블 스페이스와 임시 테이블스페이스를 분리하여 구성
  - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

  

### 분산 데이터베이스

---

- _논리적으로는 같은 시스템에 속하지만 물리적으로는 컴퓨터 네트워크를 통해 분산되어 있는 데이터베이스_
- `위치 투명성` : 접근하려는 데이터 베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 접근할 수 있음
- `중복 투명성` : 동일한 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용할 수 있고, 시스템은 자동으로 여러 데이터에 대한 작업을 수행
- `병행 투명성` : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실행되더라도 그 트랜잭션들의 수행 결과는 서로 영향을 받지 않음
- `장애 투명성` : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션은 정확하게 수행



### 데이터베이스 용어

- `데이터 웨어하우스` : 급증하는 다량의 데이터를 효과적으로 분석하여 정보화하고 이를 여러 계층의 사용자들이 효율적으로 사용할 수 있도록 한 데이터베이스
- `데이터 마트` : 전사적으로 구축된 데이터 웨어하우스로부터 특정 주제나 부서 중심으로 구축된 소규모 단일 주제의 데이터 웨어하우스
- `데이터 마이닝` : 데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법
- `OLAP` : 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사 결정에 활용하는 방식
- `OLTP` : 온라인 업무 처리 형태의 하나로 네트워크상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 검색하는 등의 단위 작업을 처리하는 방식



# 9. ER(Entity Relationship) 모델 

---

### 1) 개체-관계(E-R) 모델

  * 개체-관계(E-R) 모델: _현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위한 모델_
  * 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터 첸에 의해 제안

| 구성           | 기호 | 기호이름   |
| -------------- | ---- | ---------- |
| 개체           | □    | (사각형)   |
| 관계           | ◇    | (마름모)   |
| 속성           | ○    | (타원)     |
| 다중 값 속성   | ◎    | (이중타원) |
| 관계-속성 연결 | -    | (선)       |

* `관계` : 2개 이상의 개체 사이에 존재하는 연관성

- `관계 타입` : 같은 관계들의 집합 또는 틀
- 관계는 관계에 참여하는 개체 타입의 개수에 대한 차수와 관계에 참여하는 개체 어커런스의 개수에 대한 대응 카디널리티를 갖음



### 2) 차수에 따른 관계의 종류

- `단항 관계` : 관계에 참여하고 있는 개체 타입이 1개인 관계
- `이항 관계` : 관계에 참여하고 있는 개체 타입이 2개인 관계
- `삼항 관계` : 관계에 참여하고 있는 개체 타입 이 3개인 관계
- `n항 관계` : 관계에 참여하고 있는 개체 타입이 n개인 관계



### 3) 대응 카디널리티에 따른 관계의 종류

- `1:1 관계` : 관계에 참여하고 있는 두 개체 타입이 모두 하나씩의 개체 어커런스를 갖는 관계
- `1:N 관계` : 관계에 참여하고 있는 개체 타입 중 한 개체 타입은 여러 개의 개체 어커런스를 가질 수 있고, 다른 한 개체 타입은 하나의 개체 어커런스를 갖는 관계
- `N:M 관계` : 관계에 참여하고 있는 두 개체 타입 모두 여러 개의 개체 어커런스를 가질 수 있는 관계



# 10. 관계 데이터베이스의 Relation 구조

---

- _릴레이션_ : 데이터들을 표(Table)의 형태로 표현한 것, 릴레이션 스키마(=구조를 나타냄)와 릴레이션 인스턴스(=실제 값들)로 구성

- `튜플(Tuple)`
  - 튜플 = 각각의 행 = 레코드=카디널리티
  - 속성의 모임으로 구성
  - `튜플의 수 = 카디널리티(Cardinality) = 행 = 기수 = 대응수`~~(튜카행기대)~~
- `속성(Attribute)`
  - 각각의 열( = 데이터 항목 또는 데이터 필드)
  - 데이터베이스를 구성하는 가장 작은 논리적 단위
  - 개체의 특성을 기술.
  - `속성의 수 = 디그리(Degree) = 차수`
- `도메인`
  - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합
  - 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용
- `릴레이션 인스턴스` : 데이터 개체를 구성하고 있는 속성들에 데이터 타입이 정의되어 구체적인 데이터 값을 갖고 있는 것

# 11. ER 모델을 관계형 데이터 모델로 변환

---

- 개념적 데이터 모델인 ER 모델을 논리적 데이터 모델인 릴레이션 스키마로 변환하는 것으로, 매핑 룰이라고도 함
- 개체 A, B와 관계 Y로 이루어진 ER 모델을 관계형 데이터 모델에서의 릴레이션 스키마로 변환하는 과정은 다음과 같음
  - 개체 A, B는 각각 독립적인 릴레이션 A, B로 표현된다. 또한, ER 도형에서의 각 개체의 속성들은 각 릴레이션의 속성들로 정의되고, 기본키는 밑줄을 그어 표시
  - 관계 Y가 1:1 관계 : 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가하거나 릴레이션 B의 기본키를 릴 레이션 A의 외래키로 추가하여 표현
  - 관계 Y가 1:N 관계 : 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가하여 표현
  - 관계 Y가 N:M 관계 : 릴레이션 A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현



# 12. 키(Key)의 개념 및 종류

---

- `키(Key)` : 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성
- `슈퍼키(Super Key)` : 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로, 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못함
- `후보키(Candidate Key)` : 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, 유일성과 최소성을 모두 만족
  - _유일성_ : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
  - _최소성_ : 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 함ㄴ
- `기본키(Primary Key)` : 후보키 중에서 특별히 선정된 키 로 중복된 값과 NULL 값을 가질 수 없음
- `대체키(Alternate Key)` : 후보키 중에서 선정된 기본키를 제외한 나머지 후보키를 의미함
- `외래키(Foreign Key)` : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미하며, 릴레이션 간의 관계를 표현할 때 사용



# 13. 무결성(Integrity)

---

- `무결성` : _데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미_~~(개도참사널고키관)~~
  - `개체 무결성(실체 무결성)` : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없음
  - `도메인 무결성(영역 무결성)` : 주어진 속성 값이 정의된 도메인에 속한 값이어야 함
  - `참조 무결성` : 외래키 값은 Null이거 나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음
  - `사용자 정의 무결성` : 속성 값들이 사용자가 정의한 제약조건에 만족해야 함
  - `NULL 무결성` : 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 함
  - `고유 무결성` : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 함
  - `키 무결성` : 하나의 릴레이션에는 적어도 하나의 키가 존재해야 함
  - `관계 무결성` : 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정
