---
path: '/벡엔드 개발자 면접 질문 - 데이터베이스/'
category: '기술 면접'
tags: ['벡엔드', '개발자', '면접', '기술면접', 'CS']
title: '벡엔드 개발자 면접 질문 - 데이터베이스'
date: '2021-11-228T03:00:00.000Z'
summary: '벡엔드 개발자 면접 질문 - 데이터베이스'
images: ['images/2.jpg']
---

> 백엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요

# 3. 데이터베이스

---

### 1) 데이터베이스 인덱스

---

- 검색성능을 향상시키기 위함

- 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 함

- `장점` : 빠른 검색 성능(R)

- `단점` : 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행(U, D)

### 2) 트랜잭션

- _데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위_
- 트랜잭션에는 여러개의 연산이 수행될 수 있음
- 트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공

#### (1) 트랜잭션의 특성(ACID)

### 1) Atomicity (원자성)

- _트랜잭션과 관련된 일은 모두 실행 혹은 모두 실행되지 않음_
- Transaction은 최소 작업 단위로 더이상 나눌 수 없음
- ex) 송금 transaction은 출금(A 계좌로 부터)과 입금(B 계좌로)이라는 두 가지 작업을 수행하고 있음, 하지만 이는 하나의 transaction으로 묶여있기 때문에 위의 두 작업은 나눠질 수 없음
- 출금만 실행되고 입금이 수행되지 않는다면 이는 transaction이라 부를 수 없음
- 출금만 실행되고 입금이 실행되지 않는다면 돈이 증발해버리는 심각한 문제가 발생
- 이러한 문제를 방지하기 위해 출금과 입금을 하나의 transaction으로 정의하고 입금이 실행되지 않으면 출금 또한 취소해버림으로Tj(rollback) 출금과 입금 과정을 마치 하나의 작업처럼 실행

### 2) Consistency(일관성)

- _트랜잭션이 성공했다면, 데이터베이스는 그 일관성을 유지_.
- 일관성은 특정한 조건을 두고, 그 조건을 만족하는지를 확인하는 방식으로 검사
- 일관성 : DBMS에서 제공하는 제약조건을 어기지 않고 데이터의 논리적 오류가 없음을 의미

* ex) 송금 예제에서, A가 만원을 이체했는데 B에서 오천원만 받았다면 이는 논리적 오류

### 3) Isolation(독립성)

- _트랜잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록 함_
- 임계영역을 두는 것으로 달성할 수 있음
- ex ) A 계좌에서 B계좌로 이체하는 transaction이 실행되는 도중 A 계좌의 모든 잔액을 출금하는 transaction이 실행되었다고 가정
- 만약 첫 번째 transaction이 A의 계좌에서 이체 금액을 출금한 상태에서 두 번째 transaction이 잔액을 조회하고 이를 출금하려고한다면 문제가 발생할 수 있음
- 아직 첫 번째 transaction은 완료된 상태가 아니기 때문에 만약 도중에 문제가 생겨 이체가 취소된다면 두 번째 transaction이 조회한 금액은 잘못된 금액(이체 금액이 빠져있는)이기 때문
- table, 혹은 해당 row에 lock을 걸어버리는 것이지만 이러한 방법은 동시성을 떨어뜨려 성능에 악영향을 미칠 수 있음

### 4) Durability (지속성)

- _성공적으로 트랜잭션이 수행되었다면, 그 결과는 완전히 반영_

- 완전히 반영되면 로그를 남기게 되는데 이 로그를 이용해서 트랜잭션 수행전 상태로 되돌릴 수 있어야 함

- 트랜잭션은 로그저장이 완료된 시점에서 종료가 되어야 함

#### 2) 트랜잭션 격리 수준(Transaction Isolation Levels)

- 고립도와 성능의 트레이드 오프를 조절
- `READ UNCOMMITTED` : 다른 트랜잭션에서 커밋되지 않은 내용도 참조
- `READ COMMITTED` : 다른 트랜잭션에서 커밋된 내용만 참조
- `REPEATABLE READ` : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조
- `SERIALIZABLE`: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 함
- 정규화 : 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것

### 3) RDBMS / NOSQL

---

#### (1) RDBMS(U)

- _데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스_
- 수정 (update)에 좋음
- SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 중요

- 명확한 데이터 구조를 보장, 중복을 피할 수 있음. 중복 데이터가 존재하지 않아 저장 공간을 절약할 수 있으며, 데이터 수정 (update)이 용이

- 테이블 간의 관계를 통해서 큰 규모의 데이터를 여러 개의 테이블 (ex. user, item, buying)에 분산 저장 가능.

- 테이블 관계가 복잡해질수록 JOIN이 많은 SQL 쿼리가 만들어 질 수 있음

- 데이터 수정 (update)가 자주 발생하는 시스템이거나, 명확한 스키마가 중요한 경우

#### (2) NOSQL(C, R)

- _자유로운 형태로 데이터를 저장_
- 쓰기 (write)와 읽기 (read)에 특화
- 수평확장을 할 수 있고 분산처리를 지원
- key-value store, bigtable, dynamo, document db, graph db
- 스키마없이 유연하게 데이터를 저장/관리할 수 있는 데이터베이스
- 데이터 중복이 허용되기에 수정 (update)을 위해서는 중복으로 저장된 데이터를 검색하여 모두 수정해야하는 번거로움이 있으며, 엄격한 스키마가 없다보니 데이터에 대한 규격화된 결과 값을 얻을 수 없음
- 정확한 데이터 구조를 알지 못하거나, 데이터 수정 (update)보다는 쓰기 (write)와 읽기 (read)가 더 자주 발생하는 경우 NoSQL이 적합
