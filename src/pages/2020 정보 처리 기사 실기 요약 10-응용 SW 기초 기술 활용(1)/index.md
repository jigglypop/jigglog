---
path: "/2020 정보 처리 기사 실기 요약 10-응용 SW 기초 기술 활용(1)/"
category: "정보처리기사 실기 요약"
tags: ["정보처리기사 실기 요약", "정보처리기사", "정처기"]
title: "2020 정보 처리 기사 실기 요약 10-응용 SW 기초 기술 활용(1)"
date: "2020-07-17T21:01:00.000Z"
summary: "2020 정보 처리 기사 응용 SW 기초 기술 활용 입니다. 정처기 공부를 할 때 활용하세요."
images: ["images/1.jpg"]
---

> 정보처리기사 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 책을 참고해서 공부하세요

> 2020 정보 처리 기사 응용 SW 기초 기술 활용 요약 입니다. 정처기 공부를 할 때 활용하세요.

# 1. 운영체제(OS)

---

- _컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임_
- `처리 능력` : 일정 시간 내에 시스템이 처리하는 일의 양
- `반환 시간` : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- `사용 가능도` : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- `신뢰도` : 시스템이 주어진 문제를 정확하게 해결하는 정도
- _기능_
  - 프로세서, 기억장치, 입·출력장치, 파일 및 정보 등 의 자원 관리
  - 자원의 효과적인 경영 스케줄링 기능 제공
  - 사용자와 시스템 간의 편리한 인터페이스 제공
  - 시스템의 각종 하드웨어와 네트워크 관리·제어
  - 시스템의 오류 검사 및 복구, 데이터 관리, 데이터 및 자원 공유

# 2. Windows의 특징

---

- `GUI(그래픽 사용자 인터페이스)` : 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식
- `선점형 멀티태스킹(Preemptive Multi-Tasking)` : 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
- `자동 감지 기능(PnP)`: 컴퓨터 시스템에 프 린터나 사운드 카드 등의 하드웨어를 설치했을때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영 체제가 자동으로 구성해 주는 기능
- `OLE(Object Linking and Embedding)` : 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능

# 3. UNIX / LINUX

---

- UNIX
  - 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제
  - 시분할 시스템을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템
  - 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음
  - 다중 사용자, 다중 작업을 지원
  - 트리(Tree) 구조의 파일 시스템
- LINUX
  - 1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제
  - UNIX와 완벽하게 호환되고, 대부분의 특징이 UNIX 와 동일, 프로그램 소스 코드가 무료로 공개

# 4. UNIX 시스템의 구성

---

- `커널(Kernel)`
  - UNIX의 가장 핵심적인 부분, 하드웨어를 보호(캡슐화)하고, 프로그램들과 하드웨어 간의 인터페이스 역할을 담당
  - 컴퓨터 부팅 시 주기억장치에 적재되어 상주하면서 실행
  - 프로세스, 기억장치, 파일, 입·출력 관리, 프로세스 간 통신, 데이터 전송 및 변환 등
- `쉘(Shell)`
  - 사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
  - 시스템과 사용자 간의 인터페이스를 담당
  - DOS의 COMMAND.COM과 같은 기능을 수행
  - 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리가 가능
  - 종류 : Bourne Shell, C Shell, Korn Shell 등

# 5. Windows의 CLI 기본 명령어

---

- `dir` : 현재 디렉터리의 파일 목록 표시
- `copy` : 파일 복사
- `del` : 파일 삭제
- `type` : 파일 내용 표시
- `ren` : 파일 이름 변경
- `md` : 디렉터리 생성
- `cd` : 동일한 드라이브에서 디렉터리 위치 변경
- `cls` : 화면 내용 지움
- `attrib` : 파일 속성 변경
- `find` : 파일에서 문자열 찾음
- `chkdsk` : 디스크 상태 점검
- `format` : 디스크 표면을 트랙과 섹터로 나누어 초기화
- `move` : 파일 이동



# 6. UNIX / LINUX의 CLI 기본 명령어

---

- _검색 기능 명령어_
- `ls` : 현재 디렉터리의 파일 목록 표시
  - -a : 전부 
  - -l : 상세정보 (소유자, 크기, 수정시간 등)
  - -S : 크기별 정렬
  - -h : 단위 표현 변경 

```bash
ls -al 
// 리스트 상세하게 출력
```

* `man` : 명령어 도움말

```bash
man ls
// ls 명령어 도움말 출력
```

* `cd` : 디렉터리 위치 변경

```bash
cd /abc
// 루트에서 abc 디렉토리로 이동
cd ./abc
// 현재 위치에서 abc 디렉토리로 이동
```

* `pwd` : 현재 작업중인 디렉터리 경로를 화면에 표시

```bash
pwd
```

- `mkdir` : 디렉터리 생성

```bash
mkdir /test1/abc
// test1 폴더에 abc 폴더 생성
```

* `rmdir` : 디렉터리 삭제

```bash
rmdir /test1
// test1 폴더 삭제
```

* `rm` : 파일 삭제
  * -r : 하위 디렉토리 삭제
  * -f : 강제로 삭제
  * -i : 파일 지울지 물어봄
  * -v : 삭제 정보 보여줌

```bash
rm /test/abc.txt
// test 디렉토리 안의 abc.txt 파일 삭제
rm -fr/test/*
// test 디렉토리 안의 모든 디렉토리와 파일 삭제
```

* `mv` : 파일 이동
  * -i : 동일한 파일명 있을 경우 덮어쓸지 물어봄

```bash
mv /test1/aaa.txt /test2/bbb.txt
// test1의 aaa.txt파일을 test2 디렉토리로 옮기고 파일명을 bbb.txt로 변경
```

* `touch` : 용량 0의 파일 생성

```bash
touch abc.txt
// 내용이 없는 abc.txt 생성
touch a.txt b.txt c.txt
// 내용이 없는 파일 3개 생성
touch -t 01051054 
// 1월 5일 10시 54분으로 시간 수정
```

* `cat/more` : 파일 내용을 화면에 표시(cat : 짦게, more : 길게)

```bash
cat abc.txt

more abc.txt
```

* `head` : 처음 10줄을 출력

```bash
head abc.txt
```

* `tail` : 마지막 10줄을 출력
  * -f : 실시간으로 조회 (Log 확인시 주로 사용)

```bash
tail abc.txt
tail -f abc.log
// abc.log 파일이 변경될 때마다 실시간 출력
```

* `clear` : 화면을 clear함
* `wc` : 단어 줄 수를 세어줌
  * -l : line 수를 Count

```bash
wc -l abc.txt        
// abc.txt파일의 Line 수를 Count
```

* `alias/unalias` : 별칭을 지어주고 삭제

```bash
alias a='cd /a/b/c/d/e/f/g'        
// alias 지정 후 a를 입력하면 해당 명령어가 실행됨
unalias a        
// a로 지정된 alias 를 삭제
```

* `|` : (pipe) 명령의 결과를 다음 멍령의 입력으로 넘긴다

```bash
ls -al | wc -l
// ls 명령어의 라인수를 count
```

* `tar` : 파일을 묶어줌
  * c : 파일을 묶어줌
  * v : 작업 과정 확인
  * f : 저장될 파일명 지정
  * x : 묶은 파일을 풀어줌
  * z : tar + gzip
  * j : tar + bzip2

```bash
tar cvf abc.tar ./bbb        
// bbb 디렉토리를 abc.tar 파일로 묶어라

tar xvf abc.tar        
// abc.tar 파일을 풀어라
```

- `find` : 파일 검색

  - -name : 파일 이름으로 검색
  - -user : 소유자 이름으로 검색
  - -size : 파일 크기로 검색

```bash
find ./bbb -name 'b.*' -size 0        
// bbb 디렉토리에 파일명이 b이고 모든 확장자, size가 0인 파일 찾기
```

* `grep` : 파일에 포함된 특정 단어 검색
  * -i : 대소문자 구분 안함
  * -n : 라인 번호 출력
  * -v : 검색어가 없는 Line 보여달라
  * -c : 라인의 개수 출력

```bash
grep -ic 'Feb' ./d.txt        
// 대소문자 구분하지 않고 d.txt 에 'Feb' 가 있는 행 Count 
grep -iv 'feb' ./d.txt        
// 대소문자 구분하지 않고 d.txt에 'feb' 가 없는 Line 
grep -ivn 'feb' ./d.txt        
// 위의 명령어에 Line 번호도 출력
```

* `fsck` : 파일 시스템 검사 및 보수
* `ps` : 파일 복사



* _사용자 및 그룹 관리_ 

* `groupadd` : 새로운 그룹 생성
  * -g : 그룹번호 지정 (중복시키지 말것)

```bash
groupadd -g 500 dba            
// 그룹번호 500번으로 dba 그룹 생성
groupadd dba2            
// 가장 마지막 생성된 그룹번호의 다음 번호로 dba2 계정을 생성
```

* `groupmod` : 그룹 설정 변경
  * -g : 그룹번호 변경
  * -n : 그룹명 변경

```bash
groupmod -g 501 -n dbag dba            
// dba 그룹의 그룹번호를 501로, 그룹명을 dbag로 변경
```

* `groupdel` : 그룹 삭제

```bash
groupdel dba
```

* `useradd` : 사용자 계정 생성
  * -u : 유저번호(UID) 설정
  * -g : 그룹번호(GID) 설정
  * -G : 보조 그룹번호(GID) 설정
  * -d : 홈 디렉토리 설정
  * -s : 사용할 Shell 설정
  * -c : 계정에 대한 설명(Comment) 남김

```bash
useradd user1
useradd -u 501 -g 550 -c testuser user2
```

* `usermod` : 사용자 계정 변경
  * -u : 유저번호(UID) 설정
  * -g : 그룹번호(GID) 설정
  * -G : 보조 그룹번호(GID) 설정
  * -d : 홈 디렉토리 설정
  * -s : 사용할 Shell 설정
  * -c : 계정에 대한 설명(Comment) 남김



* `userdel` : 사용자 삭제
  * -r : 홈 디렉토리까지 삭제

```bash
userdel -r user2
```



* _권한 관리_
* 권한 관리
  * r : readable / 읽을 수 있음
  * w : writeable / 쓸 수 있음
  * x : executable / 실행할 수 있음
  * \-: denied / 접근 거부

```bash
- rw- r-- r-- 1 root root   0 Feb  5 16:42 a.txt
1|2  |3  |4  | 

// 소유자는 read, write 가능, 그룹은 read 가능, 그 외는 read 가능
// 1번 : 파일종류, 2번 : 소유자의 권한, 3번 : 그룹의 권한, 4번 : 이 외의 권한
```

* `chmod`  : 권한변경 - 영문자 할당법
  * chmod 옵션 a.txt  : 어느 부분 그리고 추가할지 삭제할지, 그리고 어떤 권한을 줄지를 정해줌

| u : user  | + : permission 추가 | r : read    |
| --------- | ------------------- | ----------- |
| g : group | - : permission 삭제 | w : write   |
| o : other | = : permission 추가 | x : execute |
| a : all   |                     |             |

```bash
chmod a+r a.txt    
// a.txt 파일 모든 사용자에게 read 권한 부여
chmod a+w a.txt    
// a.txt 파일 모든 사용자에게 write 권한 부여
chmod a+x a.txt    
// a.txt 파일 모든 사용자에게 execute 권한 부여
chmod o-r a.txt    
// a.txt 파일 관련 없는 사람은 read 권한 제거
```

* `chmod`   : 권한변경 - 숫자 할당법
  * chmod 옵션 b.txt    // 옵션 부분은 3자리 숫자가 들어감
  * 이진수 첫번째 자리는 user, 두번째 자리는 group, 세번째 자리는 other

| 4 (100(2)) | read    |
| ---------- | ------- |
| 2 (010(2)) | write   |
| 1(001(2))  | execute |

```bash
chmod 777 b.txt    
// b.txt 파일 모든 사용자에게 read, write, execute 권한 부여
chmod 751 b.txt    
// b.txt 파일 user 는 모든 권한, group 은 read, execute 권한, other 는 execute 권한 부여
chmod 700 b.txt    
// b.txt 파일 user 는 모든 권한 나머지는 권한 제거
```



* _프로세스 관리_

- `kill` : PID(프로세스 고유 번호)를 이용하여 프로세스 종료
- `killall` : 프로세스의 이름을 이용하여 프로세스 종료
- `ps` : 현재 실행중인 프로세스 표시
- `top` : 시스템의 프로세스와 메모리 사용 현황 표시
- `who` : 현재 시스템에 접속해 있는 사용자 표시



# 7. 기억장치 관리 전략

---

- _보조기억장치의 프로그램이나 데이터를 주기억장치에 적재 시기, 적재 위치 등을 지정하여 한정된 주기억 장치의 공간을 효율적으로 사용하기 위함_

- `반입(Fetch) 전략` : 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략, *요구 반입(Demand Fetch)*과 *예상반입(Anticipatory Fetch)*이 있음

- `배치(Placement) 전략` : 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
  - _최초 적합(First Fit)_ : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫번째 분할 영역에 배치 시키는 방법
  - _최적 적합(Best Fit)_ : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
  - _최악 적합(Worst Fit)_ : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

  

| 영역번호 | 영역크기 | 상태   |
| -------- | -------- | ------ |
| 1        | 5K       | 공백   |
| 2        | 14K      | 공백   |
| 3        | 10K      | 사용중 |
| 4        | 12K      | 공백   |
| 5        | 16K      | 공백   |

* ex)
  * 먼저 10K 가 적재될 수 있는지 각 영역의 크기 확인
  * First Fit : 빈 영역 중에서 10K의 프로그램이 들어갈 수 있는 첫번째 영역은 2번째
  * Best Fit : 빈 영역 중에서 10K 프로그램이 들어가고 단편화를 가장 작게 넘기는 영역은 4번
  * Worst Fit : 빈 영역 중에서 10K 프로그램이 들어가고 단편화를 가장 많이 남기는 영역은 5번



- `교체(Replacement) 전략` : 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략(FIFO, OPT, LRU, LFU, NUR, SCR 등)



# 8. 가상 기억장치(Virtual Memory)

---

- 보조기억장치(하드디스크)의 일부를 주기억 장치처럼 사용하는 것으로, 용량이 작은 주기억 장치를 큰 용량을 가진 것처럼 사용하는 것
- `페이징(Paging) 기법` : 가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법으로, 외부 단편화는 발생하지 않으나 내부 단편화는 발생 할 수 있음
- `세그먼테이션(Segmentation) 기법` : 가상 기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법, 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음

# 9. 가상기억장치 기타 관리 사항

---

- `국부성(Locality)`
  - _프로세스가 실행되는동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론_
  - _시간 구역성_ : 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스
  - _공간 구역성_ : 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스
- `워킹 셋` : _프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합_
- `페이지 부재` : _프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상_
  - 페이지 부재 빈도 : 페이지 부재가 일어나는 횟수
- `스레싱` : _프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상_

# 10. 페이지 교체 알고리즘

---

- `OPT(OPTimal replacement, 최적 교체)` : 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체

- `FIFO(First In First Out)` : 각 페이지가 주기억 장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체

| 참조페이지    | 1    | 2    | 3    | 4    | 1    | 2    | 5    | 1    | 2    | 3    | 4    | 5    |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 페이지 프레임 | _1_  | 1    | 1    | _4_  | 4    | 4    | _5_  | 5    | 5    | 5    | 5    | 5    |
|               |      | _2_  | 2    | 2    | _1_  | 1    | 1    | 2    | 1    | _3_  | 3    | 3    |
|               |      |      | _3_  | 3    | 3    | _2_  | 2    | 2    | 2    | 2    | _4_  | 4    |

- `LRU(Least Recently Used)` : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체

| 참조페이지    | 1    | 2    | 3    | 4    | 1    | 2    | 5    | 1    | 2    | 3    | 4    | 5    |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 페이지 프레임 | _1_  | 1    | 1    | _4_  | 4    | 4    | _5_  | 5    | 5    | 5    | 5    | 5    |
|               |      | _2_  | 2    | 2    | _1_  | 1    | 1    | 2    | 1    | _3_  | 3    | 3    |
|               |      |      | _3_  | 3    | 3    | _2_  | 2    | 2    | 2    | 2    | _4_  | 4    |

- `LFU(Least Frequently Used)` : 사용 빈도가 가장 적은 페이지를 교체

| 참조페이지    | 1    | 2    | 6    | 1    | 4    | 5    | 1    | 2    | 1    | 4    | 5    | 6    | 4    | 5    |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 페이지 프레임 | _1_  | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|               |      | _2_  | 2    | 2    | 2    | _5_  | 5    | 5    | 5    | 5    | 5    | 5    | 5    | 5    |
|               |      |      | _6_  | 6    | 6    | 6    | 6    | _2_  | 2    | 2    | 2    | _6_  | 6    | 6    |
|               |      |      |      |      | _4_  | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |

- `NUR(Not Used Recently)` : 최근에 사용하지 않은 페이지를 교체하는 기법으로, 참조 비트와 변형 비트가 사용됨
- `SCR(Second Chance Replacement, 2차 기회 교체)` : 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법

# 11. 프로세스 관리

---

- _프로세스(= 작업, 태스크)_ : 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미
- _프로세스 상태 전이_
- `제출(Submit)` : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- `접수(Hold)` : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
- `준비(Ready)` : 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
- `실행(Run)` : 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
- `대기(Wait), 블록(Block)` : 프로세스에 입·출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입·출력 처리가 완료될 때까지 대기하고 있는 상태
- `종료(Terminated, Exit)` : 프로세스의 실행이 끝나고 프로세스 할당이 해제

# 12. 비선점(Non-preemptive) 스케줄링

---

- _이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법_
- `FIFO(First In First Out, 선입 선출) = FCFS(First Come First Service)` : 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
- `SJF(Shortest Job First, 단기 작업 우선)` : 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
- `HRN(Hightest Response-ratio Next)` :실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완 하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법
  - _우선순위 계산식 : (대기 시간 + 서비스 시간) / 서비스 시간_
- `기한부(Deadline)` : 프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
- `우선순위(Priority)` : 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

# 13. 선점(Preemptive) 스케줄링

---

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
- 선점 우선순위 : 준비상태 큐의 프로세스들 중에서 우선 순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
- `SRT(=선점 SJF 기법)` : 비선점 스케줄링인 SJF 기법을 선점 형태로 변경한 기법
- `라운드 로빈(RR)` : 시분할 시스템을 위해 고안된 방식으로, FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치됨
- `다단계 큐(MQ)` : 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법
- `다단계 피드백 큐(MFQ)` : 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비 상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 기법

