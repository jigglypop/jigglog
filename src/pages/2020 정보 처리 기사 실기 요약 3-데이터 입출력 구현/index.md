---

path: "/2020 정보 처리 기사 실기 요약 3-데이터 입출력 구현/"
category: "정보처리기사 실기 요약"
tags: ["정보처리기사 실기 요약", "정보처리기사", "정처기"]
title: "2020 정보 처리 기사 실기 요약 3-데이터 입출력 구현"
date: "2020-07-15T17:22:00.000Z"
summary: "2020 정보 처리 기사 데이터 입출력 구현 요약 입니다. 정처기 공부를 할 때 활용하세요."
images: ["images/1.jpg"]
---

> 정보처리기사 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 책을 참고해서 공부하세요

> 2020 정보 처리 기사 데이터 입출력 구현 요약 입니다. 정처기 공부를 할 때 활용하세요.

# 1. 데이터 모델의 개념

---
### 1) 데이터 모델
- `데이터 모델` : _현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형_
- 데이터 모델 구성 요소~~(계에속어관릴)~~
  - `개체(Entity)` : _관리할 대상이 되는 실체_
  - `속성(Attribute)`: _관리할 정보의 구체적 항목_
  - `관계(Relationship)` : _개체 간의 대응 관계_

### 2) 데이터 모델의 종류~~(개논물)~~
  * `개념적 데이터 모델` : 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
  * `논리적 데이터 모델` : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
  * `물리적 데이터 모델` : 실제 컴퓨터에 데이터가 저장되는 방법으로 정의하는 물리 데이터베이스 설계 과정

### 3) 데이터 모델에 표시할 요소~~(구연제물)~~
  * `구조(Structure)` : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
  * `연산(Operation)` : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
  * `제약 조건(Constraint)` : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
  * `물리적 데이터 모델` : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 데이터베이스 설계 과정

### 4) 개체-관계(E-R) 모델
  * 개체-관계(E-R) 모델: _현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위한 모델_

| 구성           | 기호 | 기호이름   |
| -------------- | ---- | ---------- |
| 개체           | □    | (사각형)   |
| 관계           | ◇    | (마름모)   |
| 속성           | ○    | (타원)     |
| 다중 값 속성   | ◎    | (이중타원) |
| 관계-속성 연결 | -    | (선)       |




# 2. 정규화

---
### 1) 개요
* 정규화 : _관계형 데이터베이스의 설계에서 중복을 최소화하여 데이터를 구조화하는 프로세스_~~(관중데구)~~~~(도부이걸다조)~~
* 비정규 릴레이션 : `도메인`이 원자값
* 1NF : `부분적 함수` 종속 제거
* 2NF : `이행적 함수` 종속 제거
* 3NF : `결정자`이면서 후보키가 아닌 것 제거
* BCNF : `다치 종속`
* 4NF : `조인 종속성` 이용
* 5NF : 이행적 함수적 종속 (A → B이고 B → C일 때 A → C를 만족하는 관계)

### 2) 이상 현상~~(삽삭갱)~~
- `이상(Anomaly)`_데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상_~~(중릴비)~~
  - `삽입 이상` : 정보 저장 시 해당 정보의 불필요한 세부 정보를 입력해야 하는 경우
  - `삭제 이상` : 원치 않는 다른 정보가 같이 삭제되는 현상
  - `갱신 이상` : 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

### 3) 함수적 종속

#### (1) 함수적 종속

* 어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 때 _X의 값 각각에 대해 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속_
* 표현: X → Y


*  X를 *결정자(Determinant)*라 하고, Y를 *종속자(Dependent)*라고 함

|    id    | name |  department  |
| :------: | :--: | :----------: |
| 20800399 |  A   | 컴퓨터공학부 |
| 21300758 |  B   |   경영학부   |
| 21400001 |  C   |  기계공학부  |

* 학번에 의해서 학생이름과 학부는 고유하게 구분되므로 학생이름, 학부 속성은 학번에 함수적으로 종속
* 학번은 _결정자_, 학생이름과 학부는 _종속자_
* 학번 -> (학생이름, 학부)

* 속성 값은 계속 변할 수 있는 것이기 때문에 속성 자체가 가지는 특성과 의미를 기반으로 판단



#### (2) 완전 함수 종속(Full Functional Dependency)

* _종속자가 기본키에만 종속_ 
* 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우

#### (3) 부분 함수적 종속(Partial Functional Dependency)

* _릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속_
* 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속

#### (4) 이행적 함수 종속(Transitive Functional Dependency)

* _릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때_
* X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우



# 3. 정규화(Normalization)의 과정
---
### 1) 제 1정규형(1NF)
* `원자 값`
* _릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성_

#### 1) 변경 전

|   학번   |            과목코드             |   성적    | 이름 |
| :------: | :-----------------------------: | :-------: | :--: |
| 20800399 | CSE011101, CSE022202, CSE033303 | A+, A, B+ | YDH  |

#### 2) 변경 후

|   학번   | 과목코드  | 성적 | 이름 |
| :------: | :-------: | :--: | :--: |
| 20800399 | CSE011101 |  A+  | YDH  |
| 20800399 | CSE022202 |  A   | YDH  |
| 20800399 | CSE033303 |  B+  | YDH  |

### 2) 제 2정규형 (2NF)
* `부분 함수적 종속 제거`
* 제1정규형에 속하면서, _기본키가 아닌 모든 속성이 기본키에 완전 함수 종속_

#### 1) 변경 전

|  _학번_  | _과목코드_ | 성적 |     학부     | 등록금 |
| :------: | :--------: | :--: | :----------: | :----: |
| 20800399 | CSE011101  |  A+  | 컴퓨터공학부 |  350   |
| 20800399 | CSE022202  |  A   | 컴퓨터공학부 |  350   |
| 20800399 | CSE033303  |  B+  | 컴퓨터공학부 |  350   |
| 21300758 | MEC011101  |  F   |   경영학부   |  300   |
| 21400001 | POD032939  |  C+  |  기계공학부  |  400   |
| 21500399 | CSE011101  |  D   | 컴퓨터공학부 |  350   |

#### 2) 변경

* 테이블의 함수 종속 관계

```bash
학번, 과목코드 -> 성적
학번, 과목코드 -> 학부
학번, 과목코드 -> 등록금
학번 -> 학부
학번 -> 등록금
학부 -> 등록금
```

* 현재 학번->학부, 학번->등록금 두개의 부분 함수 종속성을 가지고 있고 이를 제거


#### 3) 변경 후

|  _학번_  |     학부     | 등록금 |
| :------: | :----------: | :----: |
| 20800399 | 컴퓨터공학부 |  350   |
| 21300758 |   경영학부   |  300   |
| 21400001 |  기계공학부  |  400   |
| 21500399 | 컴퓨터공학부 |  350   |

|  _학번_  | _과목코드_ | 성적 |
| :------: | :--------: | :--: |
| 20800399 | CSE011101  |  A+  |
| 20800399 | CSE022202  |  A   |
| 20800399 | CSE033303  |  B+  |
| 21300758 | MEC011101  |  F   |
| 21400001 | POD032939  |  C+  |
| 21500399 | CSE011101  |  D   |

### 3) 제 3 정규형 (3NF)
* `이행 함수 종속 제거`
* 제 2 정규형에 속하면서, _기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않음_


#### 1) 변경 전

|  _학번_  |     학부     | 등록금 |
| :------: | :----------: | :----: |
| 20800399 | 컴퓨터공학부 |  350   |
| 21300758 |   경영학부   |  300   |
| 21400001 |  기계공학부  |  400   |
| 21500399 | 컴퓨터공학부 |  350   |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
학번 -> 학부
학부 -> 등록금
학번 -> 등록금
```

* X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 (X, Y), (Y, Z) 두 릴레이션으로 분해


#### 3) 변경 후

|  _학번_  |     학부     |
| :------: | :----------: |
| 20800399 | 컴퓨터공학부 |
| 21300758 |   경영학부   |
| 21400001 |  기계공학부  |
| 21500399 | 컴퓨터공학부 |

|    _학부_    | 등록금 |
| :----------: | :----: |
| 컴퓨터공학부 |  350   |
|   경영학부   |  300   |
|  기계공학부  |  400   |


### 4) 보이스-코드 정규형(BCNF)
* `결정자 함수`

* _결정자 함수이면서 후보키가 아닌 것 제거_


#### 1) 변경 전

| _사용자 명_ | 책이름           | 배급사 |
| ----------- | ---------------- | ------ |
| 홍길동      | 블록체인 입문    | B      |
| 홍길동      | 자바 입문        | U      |
| 임꺽정      | 블록체인 입문    | B      |
| 임꺽정      | 자연어 처리 심화 | C      |
| 임꺽정      | 인공지능 입문    | K      |
| 성춘향      | 자바 입문        | U      |
| 성춘향      | 인공지능 입문    | K      |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
사용자명, 책이름 -> 배급사
배급사 -> 책이름
```

* 위 테이블의 후보키는 '사용자 명', '책이름' 이고 이 두 컬럼을 통해 레코드를 구별할 수 있지만 배급사에 의해 책이름이 결정되는 관계가 존재하여 BCNF 를 만족하지 않음


#### 3) 변경 후

| _사용자 명_ | 책이름           |
| ----------- | ---------------- |
| 홍길동      | 블록체인 입문    |
| 홍길동      | 자바 입문        |
| 임꺽정      | 블록체인 입문    |
| 임꺽정      | 자연어 처리 심화 |
| 임꺽정      | 인공지능 입문    |
| 성춘향      | 자바 입문        |
| 성춘향      | 인공지능 입문    |

| _배급사_ | 책이름           |
| -------- | ---------------- |
| B        | 블록체인 입문    |
| U        | 자바 입문        |
| C        | 자연어 처리 심화 |
| K        | 인공지능 입문    |



### 5) 4차 정규화(4NF)

* `다치 종속성 제거`
* 특정 속성값에 따라 선택적인 속성 분리

#### 1) 변경 전

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |

#### 2) 변경

* 테이블에서 함수적 종속성

```bash
개발자 -> 자격증
개발자 -> 언어
```

* 개발자마다 자격증 값들이 여러 개 존재하고, 특정 개발자마다 언어 값들이 여러 개 존재하는 경우
* 개발자별로 여러 자격증 값을 가지고 있고 개발자별로 여러 언어값을 가지고 있으므로 개발자, 자격증/ 개발자, 언어 테이블로 분리하여 관리하면 다치 종속 관계 제거

#### 3) 변경 후

| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |

| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
| 장길산 | JAVA |



### 6) 5차 정규화(5NF)

* `조인 종속성 제거`

#### 1) 변경 전

| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |

---



| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
|        | JAVA |

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |



#### 2) 변경

* 4차 정규화 테이블에 대해 조인 연산을 수행하면 4차 정규화 수행 전 데이터와 다르게 되는 문제인 조인 종속성 발생
* 조인 종속 관계를 제거하기 위해서는 모든 속성 관계인 _개발자, 자격증_, _개발자, 언어_ 뿐 아니라 _자격증, 언어_ 관계에 대한 테이블을 만들어 줌으로써 조인했을 때 정확히 원래의 데이터를 복원할 수 있음



#### 3) 변경 후

| 개발자 | 자격증             | 언어 |
| ------ | ------------------ | ---- |
| 홍길동 | 정보처리기사       | C    |
| 홍길동 | 빅데이터 분석 기사 | C++  |
| 장길산 | 정보처리기사       | JAVA |

---



| 개발자 | 자격증             |
| ------ | ------------------ |
| 홍길동 | 정보처리기사       |
| 홍길동 | 빅데이터 분석 기사 |
| 장길산 | 정보처리기사       |



| 자격증             | 언어 |
| ------------------ | ---- |
| 정보처리기사       | C    |
| 빅데이터 분석 기사 | C++  |
| 정보처리기사       | JAVA |

| 개발자 | 언어 |
| ------ | ---- |
| 홍길동 | C    |
| 홍길동 | C++  |
| 장길산 | JAVA |



# 4. 논리 데이터 모델의 물리 데이터 모델로 변환

---

- `엔티티를 테이블로 변환` : 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- `슈퍼타입 기준 테이블 변환` : 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 변환
- `서브타입 기준 테이블 변환` : 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 변환
- `개별타입 기준 테이블 변환` : 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환
- `속성을 컬럼으로 변환` : 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
- `관계를 외래키로 변환` : 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환

# 5. 반정규화(Denormalization)

---

- `반정규화` : _정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위_ ~~(반정데통중분 의정위)~~
- _테이블 통합_ : 
  - 두 개의 테이블이 조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
- _테이블 분할_ :
  - `수평 분할` : 레코드를 기준으로 테이블을 분할하는 것으로, 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할
  - `수직 분할` : 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할

# 6. 설계

---

- `인덱스` : _데이터 레코드를 빠르게 접근하기 위해 키 값, 포인터 쌍으로 구성되는 데이터 구조_
  - 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식인 *클러스터드 인덱스*와 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식인 *넌클러스터드 인덱스*가 있음
  - `트리 기반 인덱스` : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로, 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
  - `비트맵 인덱스` : 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
  - `함수 기반 인덱스` : 컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
  - `A비트맵 조인 인덱스` : 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름
  - `도메인 인덱스` : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스(Extensible Index)라고도 함
- `뷰` : _사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블_
  - 저장장치 내에 물리적으로 존재하지 않지만 사용자에게는 있는 것처럼 간주
  - CREATE문으로 정의하고, DROP문으로 제거
  - 데이터의 논리적 독립성을 제공
- `클러스터` : _데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 방법_
  - 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장
  - 클러스터링된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하
  - `단일 테이블 클러스터링` : 처리 범위가 넓은 경우
  - `다중 테이블  클러스터링`: 조인이 많이 발생하는 경우 사용

* `파티션`: _대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것_ ~~(파 데테인작논)~~
  * ~~(범해조)~~
  * `범위 분할` : 지정한 열의 값을 기준으로 분할
  * `해시 분할` : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
  * `조합 분할` : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할
  * _인덱스 파티션_ : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

# 7. 트랜잭션(Transaction)

---

### 1) 개요

* _논리적 기능을 수행하기 위한 기본 단위_

-  데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

### 2) 트랜잭션의 속성~~(원일독지)~~

#### (1) 원자성(Atomicity)

* _한 트랜잭션 대의 모든 연산이 완전히 수행되거나 전혀 수행되지 않음_

* 트랜잭션의 모든 연산이 정상적으로 수행 완료되지 않거나 수행 중 오류가 발생할 경우 어떠한 연산도 반영하지 않음
#### (2) 일관성(Consistency)

* _트랜잭션이 수행되기 전과 후에도 데이터베이스는 일관된 상태를 유지_

-  트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환

#### (3) 독립성(Isolation)

* _하나의 트랜잭션의 실행은 동시에 실행중인 다른 트랜잭션의 간섭을 받아서는 안됨_

*  둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음

#### (4) 지속성(Durability)

* _성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함_



# 8. 데이터베이스 용량 설계

---

- 데이터가 저장될 공간을 정의하는 것, 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영
- 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 증가
- `데이터 접근성을 향상시키는 설계 방법`
  - 테이블의 테이블스페이스와 인덱스의 테이블 스페이스를 분리하여 구성
  - 테이블 스페이스와 임시 테이블스페이스를 분리하여 구성
  - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류
