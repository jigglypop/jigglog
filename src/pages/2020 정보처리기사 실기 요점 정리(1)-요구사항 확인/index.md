---
path: "/2020 정보처리기사 실기 요점 정리(1)-요구사항 확인/"
category: "정보처리기사 실기"
tags: ["정보처리기사 실기", "정보처리기사"]
title: "2020 정보처리기사 실기 요점 정리(1)-요구사항 확인"
date: "2020-06-01T18:06:00.000Z"
summary: "요구사항 확인"
images: ["images/1.jpg"]
---

# 1. 요구사항 확인

### 1. 현행 시스템 파악

---

##### 1) 현행 시스템 파악

소프트웨어, 하드웨어, 네트워크 등 관련 인프라를 확인하고 어떤 기술 요소를 적용할 것인지를 판단하기 위한 사전 지식 습득 과정

##### 2) 현행 시스템 파악 절차

- 구성/기능/인터페이스 파악 : 시스템 구성 현황 파악, 시스템 기능 파악, 시스템 인터페이스 현황 파악
- 아키텍처 및 소프트웨어 구성 파악 : 아키텍처 파악, 소프트웨어 구성 파악
- 하드웨어 및 네트워크 구성 파악 : 시스템 하드웨어 현황 파악, 네트워크 구성 파악

#####

##### 3) 소프트웨어 아키텍처

개념적 설계도

- 마이크로 서비스 아키텍처 : 하나의 어플리케이션을 독립된 여러 단위의 작은 APP으로 나누어 변경과 조합 가능
- 람다 아키텍처 : BATCH와 REAL TIME 모두 지원하는 빅데이터 실시간 처리 아키텍쳐
- 카파 아키텍처 : 람다의 코드 공유 복잡성 문제를 해결, 배치 레이어 제거, 모든 계산을 피드 레이어에서 스트링으로 처리

IEEE1471 : 아키텍처 표준

- 유연성, 확장성을 가진 SW 시스템 아키텍처를 기술하기 위한 개념적 프레임워크
- 용어와 개념 표준화, 모델링 언어에 무관한 독립적 메타모델 제공, 아키텍처 표현을 위한 요소들과 관계의 일반화,  
   의사소통 지원, 고수준의 아키텍처 식별, 구체적인 문서 작성
  4+1VIEW 모델 : 요구사항을 정리한 시나리오를 네개의 관점에서 봄(USECASE, LOGICAL, IMPLEMENTATION, PROCESS, DEPLOYMENT)
  아키첵처 드라이버 : 요구사항 항목을 분석 추출 정제, 기능요구사항 품질속성 제약사항의 영향
  아키텍처 품질속성 시나리오(가용성) : 자극의 원천 자극 대상체 환경 응답 응답측정
  유틸리티 트리 : 유틸리티 -> 품질속성 -> 세분화한 품질속성 -> 시나리오 순서로 작성
  SW아키텍처 스타일 : 데이터구조, 데이터흐름, 가상머신, 호출과 리턴, 독립적 컴포넌트

* 주요 아키텍처 스타일
  저장소 구조 : 서브&중앙, 컴포넌트 추가, 삭제 편리, DATA 관리 편리, 저장소 오류가 시스템 전체에 영향
  MVC 구조 : MODEL VIEW CONTROLLER DATA를 여러 방법으로 표현 가능, DATA 구조가 변해도 다른 컴포넌트에 영향 X
  클라이언트/서버 구조 : DATA 분배 편리, 서버관리 어려움, 네트워크 영향을 많이 받음, 서버 의존성 강함
  DATA FLOW : 이해가 쉽고 재사용 가능, 출력이 입력으로 들어가서 필터간 데이터 포멧이 같아야 함
  계층구조 : INCREMENTAL 개발 가능, 유지보수 용이, 각 층은 쉽게 변경 가능, 레이어 분리가 어려움

### 2. 요구사항 확인

---

##### 1) 요구사항의 개념

소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건

​

​

##### 2)요구사항 개발 프로세스

개발 대상에 대한 요구사항을 체계적으로 도출, 분석한 후 분석 결과를 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활용

- IEEE : Computer Society에서 Software Engineering 분야의 지식을 정리한 SWEBOK에서 정의한 요구상항 프로세스를 기반으로 작성된 요구사항 개발 프로세스

* 요구사항 도출(인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스등)

  소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계

  요구사항 정보 수집을 위해 관련된 일련의 활동 등을 총칭하는 단계

  이해관계자 식별을 통해, 개발자와 고객 사이의 관계 형성

  이해관계자들와 효율적인 의사소통 중요

* 요구사항 분석(요구사항분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형분석)

  요구사항들 간 상충되는 것을 해결

  소프트웨어의 범위 파악

  소프트웨어가 환경과 어떻게 상호 작용하는지 이해

  시스템 요구상항을 정제하여 소프트웨어 요구사항 도출

* 요구사항 명세( 정확성, 명확성, 완전성, 일관성, 중요성 )

체계적으로 검토, 평가, 승인될수 있는 문서 작성

문서화할 때는 기능 요구사항은 빠짐없이 완전하고 명확하게 기술

문서화할 때는 비기능사항은 필요한 것만 명확하게 기술

시스템 정의, 시스템 요구사항, 소프트웨어 요구사항 작성

- 요구사항 확인

  분석가가 요구상항을 제대로 이해했는지 확인 필요

  일관성과 완전성이 충족되는지 검증하는 것이 중요

### 3. 분석 모델 확인하기

---

### 1. 분석 모델 검증

---

요구 사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동

##### 1) 분석 모델 검증 방법

- 유스케이스 모델 검증

- 개념 수준의 분석 클래스 검증

- 분석 클래스 검증

##### 1) UML

OMG에서 만든 객체 지향 모델링 언어

\- 구성요소 : VIEW, DIAGRAM, 모델요소, 일반적인 체계

\- DIAGRAM의 종류 :USE CASE DIAGRAM , CLASS DIAGRAM, SEQUENCE DIAGRAM, ACTIVITY DIAGRAM, COMPONENT DIAGRAM

##### 2) 디자인 패턴

\- 유용하다고 생각하는 객체들의 일반적인 상호작용 방법을 모음

\- 구성요소 : 패턴이름, 문제, 해법, 결과

\- 디자인 패턴 종류

생성 패턴 : 클래스 정의, 객체 생성 방식 구조화, 캡슐화 지향

​ (클래스) FACTORY METHOD : 인스턴스화 될 객체의 서브클래스

​ (객체) ABSTRACT FACTORY(제품 객체군), BUILDER(복합 객체생성), PROTOTYPE, SINGLETON

구조 패턴 : 객체 조직화하는 일반적 방법, 런타임 시 구조 변경 가능, 클래스 통합에 유용

​ 유동성과 확장성을 추가

​ (클래스) ADAPTOR 객체 인터페이스

​ (객체) BRIDGE, COMPOSITE, DECORATOR, FACADE(서브 시스템에 대한 인터페이스), FLYWEIGHT, PROXY

행위 패턴 : 객체 행위를 조직화, 관리 연합 제어흐름을 결정, 객체 클래스 연동에 대한 유형 제시

​ (클래스) INTERPRETER, TEMPLATE METHOD

​ (객체) CHAIN OF RESPONSIBILITY, COMMAND, ITERATOR, MEDIATOR(객체 상호작용),

​ MEMENTO(객체 정보 외부저장) OBSERVER(종속 객체 상태 변경), STATE, STRATEGY,

​ VISITOR(클래스 변경없이 객체에 적용 가능한 오퍼레이션)

ABSTRACT FACTORY 패턴 : 관련성 갖는 객체 집합 생성하거나

​ 서로 독립적인 객체 집합 생성할 수 있는 인터페이스 제공

BUILDER 패턴(생성) : 객체 생성, 표현을 분리, 서로 다른 표현도 동일한 절차로 생성

​ BUILDER, CONCRETE BUILDER, DIRECTOR, PRODUCT

SINGLETON 패턴(생성) : 클래스의 인스턴스가 반드시 1개만 존재, GETINSTANCE()로만 생성 가능

​ 생성 방법 (1) 필요 시 생성 : 생성 속도가 문제가 되지 않을 때

​ (2) 처음부터 만들어놓고 시작 PRIVATE STATIC으로 변수 선언

ADAPTOR 패턴(구조) : 클래스 재사용성 증가, 변환 적용으로 클래스 간 상호 호환성 확보, WRAPPER패턴이라고도 함

​ \- 종류 : 상속 이용 ADAPTOR 패턴, 위임 이용 ADAPTOR 패턴

FACADE 패턴(구조) : 복잡한 내부 구조는 가리고, 외부와 일관된 인터페이스 제공, HIGHT LEVEL API 제공

CHAIN OF RESPONSIBILITY 패턴(행위) : 요청처리 기회를 하나 이상의 객체에 부여, 객체 간 결합도 저하,

​ 요청 객체를 만날 때까지 객체 고리를 따라 요청 전달

COMMEND 패턴(행위) : 요청을 객체를 통해 캡슐화하여 LOG에 저장, UNDO REDO 등의 기능을 제공
