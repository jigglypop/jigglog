---
path: "/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)/"
category: "기술 면접"
tags: ["프론트엔드", "개발자", "면접", "기술면접", "자바스크립트"]
title: "프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)"
date: "2021-04-07T01:00:00.000Z"
summary: "프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2) 파트"
images: ["images/2.jpg"]
---

> 프론트 엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요



# Java Script

---



## 1) JAVASCRIPT 원시 타입

- `string`,  `number`,  `boolean`,  `undefined` , `null` , `symbol`
- undefined :  선언만 되어있고 값은 없는 상태 
- null : 자료형이 객체이며 빈값을 의미

* 자바스크립트의 Number Type :  number는 하나. 정수만을 위한 타입이 없고, 모든 수를 실수로 처리

  

#### (1) 어트리뷰트(속성, Attribute)와 프로퍼티(요소, property)

- 어트리뷰트 : element가 가지고 있는것. element의 형식 지정(<div id=D1...의 id)
- 프로퍼티 : object가 가지고 있는 구성요소(name, parent, history, innerHeight 등)



#### (2) Immutable / Mutable

##### (1) Immutable

* 내용이 변하지 않는 객체
* 자바스크립트 원시 타입은 Immutable
* 사용 이유
  * 성능을 향상시키기 위함 : 객체가 미래에 변할 계획이 없을 때
  * 메모리 사용을 줄이기 위함 : 전체 객체를 복사하지 않고 객체 참조를 만듦
  * Thread-safety : 여러개의 쓰레드가 서로 간섭하지 않고 같은 객체를 참조할 수 있음

##### (2) Mutable

* 바뀔 수 있는 변수 타입
* 자바스크립트 object와 array만 Mutable
* Mutable한 값을 Immutable하게 만들기 위해서 새로운 변수를 만들어 보관할 수 있지만, 이전 값은 여전히 메모리에 남아있기 때문에 GC가 필요

##### (3) == 과 === 

* `==` : 두 변수의 값 비교
* `===` : 엄격한 비교(값 + 타입)

```javascript
0 == false // true 왜? js 에서 0 은 false 한 값이기 때문 
1 == true     //true 

2 == "2" // true 왜? 자동으로 타입을 캐스팅 해버림 
0 == ''     //true 
0 == '0'     //true 

false == '0'    //true 
null == undefined    //true 
false == null    //false 
false == undefined    //false
```

* == 같은 경우는 피연산자가 서로 다른 타입이면 타입을 강제로 변환하여 비교

#### (3) null과 undefined

* 두 타입 모두 값이 없음을 의미
* 둘 다 데이터 타입이자 그 변수의 값
* undefined : 자바스크립트에서 변수를 선언하면 초기값으로 undefined를 할당
*  null : 값이 비어있음 ''값이 없다''는 값이 등록되어 있는 것

#### (4) Symbol

* 변경 불가능한 원시 타입의 값
* 다른 값과 중복되지 않는 유일한 값
* 이름 충돌이 없는 유일한 프로퍼티 키를 만들기 위해 사용

##### (1) 용도

* 프로퍼티 은닉

```javascript
const obj = {
  [Symbol("mySymbol")]: 1,
};
// 아무것도 출력되지 않음
for (const key in obj) {
  console.log(key);
}
// 심볼 프로퍼티 출력
console.log(Object.getOwnPropertySymbols(obj));
```

* 표준 빌트인 객체 확장

```javascript

```





## 2) 가비지 컬렉터

#### 1) 가비지 컬렉터

##### (1) 가비지와 가비지 컬렉터

* Garbage : 정리되지 않은 메모리, 유효하지 않은 객체의 메모리
* Garbage collector (GC) : 프로그램이 사용할 수 있는 메모리 용량이 부족할 때 가비지들을 메모리에서 해제하는 기능

##### (2) 메모리 

* 메모리 할당 : 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당

* 메모리 사용 : 메모리를 읽고 쓰는 것을 의미. 메모리가 할당된 변수를 사용하면 읽기와 쓰기 작업이 이루어짐

* 메모리 해제 : 더 이상 필요하지 않은 메모리를 해제하여 재사용 할 수 있도록 함

##### (3) 레퍼런스 카운팅(Reference Counting)

* 해당 값이 얼마나 많이 참조되었는지 추적

* 변수를 선언하고 참조값이 할당되면 레퍼런스 카운트는 1이 됨
* 다른 변수가 같은 값을 참조하면 레퍼런스 카운트가 늘어남
* 마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 레퍼런스 카운트가 줄어듦

```javascript
let objectA = {};	// 레퍼런스 카운트 1
let objectB = objectA; // 레퍼런스 카운트 2

objectA = null; // 레퍼런스 카운트 1
objectB = null; // 레퍼런스 카운트 0
```

* 값의 레퍼런스 카운트가 0이 되면 해당 값에 접근할 방법이 없으며 메모리를 회수해도 안전

* 순환 참조 문제 : 객체가 두 개일 때 함수 실행이 끝날 때 두 객체는 모두 스코프를 벗어나게 될 것이고, 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 하지만 함수 실행이 끝난 뒤에도 레퍼런스 카운트가 0이 되지 않으므로 두 객체는 계속 존재

* 이런 함수를 여러 번 호출하면 메모리를 회수하지 못하고 낭비되는 메모리가 많이 늘어남

##### (4) 마크 앤 스위프(Mark and sweep)

* 메모리 해제 여부를 결정하기 위해 루트(roots, 자바스크립트의 `window` 객체)부터 해당 객체까지 닿을 수 있는지를 판단

* 루트부터 시작하여 루트가 참조하는 객체들과 그 객체가 참조하는 또 다른 객체들을 추적
* 객체를 추적하면서 닿을 수 있는 객체는 표시(mark) 한 후, 표시가 없는 객체들은 메모리를 해제(sweep)



## 3) 자바스크립트의 배열

- 자바스크립트의 배열은 실제 자료구조의 배열과 다르게 HashMap으로 구현. 

- HashMap을 구현하기 위해서는 연결리스트로 구현하게 되는데 연결리스트에서 값을 찾기 위해서는 탐색해나가면서 값을 찾는 불상사가 발생

- 이를 해결하기 위해서 타이핑된배열(Int8Array, Float32Array 등) 이 추가되고 있음




## 4) 클로저

- 클로저(Closure) : _내부 함수가 외부 함수의 컨텍스트에 접근할 수 있는 것_
- MDN 정의 : _함수와 함수가 선언된 렉시컬 환경과의 조합_
- 반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하여 자신이 선언되었을때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수

##### (1) 렉시컬 스코프

* 함수를 어디에 정의했는지에 따라 상위 스코프를 결정(렉시컬 스코프, 정적 스코프)
* 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정

- 클로저의 사용 이유:

  - 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
  - 전역 변수의 사용을 억제
  - 정보를 은닉하기 위해 



## 6) ES6

| ES                    | 년도 | 추가 기능                                                    |
| --------------------- | ---- | ------------------------------------------------------------ |
| ES6 (ECMAScript 2015) | 2015 | let, const, class / 화살표 함수/ 템플릿 리터럴 / 디스트럭처링 할당/ spread 문법, rest 파라미터, Symbol, Promise/ Map, Set / iterator, generator /module import/export |
| ES7 (ECMAScript 2016) | 2016 | 지수(**) 연산자, Array.prototype.includes, String.prototype.includes |
| ES8 (ECMAScript 2017) | 2017 | async/await, Object 정적 메소드(Object.values, Object.entries, Object.getOwnPropertyDescriptors) |
| ES9 (ECMAScript 2018) | 2018 | Object Rest/Spread 프로퍼티                                  |





## Class

- Prototype, function의 ES5 스펙만으로 Class를 구현
- 자바스크립트에는 프로토타입이라는 것이 존재하여 클래스처럼 구현할 수 있음
- 클래스는 자바스크립트의 프로토타입 기반 패턴의 문법적 설탕









## 동기, 비동기

<img src="https://blog.kakaocdn.net/dn/bMlLfs/btqFQ9i1iD3/ZQE2tqi7lx7LUhTwK1tDtK/img.png" alt="img" style="zoom:50%;" />*

#### 1) 작동 원리

* 자바스크립트는 한 번에 하나의 작업을 수행

* 한 작업이 실행되는 동안 다른 작업은 멈춘 상태를 유지하고 자신의 차례를 기다리는 것

* 단일 스레드(싱글 스레드), 동기(Synchronous)



#### 2) 브라우저 부분

* 자바스크립트 엔진은 싱글스레드로 동작
* 브라우저는 멀티 스레드로 동작

##### 1) 힙(Memory Heap)(자바스크립트 엔진)

* Memory Heap은 객체를 저장하는 곳. 예제에서 선언한 함수 func1, func2, func3는 모두 Memory Heap에 저장

##### 2) 콜 스택(call stack)(자바스크립트 엔진)

* 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택

##### 3) Web API

* 브라우저에서 제공하는 API들
* DOM api, 타이머 함수, HTTP 요청 등 포함



#### 2) 자바스크립트 엔진 구조

##### 1) 태스크 큐(Callback Que / task Queue / event Queue)

* 함수를 저장하는 자료구조
* Call stack과 다르게 가장 먼저 들어온 함수를 가장 먼저 처리
* 특정 이벤트에 따른 콜백 함수를 정의하면, 콜백 함수는 Callback Que에 저장

##### 2) 이벤트 루프(Event Loop)

- call stack이 다 비워지면 callback que에 존재하는 함수를 하나씩 호출 스택으로 옮기는 역할
- 이벤트 루프를 통해 동시성을 지원

* 이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행


#### 3) 동기(Synchronous) 동작 원리

* 코드가 실행되면 순서대로 Call Stack에 실행할 함수가 쌓임

* 쌓인 반대 순서로 함수가 실행

* 실행이 된 함수는 Call Stack에서 제거



#### 4) 비동기(asynchronous) 동작 원리

* Call Stack에서 비동기 함수가 호출되면 Call Stack에 먼저 쌓였다가 Web API(혹은 백그라운드라고도 한다)로 이동한 후 해당 함수가 등록되고 Call Stack에서 사라짐

* Web API(백그라운드)에서 비동기 함수의 이벤트가 발생하면, 해당 콜백 함수는 Callback Queue에 push(이동) 

* 이제 Call Stack이 비어있는지 이벤트 루프(Event Loop)가 확인을 하는데 만약 비어있으면, Call Stack에 Callback Queue에 있는 콜백 함수를 넘겨줌(push)

* Call Stack에 들어온 함수는 실행이 되고 실행이 끝나면 Call Stack에서 사라짐



## 8) Callback, Promise, async/await

#### 1) Callback

* 다른 함수에게 인자로 전달되어 어느 시점에 실행될 수 있도록 던져주는 함수
* 비동기 처리를 위해 만들어짐

* 하지만 콜백 지옥이라 불리는 중첩문이 발생하면서 에러처리 한계가 생기기 시작했고 이를 해결하기 위해 Promise가 나옴

#### 2) Promise

* 비동기 연산이 종료된 이후에 그 결과 값이나 에러를 처리할 수 있도록 처리기를 연결하는 역할을 하는 객체

* 어떤 값이 생성 되었을 때 그 값을 대신하는 대리자이다. 

* Promise 객체를 통해 성공, 실패, 오류에 따른 후속처리가 바로 가능해서 가독성도 좋고, 비동기 에러를 처리하기도 수월

```javascript
	// Promise 객체의 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업을 수행한다.
  if (/* 비동기 작업 수행 성공 */) {
    resolve('result');
  }
  else { /* 비동기 작업 수행 실패 */
    reject('failure reason');
  }
});
```

* 비동기 처리에 성공 : resolve 메소드를 호출해서 비동기 처리 결과를 후속처리 메소드로 전달
* 비동기 처리에 실패 : reject 메소드를 호출해서 에러메시지를 후속처리 메소드로 전달
* 후속처리 메소드(then과 catch) :  Promise를 반환.
* then 을 가지고 메소드 체이닝을 통하여서 콜백 헬 문제를 해결
* Promise.all()을 사용해서 병렬로 실행되는 비동기 작업을 쉽게 작성할 수 있음
* 프로미스가 있으면 콜백만 사용하는 코딩에서 발생하는 콜백을 너무 빨리/늦게/많이/적게 실행, 필요한 환경변수/파라미터의 전달 실패, 확인해야 하는 에러, 예외가 숨어버리는 등이 발생하지 않음
* ES2015를 지원하지 않는 구형 브라우저에서는 사용할 수 없으며 폴리필이나 Babel을 통한 컴파일이 필요

#### 3) Async/await

* 비동기 코드를 동기식으로 표현하는 더 나은 방법으로 ES2017에 등장
*  Async와 await는 항상 같이 붙어 있어야 함
* await 모드는 Promise 객체를 받아 처리하고, 만약 비동기 함수가 아닌 동기적 함수라면 리턴 값을 그대로 받음
* Async 함수는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할
* async, await를 사용할 경우 코드가 간결해지지만 에러처리를 잡기 위해 try catch를 사용해야 함
* 동기적인 코드흐름으로 개발이 가능









## 1) 이벤트 위임

#### (1) DOM

- Angular의 경우 view와 model을 연결시키는 바인딩작업이 있고 변화감지를 통해서 상태를 보고 있다가 업데이트 되는 식
- React의 경우 가상 DOM이 있고, 가상 DOM이 실제 DOM과 비교하여 state가 변화되었는지 감지

#### (2) 이벤트 버블링(Event Bubbling), 이벤트 캡쳐링(Event Capturing)

* `이벤트 버블링(하위 -> 상위)` :  특정 화면 요소에서 이벤트가 발생했을 때 하위 -> 상위 요소들로 전달
* `이벤트 캡처링(상위 -> 하위)` : 이벤트 버블링과 반대로 상위 요소 -> 하위 요소로 탐색하며 이벤트를 전파

#### (3) event delegation

* 하나의 부모에 이벤트를 등록하여 부모가 이벤트를 위임하는 방식
* 이 방법은 동적인 요소들에 대한 처리가 수월, 이벤트 핸들러를 더 적게 등록해 주기 때문에 메모리 절약

- 이벤트 위임:

  - 동적으로 노드를 생성하고 삭제할 때 각 노드에 대해 이벤트를 추가 하지 않고, 상위 노드에서 하위 노드의 이벤트를 제어 

    

