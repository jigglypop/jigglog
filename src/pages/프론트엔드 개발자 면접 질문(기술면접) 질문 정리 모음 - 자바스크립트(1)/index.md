---
path: "/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)/"
category: "기술 면접"
tags: ["프론트엔드", "개발자", "면접", "기술면접", "자바스크립트"]
title: "프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)"
date: "2021-04-07T01:00:00.000Z"
summary: "프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2) 파트"
images: ["images/2.jpg"]
---

> 프론트 엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요



# Java Script

---



## 1) JAVASCRIPT 원시 타입

- `string`,  `number`,  `boolean`,  `undefined` , `null` , `symbol`
- undefined :  선언만 되어있고 값은 없는 상태 
- null : 자료형이 객체이며 빈값을 의미

* 자바스크립트의 Number Type :  number는 하나. 정수만을 위한 타입이 없고, 모든 수를 실수로 처리



## 2) 실행 컨텍스트(Execution Context) 

- 자바스크립트의 코드가 실행되기 위해 정보들을 담고 있는 곳(변수 객체, 스코프 체인, this 정보)
- 자바스크립트의 코드들이 실행되기 위한 환경(전역 컨텍스트 ,함수 컨텍스트)  
- 전역 컨텍스트 하나 생성 후에 함수 호출할 때마다 함수 컨텍스트가 생성. 
- 컨텍스트를 생성시에 변수객체, 스코프 체인, this가 생성. 컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프 체인을 따라 올라가며 찾음. 
- 함수 실행이 마무리되면 해당 컨텍스트는 사라짐. 
- 페이지가 종료되면 전역 컨텍스트가 사라짐. 

#### 1) 전역 scope를 사용했을 때 장단점

- 변수와 함수 이름의 충돌을 방지하기 위해

- 모든 스크립트는 전역 스쿠프에 접근할 수 있다. 

- 만약 모든 사람이 변수 선언에 전역 네임스페이스를 사용한다면 충돌이 매우 많이 발생할 것이다.

- 모듈 패턴(IIFE 등)으로 직접 선언한 변수는 로컬 네임스페이스에 포함되도록 해야 한다.

  



## 3) 가비지 컬렉터

#### 1) 가비지 컬렉터

##### (1) 가비지와 가비지 컬렉터

* Garbage : 정리되지 않은 메모리, 유효하지 않은 객체의 메모리
* Garbage collector (GC) : 프로그램이 사용할 수 있는 메모리 용량이 부족할 때 가비지들을 메모리에서 해제하는 기능

##### (2) 메모리 

* 메모리 할당 : 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당한다.

* 메모리 사용 : 메모리를 읽고 쓰는 것을 의미. 메모리가 할당된 변수를 사용하면 읽기와 쓰기 작업이 이루어짐

* 메모리 해제 : 더 이상 필요하지 않은 메모리를 해제하여 재사용 할 수 있도록 함

##### (3) 레퍼런스 카운팅(Reference Counting)

* 해당 값이 얼마나 많이 참조되었는지 추적

* 변수를 선언하고 참조값이 할당되면 레퍼런스 카운트는 1이 됨
* 다른 변수가 같은 값을 참조하면 레퍼런스 카운트가 늘어남
* 마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 레퍼런스 카운트가 줄어듦

```javascript
let objectA = {};	// 레퍼런스 카운트 1
let objectB = objectA; // 레퍼런스 카운트 2

objectA = null; // 레퍼런스 카운트 1
objectB = null; // 레퍼런스 카운트 0
```

* 값의 레퍼런스 카운트가 0이 되면 해당 값에 접근할 방법이 없으며 메모리를 회수해도 안전

* 순환 참조 문제 : 객체가 두 개일 때 함수 실행이 끝날 때 두 객체는 모두 스코프를 벗어나게 될 것이고, 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 하지만 함수 실행이 끝난 뒤에도 레퍼런스 카운트가 0이 되지 않으므로 두 객체는 계속 존재

* 이런 함수를 여러 번 호출하면 메모리를 회수하지 못하고 낭비되는 메모리가 많이 늘어남

##### (4) 마크 앤 스위프(Mark and sweep)

* 메모리 해제 여부를 결정하기 위해 루트(roots, 자바스크립트의 `window` 객체)부터 해당 객체까지 닿을 수 있는지를 판단

* 루트부터 시작하여 루트가 참조하는 객체들과 그 객체가 참조하는 또 다른 객체들을 추적
* 객체를 추적하면서 닿을 수 있는 객체는 표시(mark) 한 후, 표시가 없는 객체들은 메모리를 해제(sweep)



## 3) 자바스크립트의 배열

- 자바스크립트의 배열은 실제 자료구조의 배열과 다르게 HashMap으로 구현. 

- HashMap을 구현하기 위해서는 연결리스트로 구현하게 되는데 연결리스트에서 값을 찾기 위해서는 탐색해나가면서 값을 찾는 불상사가 발생

- 이를 해결하기 위해서 타이핑된배열(Int8Array, Float32Array 등) 이 추가되고 있다.

  

## 4) 이벤트 루프, 동시성 모델

- 자바스크립트는 싱글 스레드 기반 언어. 
- 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리
- 하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원
- 동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것
- 이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다. 





## 5) 클로저

- 클로저(Closure) : _내부 함수가 외부 함수의 컨텍스트에 접근할 수 있는 것_
- MDN 정의 : _함수와 함수가 선언된 렉시컬 환경과의 조합_
- 반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하여 자신이 선언되었을때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수

##### (1) 렉시컬 스코프

* 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정(렉시컬 스코프, 정적 스코프)
* 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정

- 클로저의 사용 이유:

  - 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
  - 전역 변수의 사용을 억제
  - 정보를 은닉하기 위해 



## 6) ES6

| ES                    | 년도 | 추가 기능                                                    |
| --------------------- | ---- | ------------------------------------------------------------ |
| ES6 (ECMAScript 2015) | 2015 | let, const, class / 화살표 함수/ 템플릿 리터럴 / 디스트럭처링 할당/ pread 문법, rest 파라미터, Symbol, Promise/ Map, Set / iterator, generator /module import/export |
| ES7 (ECMAScript 2016) | 2016 | 지수(**) 연산자, Array.prototype.includes, String.prototype.includes |
| ES8 (ECMAScript 2017) | 2017 | async/await, Object 정적 메소드(Object.values, Object.entries, Object.getOwnPropertyDescriptors) |
| ES9 (ECMAScript 2018) | 2018 | Object Rest/Spread 프로퍼티                                  |





## Class

- Prototype, function의 ES5 스펙만으로 Class를 구현할수 있음. 
- 자바스크립트에는 프로토타입이라는 것이 존재하여 클래스처럼 구현할 수 있음
- 클래스는 자바스크립트의 프로토타입 기반 패턴의 문법적 설탕





## AMD와 CommonJS

- 모든 모듈의 로딩이 완료된 후에 실행/ 로딩 완료 이전에 실행(동기 vs 비동기)

  

#### 1) Common.js 

- 모든 모듈이 로컬에 다운로드가 된 이후에 실행하는 방식. node.js에서 사용하는 방식으로 server 환경에서 외부 모듈을 가져올 때 유리

```javascript
var lib = require("package/lib");
function foo() {
	lib.log("hello world!");
}

exports.foobar = foo;
```

#### 2) AMD

* 비동기적으로 필요한 파일을 다운로드하는 방식, client단(브라우저 환경)에서 외부 모듈을 가져올 때 유리한 방식 

```javascript
 define(["package/lib"], function (lib) {
     function foo() {
     	lib.log("hello world!");
     }
     return {
      foobar : foo
     }
}
```





## 속성(Attribute)와 요소(property)

- 속성(Attribute)는 element가 가지고 있는것. element의 형식 지정(<div id=D1...의 id)
- 요소(property)는 object가 가지고 있는 구성요소(name, parent, history, innerHeight 등)





## Immutable / Mutable

#### 1) Immutable

* 내용이 변하지 않는 객체

##### (1) 사용 이유

- 성능을 향상시키기 위함 : 객체가 미래에 변할 계획이 없을 때
- 메모리 사용을 줄이기 위함 : 전체 객체를 복사하지 않고 객체 참조를 만듦
- Thread-safety : 여러개의 쓰레드가 서로 간섭하지 않고 같은 객체를 참조할 수 있음

#### 2) Mutable

* 바뀔 수 있는 변수 타입을
* Javascript에서는 object와 array만 Mutable한 타입이고, 원시 타입은 Immutable
* Mutable한 값을 Immutable하게 만들기 위해서 새로운 변수를 만들어 보관할 수 있지만, 이전 값은 여전히 메모리에 남아있기 때문에 GC가 필요



## 동기, 비동기

<img src="https://blog.kakaocdn.net/dn/bMlLfs/btqFQ9i1iD3/ZQE2tqi7lx7LUhTwK1tDtK/img.png" alt="img" style="zoom:50%;" />*

#### 1) 작동 원리

* 자바스크립트는 한 번에 하나의 작업을 수행

* 한 작업이 실행되는 동안 다른 작업은 멈춘 상태를 유지하고 자신의 차례를 기다리는 것

* 단일 스레드(싱글 스레드), 동기(Synchronous)



#### 2) 자바스크립트 엔진 구조

##### 1) Memory Heap

* Memory Heap은 객체를 저장하는 곳. 예제에서 선언한 함수 func1, func2, func3는 모두 Memory Heap에 저장

##### 2) Web API

* 브라우저에서 제공하는 API들

##### 3) Callback Que

* 함수를 저장하는 자료구조
* Call stack과 다르게 가장 먼저 들어온 함수를 가장 먼저 처리
* 특정 이벤트에 따른 콜백 함수를 정의하면, 콜백 함수는 Callback Que에 저장

##### 4) Event Loop

* call stack이 다 비워지면 callback que에 존재하는 함수를 하나씩 호출 스택으로 옮기는 역할



#### 3) 동기(Synchronous) 동작 원리

* 코드가 실행되면 순서대로 Call Stack에 실행할 함수가 쌓인다.(push)

* 쌓인 반대 순서로 함수가 실행

* 실행이 된 함수는 Call Stack에서 제거된다(pop)

 

#### 4) 비동기(asynchronous) 동작 원리

* Call Stack에서 비동기 함수가 호출되면 Call Stack에 먼저 쌓였다가 Web API(혹은 백그라운드라고도 한다)로 이동한 후 해당 함수가 등록되고 Call Stack에서 사라진다.

* Web API(백그라운드)에서 비동기 함수의 이벤트가 발생하면, 해당 콜백 함수는 Callback Queue에 push(이동) 된다.

* 이제 Call Stack이 비어있는지 이벤트 루프(Event Loop)가 확인을 하는데 만약 비어있으면, Call Stack에 Callback Queue에 있는 콜백 함수를 넘겨준다.(push)

* Call Stack에 들어온 함수는 실행이 되고 실행이 끝나면 Call Stack에서 사라짐



## == 과 === 

* `==` : 두 변수의 값 비교
* `===` : 엄격한 비교(값 + 타입)

```javascript
0 == false // true 왜? js 에서 0 은 false 한 값이기 때문 
1 == true     //true 

2 == "2" // true 왜? 자동으로 타입을 캐스팅 해버림 
0 == ''     //true 
0 == '0'     //true 

false == '0'    //true 
null == undefined    //true 
false == null    //false 
false == undefined    //false
```



== 같은 경우는 피연산자가 서로 다른 타입이면 타입을 강제로 변환하여 비교한다.

위 예제에서 의외인점은 null, undefined 도 falsy 한 값인데.. false == null 에서 false 가 나온다는게 의외다.

254 === '254' //  false true === 1 // false 'abc' === 'abc' // true





## DOM

- Angular의 경우 view와 model을 연결시키는 바인딩작업이 있고 변화감지를 통해서 상태를 보고 있다가 업데이트 되는 식
- React의 경우 가상 DOM이 있고, 가상 DOM이 실제 DOM과 비교하여 state가 변화되었는지 감지





## 1) 이벤트 위임

#### (1) 이벤트 버블링(Event Bubbling), 이벤트 캡쳐링(Event Capturing)

* `이벤트 버블링(하위 -> 상위)` :  특정 화면 요소에서 이벤트가 발생했을 때 하위 -> 상위 요소들로 전달
* `이벤트 캡처링(상위 -> 하위)` : 이벤트 버블링과 반대로 상위 요소 -> 하위 요소로 탐색하며 이벤트를 전파

#### (2) event delegation

* 하나의 부모에 이벤트를 등록하여 부모가 이벤트를 위임하는 방식
* 이 방법은 동적인 요소들에 대한 처리가 수월, 이벤트 핸들러를 더 적게 등록해 주기 때문에 메모리 절약

- 이벤트 버블링:

  - 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성

- 이벤트 캡쳐링:

  - 이벤트 버블링과 반대 방향으로 진행되는 이벤트 전파 방식(이벤트 리스너 capture: true 설정)

- 이벤트 위임:

  - 동적으로 노드를 생성하고 삭제할 때 각 노드에 대해 이벤트를 추가 하지 않고, 상위 노드에서 하위 노드의 이벤트를 제어 

    

