---
path: "/벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - cs/"
category: "기술 면접"
tags: ["벡엔드", "개발자", "면접", "기술면접", "CS"]
title: "벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - CS"
date: "2021-04-08T01:00:00.000Z"
summary: "프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트 파트"
images: ["images/2.jpg"]
---

>  백엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요

---



# CS 관련 지식

## 1) 네트워크

---

* RESTful API : 
  - URI로 접근가능하고 내용이 JSON,XML 등으로 표현된 자원에 대한 행위를 HTTP Method로 정의
  - RESTful하다라는 것은 REST API의 설계의도를 명확하게 지켜주는 것 (슬래시를 통해 계층관계를 표시한다던가 숫자는 id를 나타낸다든가 동사보단 명사를 위주)
* CORS(Cross-Origin Resource Sharing): 
  - 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생 하는 문제 
  - 웹 프론트 측에서 request header에 CORS 관련 옵션을 넣어주고, 서버에서는 해당 프론트 요청을 허용

#### CSR / SSR

##### CSR의 과정 

- 서버가 브라우저에게 응답을 보냄 
- 브라우저는 JS를 다운 받음 
- 브라우저는 리액트를 실행 
- 페이지가 보여지고 상호작용 

- SSR의 과정 :

  - 서버가 브라우저에게 HTML 응답, 랜더링하기 위한 준비가 되었다고 보냄 
  - 브라우저가 페이지랜더링, 페이지가 보여지고 브라우저는 JS 다운받음 
  - 브라우저 리액트 실행 
  - 페이지 상호작용 가능
- CSR과 SSR의 차이 : 

  * CSR은 마지막 단계 전까지 화면에 보여지지가 않고 로딩중 / SSR은 미리 페이지가 보여짐
  * CSR은 초기로딩속도가 느리긴하지만, 화면전환에 있어서 클라이언트에서 이루어져서 빠른 전환이 가능
  * SSR은 초기로딩속도가 빨라서 사용자가 느끼기엔 좋지만, 동작은 하지않음. 
  * 화면전환에 있어서 서버에 요청해야하므로 서버에 부담을 줄 수 있음. 서비스마다 사용자의 요구마다 다름.

* 브라우저 주소창에 주소 검색 이후의 렌더링 과정

  * DNS 서버가 연결해줄 곳을 찾음   

  * http / https 여부 판단
  * index.html 클라이언트로 보내고 브라우저가 index.html 파싱
  * DOM트리를 읽음:
    - css : link태그를 만나 css요청이 발생하면, 요청과 응답과정을 거치고 css를 파싱, 이후 중단된 html을 다시읽고 DOM트리를 완성
    - js : HTML파서는 Script태그를 만나게 되면 javascript 코드를 실행하기 위해 파싱을 중단. 제어권한을 자바스크립트 엔진에게 넘기고, 자바스크립트 코드 또는 파일을 로드해서 파싱하고 실행
  * DOM트리 + CSSOM트리= Render Tree를 만들고 그림

* OSI 7 Layer : 네트워크에서 통신이 일어나는 과정을 7단계로 캡슐화하여 서로 다른 동작을 각 layer에서 담당하는 것을 말한다. 이로서 통신이 일어나는 과정을 단계적으로 파악할 수 있으며 layer 별로 각기 다른 동작을 수행하기에 오류 탐지가 용이

  * 물리 계층(Physical layer) : 전기적, 기계적 특성을 바탕으로 비트 흐름을 전송. 이 계층은 데이터를 전달만 할 뿐, 데이터가 무엇인지 전혀 신경쓰지 않음(케이블, 리피터, 허브 등)
  * 데이터 링크 계층(DataLink layer) : 안전한 정보 전달을 보장. 물리 계층에서 전달 받은 프레임의 오류를 찾고 필요시 재전송을 요청
  * 네트워크 계층(Network layer) : 오류 없는 패킷을 목적지까지 안전하고 빠르게 전달하는 경로(라우팅)를 찾는 계층
  * Transport layer: 전송을 통해 통신을 활성화하는 계층. 패킷의 전송이 유효한지 확인하고 실패한 패킷을 재전송. end-to-end 통신의 신뢰성을 보장하고, 오류 검출, 흐름제어, 중복 검사를 수행한다.
  * 세션 계층(Session layer) : 포트를 연결하여 논리적인 통신을 가능하게 하는 계층
  * 표현 계층(Presentation layer) : 응용 프로그램을 위해 형식상 차이를 갖는 데이터를 인코딩하여 일관된 형태의 데이터를 표현하는 계층
  * 응용 계층(Application layer) : 사용자와 직접 상호작용하는 계층(크롬, 파이어폭스)

* TCP와 UDP : 전송 계층에서 패킷을 보내기 위한 프로토콜이다.

  * TCP (Transmission Control Protocol): 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 해제.  높은 신뢰성과 전송 순서를 보장한다. 1:1 통신에서 사용된다. UDP보다는 속도가 느림
  * UDP (User Datagram Protocol): 비연결형 서비스로 패킷을 주고 받을 때 신호 절차를 거치지 않음. 신뢰성이 낮으며 전송 순서가 바뀔 수 있음. 1:N 이나 N:N 통신에서 사용. TCP보다 속도가 빠름

* 3-way handshaking과 4-way handshaking (TCP)

  * 3-way handshaking: 장치들 사이의 접속을 성립하기 위한 절차로 양 장치 모두 데이터 통신 준비가 되었다는 것을 보장

    (SYN (Client) → SYN + ACK (Server) → ACK (Client)) 

  * 4-way handshaking: 장치들 사이의 통신을 종료하기 위한 절차: (FIN (Client) → ACK (Server) → FIN (Server) → ACK(Client))

- Long-Polling과 Websocket, Server-Sent Event:
  - Long-Polling: response를 닫지 않고 계속 보내주는 것
  - Websocket: subscribe 후에 양방향으로 메세지 교환
  - Server-Sent Event: Push, HTTP 사용
- HTTP와 HTTPS:
  - http 는 네트워크상에서 정보를 누군가가 마음대로 열람, 수정이 가능 / https는 누가 볼수없도록 막음
  - http방식이 https방식보다 빠름

  - Http방식은 민감한 정보를 다룰 때 항상 변조, 해킹 가능성을 생각해야 함
  - Https는 설치 및 인증서를 유지하는데 추가적인 비용이 발생.
  - 민감한 정보가 있는 페이지의 경우 Https 그렇지 않으면 http

- HTTP Method:
  - PUT :  요청된 자원을 수정할 때, 자원내 필드를 전체 수정할 때 사용 (만약 일부만 전달할 경우, 그외 필드들은 NULL or 초기값 처리)
  - PATCH :  요청된 자원을 수정할 때, 자원내 필드를 일부 수정할 때 사용
  - GET : Http Request Message의 Header 부분의 URL에 담겨서 전송되며, BODY는 비어있는 상태 URL에 ?뒤에 데이터를 가져오기 위한 조건이 포함. URL에 조건이 포함되었기 때문에 데이터의 제한이 존재하며, URL에 노출되기 때문에 보안의 위험존재. 
  - POST : Http Request Message의 BODY 부분에 클라이언트의 요청을 처리하기 위한 데이터가 존재. URL에 노출되지 않기 때문에 보안의 위험이 존재하지 않으며, 보내는 데이터의 제한이 없음
  - GET과 POST를 상황에 따라 써야하는 이유는, GET 요청은 캐싱이 된다. 그뜻은 웹 서버에 요청이 전달되지 않고, 캐시에서 데이터를 전달해준다는 것이다.
  - 만약 글작성을 GET으로 처리한다면, 똑같은 요청을 처리했을 때, 캐싱으로 인해 두번째부터의 동일한 글작성은 서버에 전달되지 않고 첫번째 캐싱된 결과를 계속 전달받을 수 있기 때문에 METHOD를 명확하게 구분해서 써야한다. 

* 웹 프로토콜
  * 웹 프로토콜 : 웹에서 쓰이는 통신규약
  * Http(Hyper text Transfer Protocol)  통신 : 웹 프로토콜중 하나로 HTTP가 가장 많이 쓰임. 요청과 응답으로 이루어져 있어 어떤 데이터를 요청하면, 어느 데이터를 준다고 응답
  * Http 1.1과 2.0: 속도의 차이. 2.0같은 경우는 헤더를 압축해서 보내기도하고, 한번의 연결로 동시에 여러 메시지를 주고 받을 수도 있음

#### 1) 웹 통신의 큰 흐름

* 브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.
* DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다. 일반적으로 설명하는 DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.
* 이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.
* 패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.
* 액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.
* 핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사
* 웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘김. 애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송

 

#### 2) TCP와 UDP

* `TCP` : 연결 지향형 프로토콜
* `UDP` : 데이터를 데이터 그램 단위로 전송하는 프로토콜
* TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느림
* TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.
* UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. 그래서 HTTP/3은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다. 즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.

 

#### 3) TCP 3, 4 way handshake

##### (1) TCP 3way handshake 

* 가상회선을 수립하는 단계 
* 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정
* SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송
*  정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.

##### (2) TCP 4way handshake

* 연결을 해제하는 단계
* 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결 해제
* 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문

 

#### 4) HTTP와 HTTPS의 차이점

* HTTP : 따로 암호화 과정을 거치지 않음. 중간에 패킷을 가로챌 수 있고, 수정할 수 있어 보안이 취약
* HTTPS : 중간에 암호화 계층을 거쳐서 패킷을 암호화

 

#### 5) HTTPS와 SSL Handshake

* HTTPS : HTTP에 보안 계층을 추가한 것
* HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.

* 제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 
* 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 
* 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.

클라이언트는 TCP 3way handshake를 수행한 이후 Client Hello를 전송합니다. 서버는 인증서를 보냅니다.(다른 정보들도 전송하나 검색을 통해 알 수 있는 부분입니다. 대개 그 정도까지는 요구하지 않습니다.)

클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다. 이 인증서는 인증기관의 개인키로 암호화되어있고, 공개키로 검증할 수 있습니다.(브라우저에 내장되어있음) 클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.

서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다. 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.

제3자 인증: 인증서, 인증기관/공개키 암호화: 인증서, 비밀키 공유/비밀키 암호화: 통신과정

 

#### 6) GET과 POST의 차이점

##### (1) GET

* 서버에 존재하는 정보를 요청
* 이 때 반환되는 정보는 정보 자체가 아니라 정보의 표현
* Request Body는 입력하지 않는 것이 일반적이며, 레거시 시스템의 경우 요청을 받아들이지 않을 수 있음
* 캐싱을 수행하기 때문에 캐싱되지 않는 요청은 GET 요청이 맞지 않을 수 있음

##### (2) POST

* 서버에 정보를 생성하는 것을 요청
* 예전 HTTP 통신은 POST 요청으로 데이터 삭제, 수정도 form 요청으로 같이 수행 
* POST 요청은 서버의 상태를 변경시키기 때문에 멱등성이 유지되지 않습니다. 
* Request Body에 요청하는 데이터를 담아 전송합니다.

 

#### 7) HTTP 메서드

OPTIONS, HEAD, TRACE의 존재에 대해서는 알아만 둡시다. 특히 TRACE는 몰라도 되는 것 같습니다. OPTIONS는 해당 uri에 대해 서버가 허용하는 메서드를 확인할 때 사용합니다. HEAD는 GET과 비슷하나 header만 가져옵니다.

* GET 요청은 서버에 존재하는 데이터를 요청하는 것입니다. CRUD로 따지면 R입니다.

* POST 요청은 서버에 데이터를 생성하는 것을 요청합니다. CRUD로 따지면 C입니다.

* PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성합니다. CRUD로 따지면 C,U입니다.

* DELETE 요청은 서버에 데이터를 제거할 것을 요청합니다. 존재하지 않아도 동일하게 동작합니다. CRUD로 따지면 D입니다.

* PATCH 요청은 서버에 존재하는 데이터를 일부 수정합니다. CRUD로 따지면 U입니다.



#### 8) RESTful

* HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현합니다. 사람이 읽을 수 있는 API라는 것이 특징입니다. HTTP를 사용하기 때문에 HTTP의 특성을 그대로 반영합니다. 또한 별도의 인프라 구축이 필요없습니다.

* 단점으로는 명확한 표준이 존재하지 않는다는 점, RESTful을 완전히 만족하는 API를 만들기는 매우 까다롭다는 점(그런 REST API로 괜찮은가 참고), REST API가 분산환경에 적합하지 않다는 점이 있습니다.(멱등성을 보장하기 힘들기 때문)

* HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게됩니다.(모든 관련된 동작을 URI를 통해 알려줍니다.) 즉, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점을 가져옵니다.



#### 9) CORS

* 서로 다른 도메인간에 자원을 공유하는 것
* 대부분의 브라우저에서는 이를 기본적으로 차단하며 서버측에서 헤더를 통해서 사용가능한 자원을 알려줌

* preflight request는 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청
* OPTIONS 메서드로 요청하며 CORS를 허용하는지 확인
* CORS가 허용된 웹서버라면 사용 가능한 리소스를 헤더에 담아 응답

 

* OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요.

OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.

실제로 우리가 대부분 사용하는 네트워크는 TCP/IP 4계층입니다. 통신에 실제로 사용되는 계층이고 1,2 계층이 1계층, 5, 6, 7계층이 4계층으로 운영됩니다.

 

## 2) 운영체제

---



#### 1) 프로세스와 스레드

* `프로세스` : _실행 중인 프로그램_, 운영체제로부터 자원을 할당, 한 프로세스 안에 여러개의 스레드가 생성될 수 있음

* `스레드` : _실행 제어만 분리한 것_, 프로세스로부터 자원을 할당, 코드 /데이터 /힙영역을 공유하기 때문에 좀 더 효율적으로 통신, 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠름, 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야 함

  


#### 2) 컨텍스트 스위칭

* _한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법_

* 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작

* CPU는 아무런 일을 하지 않으므로  잦은 컨텍스트 스위칭은 성능저하 원인

* 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭 가능

  

#### 3) 동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점

* 동기 방식은 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식입니다. 또, 동기 방식은 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같습니다.

* 비동기 방식은 여러 개의 처리가 함께 실행되는 방식으로, 동기 방식에 비해 단위시간 당 많은 작업을 처리할 수 있습니다. 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있습니다. 프로그램의 복잡도도 증가하게 됩니다.

* 블로킹/논블로킹은 동기/비동기와는 다른 관점으로, 내가 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류입니다.

* 블로킹 방식은 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있는 것을 의미합니다. 반면에 논블로킹은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.

* 동기 논블로킹은 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생합니다.

  

#### 4) 멀티스레드 프로그래밍 

* 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것

##### (1) 장점

* 멀티 프로세스에 비해 메모리 자원소모가 줄어듬
* 힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단
* 스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠름

##### (2) 단점

* 힙 영역에 있는 자원을 사용할 때는 동기화를 해야 함

* 동기화를 위해서 락을 과도하게 사용하면 성능이 저하

* 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료

  

#### 5) Thread-safe

* 두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다.
* java.util.concurrent 패키지 하위의 클래스를 사용합니다.
* 인스턴스 변수를 두지 않습니다.
* Singleton 패턴을 사용합니다.(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않습니다.)
* 동기화(syncronized) 블럭에서 연산을 수행합니다.



#### 6) 프로세스 동기화

* 다중 프로세스 환경에서 자원등에 한 프로세스만이 접근가능하도록 하는 것
* 프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 존재

##### (1) Race Condition(경쟁 상태)

* 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황
* 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황

##### (2)Critical Section(임계 구역)

* 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭
* 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능
* 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용

##### (3) 임계 구역 문제를 해결하기 위한 조건

* 상호 배제(Mutual Exclusion): 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.
* 진행(Progress): 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.
* 유한 대기(Bounded Waiting): 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)

 

#### 7) 교착상태(Deadlock) 

* 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태

##### (1) 교착 상태 발생조건

* 상호 배제 : 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 함
* 점유 대기 : 할당된 자원을 가진 상태에서 다른 자원을 기다림
* 비선점 : 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없음
* 순환대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음

##### (2) 교착 상태 해결방법

* 예방: 4가지 조건 중 하나라도 만족되지 않도록 함

* 회피: 알고리즘을 데드락이 발생하지 않도록 함

* 회복: 교착상태가 발생할 때 해결

* 무시: 회복과정의 성능저하가 심하다면 그냥 무시

  

* 기아상태(Starvation) : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우
  
* 우선순위를 변경합니다.(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용합니다.)
  
  

#### (3) 세마포어와 뮤텍스의 차이

* `세마포어` : _여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식_. 뮤텍스가 될 수 있음, 다른 프로세스가 세마포어를 해제할 수 있음

* `뮤텍스` : _한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식_. 뮤텍스는 세마포어가 될 수 없음, 락을 획득한 프로세스만 락을 반환할 수 있음

  

#### (4) 가상 메모리

* Swap 영역. 실제 메모리에서 공간이 부족한 경우 보조 기억 장치(auxiliary storage, secondary storage)에서 임시로 사용하는 영역
* OS 에서 관리하며 프로세스는 이것이 실제 메모리인지 Swap 영역인지 모름
* 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며 가급적이면 swap메모리를 사용하지 않도록 설계하는 것이 좋고 만약 계속해서 사용하는 양이 증가한다면 메모리 누수 의심

#### (5) 캐시의 지역성 

* 시간 지역성 : 최근에 접근한 데이터에 다시 접근하는 경향
* 공간 지역성 : 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향

#### (6) 프로세스 관련 용어

* PCB : 프로세스 제어 블록, 프로세스에 대한 중요한 정보를 저장
* PC : 프로그램 카운터, 프로세스 실행을 위한 다음 명령의 주소를 표시
* 캐시메모리 : 자주 사용되는 데이터가 저장되는 공간으로 CPU의 레지스터와 메모리 사이에서 병목 현상을 완화하는 장치

 

## 3) 데이터베이스

---

#### (1) 데이터베이스 인덱스 

* 검색성능을 향상시키기 위함
* 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 함
* `장점` : 빠른 검색 성능
* `단점` : 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행

#### (2) 트랜잭션 

* 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위
* 트랜잭션에는 여러개의 연산이 수행될 수 있음
* 트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공

##### (1) ACID 

* _트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질_
* Atomicity (원자성) : _트랜잭션의 연산은 모든 연산이 완벽히 수행_되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패
* Consistency (일관성) : _트랜잭션은 유효한 상태로만 변경될 수 있음_
* Isolation (고립성) : _동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행_되어야 함
* Durability (내구성) : _커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 함_ (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)

##### (2) 트랜잭션 격리 수준(Transaction Isolation Levels) 

* 고립도와 성능의 트레이드 오프를 조절
* `READ UNCOMMITTED` : 다른 트랜잭션에서 커밋되지 않은 내용도 참조
* `READ COMMITTED` : 다른 트랜잭션에서 커밋된 내용만 참조
* `REPEATABLE READ` : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조
* `SERIALIZABLE `: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 함
* 정규화 : 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것

#### (3) RDBMS / NOSQL 

##### (1) RDBMS

* _데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스_
*  SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다. 
* 명확한 데이터 구조를 보장, 중복을 피할 수 있음

##### (2) NOSQL

* _자유로운 형태로 데이터를 저장_

* 수평확장을 할 수 있고 분산처리를 지원

* key-value store, bigtable, dynamo, document db, graph db

  

