<!DOCTYPE html><html lang="ko"><head><style data-href="/styles.8ab4be3c937b074fb994.css">code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}@font-face{font-family:NanumBarunGothicSubset;src:local("NanumBarunGothicSubset"),url(/static/NanumBarunGothicSubset-52c895afbd91cc92aa04a6f791219e85.woff2) format("woff2")}body{font-family:NanumBarunGothicSubset!important;width:100vw;overflow-x:hidden}#___gatsby{width:100vw;height:100vh}::-webkit-scrollbar{width:23px;background-color:#141414}::-webkit-scrollbar-thumb{background-image:linear-gradient(45deg,#8e2de2,#4a00e0);border-radius:10px;background-clip:padding-box;border:3px solid rgba(0,0,0,0)}::-webkit-scrollbar-track{background-color:rgba(0,0,0,0)}::-webkit-scrollbar-corner{background-color:#141414}body{background:-webkit-gradient(linear,left top,right top,from(#8e2de2),to(#4a00e0));background:linear-gradient(90deg,#8e2de2,#4a00e0);height:100vh;color:#fff}ol,ul{list-style:unset!important;margin:0;padding:0}.gatsby-highlight pre[class*=language-]{min-width:100%;font-family:NanumBarunGothic!important;padding:30px}code[class*=language-],pre[class*=language-]{color:#fff}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#373b44;padding:7px;@media (max-width:600px){margin-top:-100px;font-size:10px}}.language-text{margin:5px;@media (max-width:600px){margin-top:-100px;font-size:10px}}code.language-text{background:linear-gradient(45deg,#00c9ff,#92fe9d)!important;font-family:NanumBarunGothic!important;color:#292929;font-weight:400}</style><meta name="generator" content="Gatsby 2.22.15"/><style data-styled="" data-styled-version="5.1.0"></style><style type="text/css">
    .anchor-header.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor-header.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor-header svg,
    h2 .anchor-header svg,
    h3 .anchor-header svg,
    h4 .anchor-header svg,
    h5 .anchor-header svg,
    h6 .anchor-header svg {
      visibility: hidden;
    }
    h1:hover .anchor-header svg,
    h2:hover .anchor-header svg,
    h3:hover .anchor-header svg,
    h4:hover .anchor-header svg,
    h5:hover .anchor-header svg,
    h6:hover .anchor-header svg,
    h1 .anchor-header:focus svg,
    h2 .anchor-header:focus svg,
    h3 .anchor-header:focus svg,
    h4 .anchor-header:focus svg,
    h5 .anchor-header:focus svg,
    h6 .anchor-header:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><title data-react-helmet="true">jigglog| vue 공부 1일차</title><meta data-react-helmet="true" name="og:title" content="jigglog| vue 공부 1일차"/><style data-styled="" data-styled-version="5.1.0">@media (max-width:414px){.iqeByS[href="/"]{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:60px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}}/*!sc*/
data-styled.g7[id="styled__StyledLink-sc-8u1x3g-4"]{content:"iqeByS,"}/*!sc*/
.bntZrz{font-size:13px;font-weight:800;margin:0 0.25rem;text-shadow:2px 2px 2px #141414;}/*!sc*/
@media (max-width:600px){.bntZrz{font-size:12px;}.bntZrz.menuvisible{visibility:hidden;}}/*!sc*/
data-styled.g8[id="styled__MenuTitle-sc-8u1x3g-5"]{content:"bntZrz,"}/*!sc*/
.jghhmh{margin:10px;font-size:12px;font-weight:800;}/*!sc*/
@media (max-width:600px){.jghhmh{font-size:10px;}}/*!sc*/
data-styled.g9[id="styled__SmallItem-sc-8u1x3g-6"]{content:"jghhmh,"}/*!sc*/
.kTHvNm{grid-row:1/2;grid-column:1/3;-webkit-transition:all 0.3s ease-in-out;transition:all 0.3s ease-in-out;font-family:"NanumBarunGothicSubset";src:local("NanumBarunGothicSubset"),url("../../fonts/NanumBarunGothicSubset.woff2") format("woff2");position:fixed;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;top:0;height:60px;width:100%;font-size:14px;font-weight:600;z-index:2;background-color:#141414;}/*!sc*/
.kTHvNm .test{padding:2px;border:2px solid white;}/*!sc*/
.kTHvNm.active{padding-left:200px;}/*!sc*/
.kTHvNm .container{height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transition:all 0.3s ease-in-out;transition:all 0.3s ease-in-out;}/*!sc*/
.kTHvNm .ul{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;list-style-type:none;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-weight:600;margin:0 0.5rem;}/*!sc*/
.kTHvNm .logo{font-size:15px;font-weight:800;}/*!sc*/
.kTHvNm .li{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:12px;font-weight:800;margin:5px;}/*!sc*/
.kTHvNm .be-person{color:white;}/*!sc*/
.kTHvNm .logout{cursor:pointer;}/*!sc*/
.kTHvNm .hamberger{cursor:pointer;}/*!sc*/
data-styled.g10[id="styled__HeaderDiv-sc-8u1x3g-7"]{content:"kTHvNm,"}/*!sc*/
.kgovCY{grid-row:1/3;grid-column:1/3;background:linear-gradient(20deg,rgba(172,0,255,0.8) 46%,rgba(0,207,255,0.8) 100%);visibility:hidden;position:fixed;width:0;height:100%;z-index:3;-webkit-transition:all 0.3s ease-in-out;transition:all 0.3s ease-in-out;}/*!sc*/
.kgovCY.active{visibility:visible;width:200px;}/*!sc*/
data-styled.g11[id="styled__SideBarDiv-sc-8u1x3g-8"]{content:"kgovCY,"}/*!sc*/
.jABbLz{display:grid;grid-template-rows:160px 1fr;visibility:hidden;-webkit-transition:all 0.3s ease-in-out;transition:all 0.3s ease-in-out;-webkit-transition-delay:-0.2s;transition-delay:-0.2s;z-index:2;}/*!sc*/
.jABbLz.active{-webkit-transition-delay:0.2s;transition-delay:0.2s;visibility:visible;}/*!sc*/
data-styled.g12[id="styled__SideBarInnerDiv-sc-8u1x3g-9"]{content:"jABbLz,"}/*!sc*/
.jXLHVK{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;grid-row:1/2;z-index:3;margin-top:3rem;}/*!sc*/
.jXLHVK h1{font-size:13px;font-weight:600;margin:10px;text-shadow:2px 2px 2px gray;}/*!sc*/
.jXLHVK hr{border:none;background-color:rgba(255,255,255,0.5);width:60%;height:2px;}/*!sc*/
data-styled.g13[id="styled__SideBarTopDiv-sc-8u1x3g-10"]{content:"jXLHVK,"}/*!sc*/
.hioUuB{grid-row:2/3;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;max-height:60vh;overflow:scroll;margin:10px;background-color:#141414;}/*!sc*/
data-styled.g15[id="styled__SideBarListDiv-sc-8u1x3g-12"]{content:"hioUuB,"}/*!sc*/
.iMfA-DO{cursor:pointer;}/*!sc*/
.iMfA-DO .box{display:inline-block;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
.iMfA-DO img{width:60px;height:60px;border:4px solid transparent;border-radius:50%;object-fit:cover;box-shadow:3px 3px 3px black;}/*!sc*/
.iMfA-DO .admin{background:linear-gradient(45deg,#000000,#000000) padding-box,linear-gradient(45deg,#00b09b,#96c93d) border-box;}/*!sc*/
data-styled.g18[id="style__BorderDiv-fw5yvl-0"]{content:"iMfA-DO,"}/*!sc*/
.dmGmmo{-webkit-transition:all 0.3s ease-in-out;transition:all 0.3s ease-in-out;font-family:"NanumBarunGothicSubset";src:local("NanumBarunGothicSubset"),url("../../fonts/NanumBarunGothicSubset.woff2") format("woff2");position:fixed;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;bottom:0;height:50px;width:100%;font-size:10px;font-weight:600;z-index:2;background-color:#141414;}/*!sc*/
.dmGmmo .text{font-size:10px;font-weight:800;padding:50px;}/*!sc*/
data-styled.g19[id="styled__FooterDiv-sc-1a50tl6-0"]{content:"dmGmmo,"}/*!sc*/
.kbRvHn{background:linear-gradient(90deg,#8e2de2,#4a00e0);}/*!sc*/
data-styled.g20[id="styled__Wrapper-sc-15v8614-0"]{content:"kbRvHn,"}/*!sc*/
.hnwaga{background:linear-gradient(90deg,#8e2de2,#4a00e0);position:absolute;background:transparent;width:100%;height:100vh;}/*!sc*/
data-styled.g21[id="styled__LayoutWrapper-sc-1x92zxt-0"]{content:"hnwaga,"}/*!sc*/
.bkWEwV{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}/*!sc*/
data-styled.g23[id="styled__OuterWrapper-sc-1x92zxt-2"]{content:"bkWEwV,"}/*!sc*/
.cBddps .divider{margin-top:50px;margin-bottom:20px;margin-left:10px;margin-right:10px;height:3px;background-color:gray;}/*!sc*/
.cBddps img{width:50px;height:50px;}/*!sc*/
.cBddps .biotext{color:black;font-size:13px;margin-top:10px;font-weight:800;}/*!sc*/
.cBddps .myname{color:black;font-size:13px;margin-top:10px;font-weight:800;}/*!sc*/
.cBddps .gridgap{margin-top:10px;}/*!sc*/
.cBddps .circle{margin:0;padding:0;}/*!sc*/
data-styled.g69[id="styled__BioWrapper-sc-1q0fm4m-0"]{content:"cBddps,"}/*!sc*/
.dZctMr{margin:10px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;height:45px;width:45px;border-radius:50%;text-align:center;border:1.5px solid #ebebeb;}/*!sc*/
.dZctMr svg{width:20px;height:20px;}/*!sc*/
data-styled.g70[id="styled__CircleWrapper-sc-1q0fm4m-1"]{content:"dZctMr,"}/*!sc*/
.jWVJkG:before,.jWVJkG:after{display:block;clear:both;content:"";}/*!sc*/
data-styled.g71[id="Clearfix-j34zgs-0"]{content:"jWVJkG,"}/*!sc*/
.lmJOuU{margin:auto;padding:10px 0 0;margin:0 40px 40px 40px;font-size:16px;background-color:white;border-radius:10px;box-shadow:10px 10px 10px black;}/*!sc*/
@media (max-width:600px){.lmJOuU{padding:70px 16px 0;margin:0 10px 10px 10px;}}/*!sc*/
.lmJOuU:before,.lmJOuU:after{display:block;content:"";clear:both;}/*!sc*/
.lmJOuU h1{margin:0.67em 0;font-size:36px;}/*!sc*/
.lmJOuU time{margin:1em 0;font-size:14px;}/*!sc*/
.lmJOuU a{font-size:12px;font-weight:800;color:gray;}/*!sc*/
data-styled.g73[id="styled__PostWrapper-sc-1hokm1n-1"]{content:"lmJOuU,"}/*!sc*/
.dUDtWR{padding:0 20px 20px 20px;line-height:2em;color:black;}/*!sc*/
.dUDtWR h1{margin-top:5em;font-size:32px;font-weight:800;}/*!sc*/
.dUDtWR h2{margin-top:5em;font-size:28px;font-weight:800;}/*!sc*/
.dUDtWR h3{margin-top:1em;font-size:24px;font-weight:800;}/*!sc*/
.dUDtWR h4{margin-top:1em;font-size:21px;font-weight:800;}/*!sc*/
.dUDtWR h5{margin-top:1em;font-size:19px;font-weight:800;}/*!sc*/
.dUDtWR p{margin-top:10px;font-size:18px;font-weight:100;}/*!sc*/
.dUDtWR strong{margin-top:100px;font-size:22px;font-weight:800;}/*!sc*/
.dUDtWR li{margin-top:10px;margin-left:30px;font-size:18px;font-weight:100;}/*!sc*/
.dUDtWR blockquote{line-height:1.2em;color:#aaa;margin-top:18px;font-size:18px;}/*!sc*/
.dUDtWR em{line-height:1.2em;font-weight:1000;margin-top:18px;font-size:18px;-webkit-text-decoration:underline;text-decoration:underline;}/*!sc*/
.dUDtWR pre,.dUDtWR span{margin-top:10px;font-size:14px;}/*!sc*/
.dUDtWR table{margin:20px;background:#f9f9f9;}/*!sc*/
.dUDtWR thead{background:#e2e2e2;font-weight:800;}/*!sc*/
.dUDtWR th,.dUDtWR tr,.dUDtWR td{border:2px solid gray;color:black;padding:10px;font-size:14px;min-width:3rem;}/*!sc*/
.dUDtWR hr{margin-bottom:30px;}/*!sc*/
.dUDtWR code{position:relative;}/*!sc*/
.dUDtWR del{visibility:hidden;-webkit-text-decoration:none;text-decoration:none;color:gray;}/*!sc*/
@media (max-width:1000px){.dUDtWR{padding:0 10px 10px 10px;line-height:2em;color:black;}.dUDtWR hr{margin-bottom:10px;}.dUDtWR h1{margin-bottom:2px;font-size:18px;}.dUDtWR h2{font-size:16px;}.dUDtWR h3{font-size:14px;}.dUDtWR h4{font-size:12px;}.dUDtWR h5{font-size:10px;}.dUDtWR p,.dUDtWR blockquote,.dUDtWR pre{margin-top:5px;font-size:10px;}.dUDtWR li{line-height:2.5em;margin-top:5px;font-size:10px;margin-left:10px;}.dUDtWR table{margin:20px;}.dUDtWR th,.dUDtWR tr,.dUDtWR td,.dUDtWR span,.dUDtWR em{font-size:10px;}.dUDtWR strong{font-size:14px;}}/*!sc*/
data-styled.g75[id="styled__PostContent-sc-1hokm1n-3"]{content:"dUDtWR,"}/*!sc*/
@media (max-width:600px){.ilhkQa{display:none;}}/*!sc*/
data-styled.g77[id="styled__ClearMobile-sc-1hokm1n-5"]{content:"ilhkQa,"}/*!sc*/
.iaGTzG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:white;background:linear-gradient(45deg,#000000,#434343);border-radius:4px;outline:0;border:0;}/*!sc*/
.iaGTzG h4{margin:2px;}/*!sc*/
data-styled.g78[id="styled__Button-sc-1hokm1n-6"]{content:"iaGTzG,"}/*!sc*/
.dsQNWx .jb-wrap{max-height:400px;width:100%;margin:10px auto;position:relative;overflow:hidden;}/*!sc*/
.dsQNWx .jb-wrap img{max-height:initial;width:100%;vertical-align:middle;}/*!sc*/
.dsQNWx .jb-text{color:white;font-weight:800;text-shadow:2px 2px 20px white;font-size:30px;text-align:center;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);background-color:black;padding:5%;line-height:2em;}/*!sc*/
@media (max-width:600px){.dsQNWx .jb-text{font-size:15px;}}/*!sc*/
@-webkit-keyframes blink{50%{opacity:0.8;}100%{opacity:1;}}/*!sc*/
@keyframes blink{50%{opacity:0.8;}100%{opacity:1;}}/*!sc*/
data-styled.g79[id="styled__ImageWrapper-sc-1hokm1n-7"]{content:"dsQNWx,"}/*!sc*/
.iFwxVQ{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding-left:30px;padding-right:30px;}/*!sc*/
data-styled.g80[id="styled__WarpVisible-sc-1hokm1n-8"]{content:"iFwxVQ,"}/*!sc*/
.cSpTsB{position:-webkit-sticky;position:sticky;top:70px;display:block;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;}/*!sc*/
.cSpTsB h4{font-size:14px;font-weight:800;}/*!sc*/
@media (max-width:1200px){.cSpTsB h4{font-size:10px;font-weight:800;}}/*!sc*/
@media (max-width:992px){.cSpTsB{display:none;}}/*!sc*/
.cSpTsB .lineblock{display:inline-block;}/*!sc*/
.cSpTsB .smallcircle{display:inline-block;padding-left:30px;font-weight:800;color:greenyellow;vertical-align:middle;}/*!sc*/
data-styled.g81[id="styled__Visible-sc-1hokm1n-9"]{content:"cSpTsB,"}/*!sc*/
.hAenLH{position:-webkit-sticky;position:sticky;display:block;top:20vh;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;}/*!sc*/
@media (max-width:992px){.hAenLH{display:none;}}/*!sc*/
data-styled.g82[id="styled__VisibleTable-sc-1hokm1n-10"]{content:"hAenLH,"}/*!sc*/
.hWEvTs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:white;background-image:linear-gradient(45deg,#8E2DE2,#4A00E0);border-radius:4px;outline:0;border:0;box-shadow:2px 2px 2px black;}/*!sc*/
data-styled.g85[id="styled__Button-sc-1aanmmt-0"]{content:"hWEvTs,"}/*!sc*/
.cdHxYi{font-size:15px;font-weight:800;margin:5px;text-shadow:3px 3px 30px white;}/*!sc*/
data-styled.g86[id="styled__PrintTitle-sc-1aanmmt-1"]{content:"cdHxYi,"}/*!sc*/
.iRLYFX{padding:5%;position:relative;display:grid;grid-template-rows:50px 1fr 270px;}/*!sc*/
data-styled.g93[id="style__CommentDiv-f1ulxg-6"]{content:"iRLYFX,"}/*!sc*/
</style><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="manifest" href="/manifest.webmanifest"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><link rel="shortcut icon" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="48x48" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/favicon-48x48.png"/><link rel="manifest" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/manifest.json"/><meta name="mobile-web-app-capable" content="yes"/><meta name="theme-color" content="#fff"/><meta name="application-name" content="gatsby-advanced-blog"/><link rel="apple-touch-icon" sizes="57x57" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-152x152.png"/><link rel="apple-touch-icon" sizes="167x167" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-167x167.png"/><link rel="apple-touch-icon" sizes="180x180" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-180x180.png"/><link rel="apple-touch-icon" sizes="1024x1024" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-icon-1024x1024.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/><meta name="apple-mobile-web-app-title" content="gatsby-advanced-blog"/><link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-640x1136.png"/><link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-750x1334.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-828x1792.png"/><link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1125x2436.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1242x2208.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1242x2688.png"/><link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1536x2048.png"/><link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1668x2224.png"/><link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1668x2388.png"/><link rel="apple-touch-startup-image" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2048x2732.png"/><link rel="apple-touch-startup-image" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1620x2160.png"/><link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1136x640.png"/><link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1334x750.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-1792x828.png"/><link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2436x1125.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2208x1242.png"/><link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2688x1242.png"/><link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2048x1536.png"/><link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2224x1668.png"/><link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2388x1668.png"/><link rel="apple-touch-startup-image" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2732x2048.png"/><link rel="apple-touch-startup-image" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="/icons-62a08f42ca1f8af3cd82ef580e951ba4/apple-touch-startup-image-2160x1620.png"/><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><script>
  
  function gaOptout(){document.cookie=disableStr+'=true; expires=Thu, 31 Dec 2099 23:59:59 UTC;path=/',window[disableStr]=!0}var gaProperty='UA-173606059-1',disableStr='ga-disable-'+gaProperty;document.cookie.indexOf(disableStr+'=true')>-1&&(window[disableStr]=!0);
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-173606059-1', 'auto', {});
      ga('set', 'anonymizeIp', true);
      
      
      
      
      }</script><title data-react-helmet="true"></title><link as="script" rel="preload" href="/webpack-runtime-9a069dfb23f8443c2eef.js"/><link as="script" rel="preload" href="/framework-ffd9c0bba7cdf399bad4.js"/><link as="script" rel="preload" href="/app-a62b28eb55c66165547c.js"/><link as="script" rel="preload" href="/styles-ae6d046c35c187471a06.js"/><link as="script" rel="preload" href="/545f34e4-699a489d72ce4efc69d8.js"/><link as="script" rel="preload" href="/fb7d5399-a04be0fcb814b11f1f30.js"/><link as="script" rel="preload" href="/78e521c3-dc074188099d099a0295.js"/><link as="script" rel="preload" href="/1bfc9850-111378d602944f040fd6.js"/><link as="script" rel="preload" href="/0c428ae2-dcb1cda6f06718491f22.js"/><link as="script" rel="preload" href="/7608a4a4e80a2d64cce96855cef341673398a342-88208b24539781f28490.js"/><link as="script" rel="preload" href="/468967d5554fbdfaa4755e6d87845426800be832-8d47232650e59cbb1969.js"/><link as="script" rel="preload" href="/73bb605ea3e8982cb7cb1d831bcb96853dcd1a75-8dc90ba7f3de59cbdfbd.js"/><link as="script" rel="preload" href="/c2c45664921f384cbb57e917886f75ed18a7c772-507cfa34282fddb19c00.js"/><link as="script" rel="preload" href="/component---src-templates-post-jsx-dfab648e2dcf638ae7e0.js"/><link as="fetch" rel="preload" href="/page-data\vue공부1일차\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data\app-data.json" crossorigin="anonymous"/><meta name="google-site-verification" content="iJNm9P7wYJjzTUuWrwBW8Hgl1I7JevIZjuUyGFAshLg"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Access-Control-Allow-Origin" content="*"/><meta http-equiv="Access-Control-Allow-Headers" content="*"/><meta http-equiv="Access-Control-Expose-Headers" content="*"/><meta http-equiv="Access-Control-Allow-Credentials" content="true"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta id="viewport" name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1"/><meta name="description" content="새로운 개발을 좋아하는 개발자"/><meta name="keywords" content="Gatsby, ReactJS"/><meta name="author" content="JIGGLYPOP"/><meta property="og:title" content="jigglog"/><meta property="og:site_name" content="jigglog"/><meta property="og:type" content="website"/><meta property="og:description" content="새로운 개발을 좋아하는 개발자"/><meta property="og:locale" content="ko_KR"/><style id="gatsby-inlined-css">html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video,
input,
textarea {
  box-sizing: border-box;
}

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
menu,
nav,
section {
  display: block;
}
body {
  line-height: 1;
}
ol,
ul {
  list-style: none;
}
blockquote,
q {
  quotes: none;
}
blockquote:before,
blockquote:after,
q:before,
q:after {
  content: "";
  content: none;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
a,
a:focus,
a:hover,
a:visited {
  color: white;
  text-decoration: blink;
}
img {
  user-select: none;
}
body {
  -webkit-font-smoothing: antialiased;
}
button,
a,
label {
  cursor: pointer;
}
*[disabled] {
  cursor: not-allowed;
}

body {
  width: 100vw;
  height: 100vh;
}
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="styled__OuterWrapper-sc-1x92zxt-2 bkWEwV"><div id="layoutwrapper" class="styled__LayoutWrapper-sc-1x92zxt-0 hnwaga"><div class="styled__Wrapper-sc-15v8614-0 kbRvHn"><nav><div><nav class="styled__HeaderDiv-sc-8u1x3g-7 kTHvNm HeaderDiv"><div class="container"><div class="ul"><div class="li"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" style="color:white;font-size:20px" class="hamberger" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></div><div class="li"><a class="styled__StyledLink-sc-8u1x3g-4 iqeByS" href="/"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" style="width:25px;height:25px" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill-rule="nonzero" d="M10 6a8 8 0 0 0 11.955 6.956C21.474 18.03 17.2 22 12 22 6.477 22 2 17.523 2 12c0-5.2 3.97-9.474 9.044-9.955A7.963 7.963 0 0 0 10 6zm-6 6a8 8 0 0 0 8 8 8.006 8.006 0 0 0 6.957-4.045c-.316.03-.636.045-.957.045-5.523 0-10-4.477-10-10 0-.321.015-.64.045-.957A8.006 8.006 0 0 0 4 12zm14.164-9.709L19 2.5v1l-.836.209a2 2 0 0 0-1.455 1.455L16.5 6h-1l-.209-.836a2 2 0 0 0-1.455-1.455L13 3.5v-1l.836-.209A2 2 0 0 0 15.29.836L15.5 0h1l.209.836a2 2 0 0 0 1.455 1.455zm5 5L24 7.5v1l-.836.209a2 2 0 0 0-1.455 1.455L21.5 11h-1l-.209-.836a2 2 0 0 0-1.455-1.455L18 8.5v-1l.836-.209a2 2 0 0 0 1.455-1.455L20.5 5h1l.209.836a2 2 0 0 0 1.455 1.455z"></path></g></svg></a><a class="styled__StyledLink-sc-8u1x3g-4 iqeByS" href="/"><div class="styled__MenuTitle-sc-8u1x3g-5 bntZrz menuvisible">JIGGLOG</div></a></div></div><div class="ul"><div class="li"><h4><a class="styled__StyledLink-sc-8u1x3g-4 iqeByS" href="/portfolios"><div class="styled__MenuTitle-sc-8u1x3g-5 bntZrz menuvisible">포트폴리오</div></a></h4></div><div class="li"><h4><a class="styled__StyledLink-sc-8u1x3g-4 iqeByS" href="/resume"><div class="styled__MenuTitle-sc-8u1x3g-5 bntZrz menuvisible">이력서</div></a></h4></div></div></div></nav></div><div class="styled__SideBarDiv-sc-8u1x3g-8 kgovCY SideBarDiv"><div class="styled__SideBarInnerDiv-sc-8u1x3g-9 jABbLz SideBarInnerDiv"><div class="styled__SideBarTopDiv-sc-8u1x3g-10 jXLHVK"><div><a href="/resume"><div width="60px" height="60px" class="style__BorderDiv-fw5yvl-0 iMfA-DO"><div class="box"><img src="/jigglypop.gif" class="admin" alt="box"/></div></div></a><div class="nameh1"><h1>JIGGLYPOP</h1></div><div class="nameh1"><h1>염동환</h1></div></div></div><div class="styled__SideBarListDiv-sc-8u1x3g-12 hioUuB"><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/정보처리기사 필기/1">정보처리기사 필기<!-- --> <small>(15)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/정보처리기사 실기 요약/1">정보처리기사 실기 요약<!-- --> <small>(1)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/vue.js/1">vue.js<!-- --> <small>(2)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/기술 면접/1">기술 면접<!-- --> <small>(9)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/자격증/1">자격증<!-- --> <small>(7)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/react/1">react<!-- --> <small>(1)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/RxJs/1">RxJs<!-- --> <small>(1)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/three.js 공부/1">three.js 공부<!-- --> <small>(1)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/정보처리기사 실기/1">정보처리기사 실기<!-- --> <small>(20)</small></a></div><div class="styled__SmallItem-sc-8u1x3g-6 jghhmh"><a href="/categories/알고리즘/1">알고리즘<!-- --> <small>(2)</small></a></div></div></div></div></nav><main><div class="styled__PostWrapper-sc-1hokm1n-1 lmJOuU"><div class="MuiGrid-root MuiGrid-container"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><div class="styled__ImageWrapper-sc-1hokm1n-7 dsQNWx"><div class="jb-wrap"><div class="jb-image"><img src="/static/1-5f5e3d9ae284b236ec2c64b060aa7893.jpg" alt=""/></div><div class="jb-text">vue 공부 1일차</div></div></div></div><div class="MuiGrid-root stickyvisible MuiGrid-item MuiGrid-grid-md-2 MuiGrid-grid-lg-2"><div class="styled__Visible-sc-1hokm1n-9 cSpTsB"><div class="styled__BioWrapper-sc-1q0fm4m-0 cBddps"><div class="MuiGrid-root MuiGrid-container"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><hr class="divider"/></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><a href="/resume"><img src="/github.png"/></a></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><p class="biotext">JIGGLYPOP</p></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><p class="biotext">염동환</p></div><div class="MuiGrid-root gridgap MuiGrid-item MuiGrid-grid-xs-12"><hr class="divider"/><p class="biotext">새로운 개발을 좋아하는 개발자</p></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-4"><a href="https://github.com/jigglypop" target="_blank" rel="noreferrer noopener" class="circle"><div class="styled__CircleWrapper-sc-1q0fm4m-1 dZctMr"><svg viewBox="0 0 26 28" style="margin:0;padding:0"><path d="M10 19c0 1.141-0.594 3-2 3s-2-1.859-2-3 0.594-3 2-3 2 1.859 2 3zM20 19c0 1.141-0.594 3-2 3s-2-1.859-2-3 0.594-3 2-3 2 1.859 2 3zM22.5 19c0-2.391-1.453-4.5-4-4.5-1.031 0-2.016 0.187-3.047 0.328-0.812 0.125-1.625 0.172-2.453 0.172s-1.641-0.047-2.453-0.172c-1.016-0.141-2.016-0.328-3.047-0.328-2.547 0-4 2.109-4 4.5 0 4.781 4.375 5.516 8.188 5.516h2.625c3.813 0 8.188-0.734 8.188-5.516zM26 16.25c0 1.734-0.172 3.578-0.953 5.172-2.063 4.172-7.734 4.578-11.797 4.578-4.125 0-10.141-0.359-12.281-4.578-0.797-1.578-0.969-3.437-0.969-5.172 0-2.281 0.625-4.438 2.125-6.188-0.281-0.859-0.422-1.766-0.422-2.656 0-1.172 0.266-2.344 0.797-3.406 2.469 0 4.047 1.078 5.922 2.547 1.578-0.375 3.203-0.547 4.828-0.547 1.469 0 2.953 0.156 4.375 0.5 1.859-1.453 3.437-2.5 5.875-2.5 0.531 1.062 0.797 2.234 0.797 3.406 0 0.891-0.141 1.781-0.422 2.625 1.5 1.766 2.125 3.938 2.125 6.219z"></path></svg></div></a></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-4"><a href="https://www.facebook.com/donghwan.yeom.3" target="_blank" rel="noreferrer noopener" class="circle"><div class="styled__CircleWrapper-sc-1q0fm4m-1 dZctMr"><svg viewBox="0 0 16 28" style="margin:0;padding:0"><path d="M14.984 0.187v4.125h-2.453c-1.922 0-2.281 0.922-2.281 2.25v2.953h4.578l-0.609 4.625h-3.969v11.859h-4.781v-11.859h-3.984v-4.625h3.984v-3.406c0-3.953 2.422-6.109 5.953-6.109 1.687 0 3.141 0.125 3.563 0.187z"></path></svg></div></a></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-4"><a href="https://www.instargram.com/yeom_donghwan" target="_blank" rel="noreferrer noopener" class="circle"><div class="styled__CircleWrapper-sc-1q0fm4m-1 dZctMr"><svg viewBox="0 0 24 24" style="margin:0;padding:0"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"></path></svg></div></a></div></div></div><div class="styled__WarpVisible-sc-1hokm1n-8 iFwxVQ"><div class="lineblock"><button type="button" class="styled__Button-sc-1hokm1n-6 iaGTzG"><h4>블록가리기</h4></button></div><div class="lineblock"><div class="lineblock"><div class="smallcircle"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="8"></circle></svg></div></div></div></div><div class="styled__WarpVisible-sc-1hokm1n-8 iFwxVQ"><div class="lineblock"><button type="button" class="styled__Button-sc-1hokm1n-6 iaGTzG"><h4>밑줄가리기</h4></button></div><div class="lineblock"><div class="lineblock"><div class="smallcircle"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="8"></circle></svg></div></div></div></div><div class="styled__WarpVisible-sc-1hokm1n-8 iFwxVQ"><div class="lineblock"><button type="button" class="styled__Button-sc-1hokm1n-6 iaGTzG"><h4>요약가리기</h4></button></div><div class="lineblock"><div class="lineblock"><div class="smallcircle"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M8 15A7 7 0 108 1a7 7 0 000 14zm0 1A8 8 0 108 0a8 8 0 000 16z" clip-rule="evenodd"></path></svg></div></div></div></div></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-sm-12 MuiGrid-grid-md-8 MuiGrid-grid-lg-8"><div class="styled__ClearMobile-sc-1hokm1n-5 ilhkQa"><div class="styled__ButtonInline-sc-1hokm1n-0 glyxnx"><div class="Clearfix-j34zgs-0 jWVJkG"><button type="button" class="styled__Button-sc-1aanmmt-0 hWEvTs"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M448 192V77.25c0-8.49-3.37-16.62-9.37-22.63L393.37 9.37c-6-6-14.14-9.37-22.63-9.37H96C78.33 0 64 14.33 64 32v160c-35.35 0-64 28.65-64 64v112c0 8.84 7.16 16 16 16h48v96c0 17.67 14.33 32 32 32h320c17.67 0 32-14.33 32-32v-96h48c8.84 0 16-7.16 16-16V256c0-35.35-28.65-64-64-64zm-64 256H128v-96h256v96zm0-224H128V64h192v48c0 8.84 7.16 16 16 16h48v96zm48 72c-13.25 0-24-10.75-24-24 0-13.26 10.75-24 24-24s24 10.74 24 24c0 13.25-10.75 24-24 24z"></path></svg><div class="styled__PrintTitle-sc-1aanmmt-1 cdHxYi">PRINT</div></button></div></div></div><div class="styled__PostContent-sc-1hokm1n-3 dUDtWR"><h5>2021-04-04 12:23<!-- --> 시에 저장한 글입니다.</h5><hr style="margin-bottom:50px"/><div id="post-contents" style="margin-bottom:100px"><ol>
<li>
<h3 id="vuejs란-무엇인가" style="position:relative;"><a href="#vuejs%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="vuejs란 무엇인가 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>VueJS란 무엇인가</h3>
<p><strong>Vue.js</strong>는 사용자 인터페이스를 만들기 위한 진보적인 프레임워크입니다. 핵심 라이브러리는 <code class="language-text">뷰 레이어</code>만 초점을 맞추어, 다른 라이브러리나 기존 프로젝트와의 통합이 쉽습니다.</p>
</li>
<li>
<h3 id="vuejs의-주요-특징은" style="position:relative;"><a href="#vuejs%EC%9D%98-%EC%A3%BC%EC%9A%94-%ED%8A%B9%EC%A7%95%EC%9D%80" aria-label="vuejs의 주요 특징은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>VueJS의 주요 특징은</h3>
<p>아래의 항목들은 VueJS의 주요 특징들입니다.</p>
<ol>
<li><strong>가상 DOM(Virtual DOM):</strong> VueJS에서는 ReactJS, Ember 프레임워크와 유사하게 가상 DOM을 사용합니다. 가상 DOM은 원본 HTML DOM을 표현하는 메모리 상의 가벼운 DOM 트리로, 원본 DOM에 영향을 미치지 않고 업데이트를 할 수 있습니다.</li>
<li><strong>컴포넌트(Components):</strong> VueJS 어플리케이션에서 재사용할 수 있는 엘리먼트들을 만들 수 있습니다.</li>
<li><strong>템플릿(Templates):</strong> VueJS는 Vue 인스턴스 데이터와 DOM에 접근할 수 있는 HTML 기반의 템플릿을 제공합니다.</li>
<li><strong>라우팅(Routing):</strong> 페이지의 전환은 vue-router를 이용합니다.</li>
<li><strong>저용량(Light weight):</strong> VueJS는 다른 프레임워크와 비교해 저용량입니다.</li>
</ol>
</li>
<li>
<h3 id="vuejs의-라이프사이클lifecycle-함수는" style="position:relative;"><a href="#vuejs%EC%9D%98-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4lifecycle-%ED%95%A8%EC%88%98%EB%8A%94" aria-label="vuejs의 라이프사이클lifecycle 함수는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>VueJS의 라이프사이클(lifecycle) 함수는</h3>
<p>라이프사이클 훅(Lifecycle hook)은 사용중인 라이브러리가 어떤 순서로 동작하는지를 알려주는 역할을 합니다. 훅을 이용해 컴포넌트가 언제 생성되고, 언제 DOM에 추가되며, 언제 업데이트되고 언제 사라지는지 알 수 있습니다. 아래의 다이어그램을 통해 VueJS의 전반적인 라이프사이클을 확인할 수 있습니다.</p>
<p><img src="https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/vuelifecycle.png" alt="img"></p>
<ol>
<li><strong>Creation(초기화):</strong> Create 훅은 컴포넌트가 DOM에 추가되기 전에 실행되는 단계입니다. 클라이언트와 서버가 렌더링 단계 전에 컴포넌트에 설정해야 할 것들이 있을 때 사용하는 단계입니다. 다른 훅과는 다르게, Create 훅은 서버 사이드 렌더링에서도 지원되는 훅입니다.</li>
<li>beforeCreate: <code class="language-text">beforeCreate</code> 훅은 컴포넌트 초기화 단계 중 가장 처음으로 실행됩니다. 이 훅에서는 컴포넌트의 data를 관찰하고, 이벤트를 초기화합니다. 이 단계에서 data는 아직까지 반응적이지 않으며, 컴포넌트의 라이프사이클에서 발생하는 이벤트 역시 설정되지 않은 상태입니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">    new Vue({
      data: {
       count: 10
      },
      beforeCreate: function () {
        console.log(&#39;Nothing gets called at this moment&#39;)
        // `this` points to the view model instance
        console.log(&#39;count is &#39; + this.count);
      }
    })
       // count is undefined</code></pre></div>
<ol>
<li>created: <code class="language-text">created</code> 훅은 Vue 인스턴스가 이벤트를 설정하고 data를 관찰할 때 발생합니다. 이 단계에서 템플릿은 아직 마운트되거나 렌더링되지 않았지만, 이벤트들이 활성화되며 data에 반응적으로 접근하는 것이 가능합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  new Vue({
    data: {
     count: 10
    },
    created: function () {
      // `this` points to the view model instance
      console.log(&#39;count is: &#39; + this.count)
    }
  })
     // count is: 10</code></pre></div>
<p>  <strong>주의:</strong> Create 훅에서는 DOM에 직접 접근하거나 마운트할 엘리먼트(<code class="language-text">this.$el</code>)에 직접 접근할 수 없다는 점을 기억하세요.</p>
<ol start="2">
<li><strong>Mounting(DOM 추가):</strong> Mount 훅은 가장 많이 사용되는 단계로, 컴포넌트가 렌더링되기 직전이나 직후에 컴포넌트에 접근할 수 있는 단계입니다.</li>
<li>beforeMount: <code class="language-text">beforeMount</code> 훅은 컴포넌트가 DOM에 추가되기 직전에 실행되는 훅입니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  new Vue({
    beforeMount: function () {
      // `this` points to the view model instance
      console.log(`this.$el is yet to be created`);
    }
  })</code></pre></div>
<ol>
<li>mounted: <code class="language-text">mounted</code> 훅은 반응적인 data, 템플릿, 렌더링된 DOM(<code class="language-text">this.$el</code>) 모두에 접근할 수 있어서 가장 많이 사용되는 훅입니다. 흔히 컴포넌트에서 필요한 데이터를 외부에서 가져오는(fetch) 용도로 많이 사용됩니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;I’m text inside the component.&lt;/p&gt;
&lt;/div&gt;
  new Vue({
    el: &#39;#app&#39;,
    mounted: function() {
      console.log(this.$el.textContent); // I&#39;m text inside the component.
    }
  })</code></pre></div>
<ol start="3">
<li><strong>Updating (재 렌더링):</strong> Update 훅은 컴포넌트 내부의 반응적인 속성이 변했거나, 그 외의 것들이 재 렌더링을 일으킬 때 실행되는 단계입니다.</li>
<li>beforeUpdate: <code class="language-text">beforeUpdate</code> 훅은 컴포넌트의 data가 변경되어 업데이트 사이클이 시작될 때 실행됩니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;{{counter}}&lt;/p&gt;
&lt;/div&gt;
...// rest of the code
  new Vue({
    el: &#39;#app&#39;,
    data() {
      return {
        counter: 0
      }
    },
     created: function() {
      setInterval(() =&gt; {
        this.counter++
      }, 1000)
    },

    beforeUpdate: function() {
      console.log(this.counter) // Logs the counter value every second, before the DOM updates.
    }
  })</code></pre></div>
<ol>
<li>updated: <code class="language-text">updated</code> 훅은 컴포넌트의 data가 변하여 재 렌더링이 일어난 후에 실행됩니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
  &lt;p ref=&quot;dom&quot;&gt;{{counter}}&lt;/p&gt;
&lt;/div&gt;
...//
  new Vue({
    el: &#39;#app&#39;,
    data() {
      return {
        counter: 0
      }
    },
     created: function() {
      setInterval(() =&gt; {
        this.counter++
      }, 1000)
    },
    updated: function() {
      console.log(+this.$refs[&#39;dom&#39;].textContent === this.counter) // Logs true every second
    }
  })</code></pre></div>
<ol start="4">
<li><strong>Destruction(해체):</strong> Destruction 훅은 컴포넌트를 더 이상 사용하지 않을 때 사용하는 단계입니다.</li>
<li>beforeDestroy: <code class="language-text">beforeDestroy</code> 훅은 컴포넌트가 해체되기 직전에 실행됩니다. 이 훅은 반응적인 이벤트들이나 data들을 해체하는 훅으로 적합합니다. 이 단계에서 컴포넌트는 여전히 문제없이 잘 동작합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue ({
  data() {
    return {
      message: &#39;Welcome VueJS developers&#39;
    }
  },

  beforeDestroy: function() {
    this.message = null
    delete this.message
  }
})</code></pre></div>
<ol>
<li>destroyed: <code class="language-text">destroyed</code> 훅은 컴포넌트가 해체되고 난 직후에 호출됩니다. 모든 지시자들의 바인딩이 해제되었으며, 이벤트 리스너가 제거된 상태입니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue ({
    destroyed: function() {
      console.log(this) // Nothing to show here
    }
  })</code></pre></div>
</li>
<li>
<h3 id="조건부-지시자conditional-directives란" style="position:relative;"><a href="#%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%A7%80%EC%8B%9C%EC%9E%90conditional-directives%EB%9E%80" aria-label="조건부 지시자conditional directives란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>조건부 지시자(conditional directives)란</h3>
<p>VueJS는 조건에 따라 엘리먼트를 보여주거나 숨길 수 있는 지시자들을 제공합니다. 사용할 수 있는 지시자들은 <strong>v-if, v-else, v-else-if and v-show</strong>가 있습니다.</p>
<p><strong>1. v-if:</strong> v-if 지시자는 조건에 따라 DOM 엘리먼트를 추가하거나 제거합니다. 예를 들어, 아래의 버튼은 <code class="language-text">isLoggedIn</code>의 값이 <code class="language-text">false</code>라면 나타나지 않습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;button v-if=&quot;isLoggedIn&quot;&gt;Logout&lt;/button&gt;</code></pre></div>
<p>엘리먼트들을 <code class="language-text">&lt;template&gt;</code> 태그로 감싼다면, 하나의 v-if만으로 여러 엘리먼트들의 조건을 설정할 수 있습니다. 예를 들어, 아래와 같이 <code class="language-text">label</code>과 <code class="language-text">button</code> 태그를 하나의 조건 지시자로 제어할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template v-if=&quot;isLoggedIn&quot;&gt;
 &lt;label&gt; Logout &lt;/button&gt;
 &lt;button&gt; Logout &lt;/button&gt;
&lt;/template&gt;</code></pre></div>
<p><strong>2. v-else:</strong> 프로그래밍 언어에서 <code class="language-text">if</code>의 조건에 맞지 않는 경우 <code class="language-text">else</code>로 넘어가는 것처럼, v-else 지시자는 인접한 v-if 지시자 또는 v-else-if 지시자가 <code class="language-text">false</code>일 때만 그 내용이 나타납니다. 이 지시자에는 조건을 지정할 필요가 없습니다. 예를 들어, 아래의 예시는 <code class="language-text">isLoggedIn</code>이 <code class="language-text">false</code>일 때(즉 로그인 된 상태가 아닐 때), v-else를 이용해 로그인 버튼을 보여줍니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;button v-if=&quot;isLoggedIn&quot;&gt; Logout &lt;/button&gt;
&lt;button v-else&gt; Log In &lt;/button&gt;</code></pre></div>
<p><strong>3. v-else-if:</strong> v-else-if 지시자는 v-if 이외의 다른 조건을 추가로 확인해야 할 때 사용합니다. 예를 들어, v-else-if 지시자를 이용해 <code class="language-text">ifLoginDisabled</code>의 값이 <code class="language-text">true</code>일 때는 로그인 버튼 대신 텍스트를 보여줄 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;button v-if=&quot;isLoggedIn&quot;&gt; Logout &lt;/button&gt;
&lt;label v-else-if=&quot;isLoginDisabled&quot;&gt; User login disabled &lt;/label&gt;
&lt;button v-else&gt; Log In &lt;/button&gt;</code></pre></div>
<p><strong>4. v-show:</strong> v-show 지시자는 v-if 지시자와 비슷한 기능을 하지만, DOM에 엘리먼트가 추가된 상태에서 CSS의 display 값을 이용해 보여주고 숨김을 결정합니다. v-show 지시자는 조건문이 자주 토글될 때 권장됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;span v-show=&quot;user.name&quot;&gt;Welcome user,{{user.name}}&lt;/span&gt;</code></pre></div>
</li>
<li>
<h3 id="v-show와-v-if의-차이점은" style="position:relative;"><a href="#v-show%EC%99%80-v-if%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80" aria-label="v show와 v if의 차이점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-show와 v-if의 차이점은</h3>
<p><strong>v-show</strong>와 <strong>v-if</strong>의 주요 차이점은 다음과 같습니다.</p>
<ol>
<li>v-if는 조건이 일치하는 엘리먼트만 DOM에 렌더링하는 반면, v-show는 모든 엘리먼트를 DOM에 렌더링한 후 CSS를 이용해 내용을 보여주거나 숨깁니다.</li>
<li>v-if와 v-else-if에서는 v-else를 사용할 수 있지만, v-show에서는 사용할 수 없습니다.</li>
<li>v-if는 토글할 때 높은 렌더링 비용이 들지만, v-show는 초기의 렌더링 작업에서 높은 비용이 듭니다. 즉, v-show는 요소를 자주 켜고 끄는 경우 성능 상의 이점이 있지만, 초기 렌더링 작업에서는 v-if가 더 효율적입니다.</li>
<li>v-if는 <code class="language-text">&lt;template&gt;</code>태그에서 사용할 수 있지만 v-show는 사용할 수 없습니다.</li>
</ol>
</li>
<li>
<h3 id="v-for를-쓰는-목적은" style="position:relative;"><a href="#v-for%EB%A5%BC-%EC%93%B0%EB%8A%94-%EB%AA%A9%EC%A0%81%EC%9D%80" aria-label="v for를 쓰는 목적은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-for를 쓰는 목적은</h3>
<p>v-for 지시자는 배열이나 객체를 순환하면서 반복적인 렌더링을 가능하게 합니다.</p>
<ol>
<li>배열의 경우:</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul id=&quot;list&quot;&gt;
 &lt;li v-for=&quot;(item, index) in items&quot;&gt;
   {{ index }} - {{ item.message }}
 &lt;/li&gt;
&lt;/ul&gt;

var vm = new Vue({
 el: &#39;#list&#39;,
 data: {
   items: [
     { message: &#39;John&#39; },
     { message: &#39;Locke&#39; }
   ]
 }
})</code></pre></div>
<p>자바스크립트 순환문과 유사하게, <code class="language-text">in</code> 외에도 <code class="language-text">of</code>를 사용할 수 있습니다.</p>
<ol>
<li>객체의 경우:</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;object&quot;&gt;
 &lt;div v-for=&quot;(value, key, index) in user&quot;&gt;
   {{ index }}. {{ key }}: {{ value }}
 &lt;/div&gt;
&lt;/div&gt;

var vm = new Vue({
 el: &#39;#object&#39;,
 data: {
   user: {
     firstName: &#39;John&#39;,
     lastName: &#39;Locke&#39;,
     age: 30
   }
 }
})</code></pre></div>
</li>
<li>
<h3 id="vue-인스턴스란" style="position:relative;"><a href="#vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EB%9E%80" aria-label="vue 인스턴스란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue 인스턴스란</h3>
<p>모든 Vue 어플리케이션은 Vue 함수를 이용해 Vue 인스턴스를 생성하면서 동작합니다. 일반적으로 <code class="language-text">vm</code>(ViewModel의 축약형)이라는 변수를 이용해 Vue 인스턴스를 참조합니다. 아래와 같은 방법으로 Vue 인스턴스를 생성할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var vm = new Vue({
 // options
})</code></pre></div>
<p>위의 코드에서 볼 수 있듯, 옵션을 설정하기 위한 객체를 전달해야 합니다. 이 옵션은 API 문서에서 자세히 확인할 수 있습니다.</p>
</li>
<li>
<h3 id="여러-엘리먼트들을-한-번에-조건부로-나타내는-방법은" style="position:relative;"><a href="#%EC%97%AC%EB%9F%AC-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EB%93%A4%EC%9D%84-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%A1%B0%EA%B1%B4%EB%B6%80%EB%A1%9C-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="여러 엘리먼트들을 한 번에 조건부로 나타내는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>여러 엘리먼트들을 한 번에 조건부로 나타내는 방법은</h3>
<p>렌더링에 영향을 미치지 않는 <code class="language-text">&lt;template&gt;</code> 태그에 <strong>v-if</strong> 지시자를 적용함으로써 여러 엘리먼트들을 한 번에 조건부로 나타낼 수 있습니다. 예를 들어, 아래와 같이 유효한 사용자인 경우에 한해서 사용자 정보를 보여줄 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template v-if=&quot;condition&quot;&gt;
 &lt;h1&gt;Name&lt;/h1&gt;
 &lt;p&gt;Address&lt;/p&gt;
 &lt;p&gt;Contact Details&lt;/p&gt;
&lt;/template&gt;</code></pre></div>
</li>
<li>
<h3 id="key-속성을-이용해-엘리먼트를-재사용하는-방법은" style="position:relative;"><a href="#key-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="key 속성을 이용해 엘리먼트를 재사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>key 속성을 이용해 엘리먼트를 재사용하는 방법은</h3>
<p>Vue는 가능한 한 엘리먼트를 효율적으로 렌더링하려 합니다. 그래서 엘리먼트를 처음부터 다시 만들기보다는 재사용하려 합니다. 그러나 이는 몇 가지 상황에서 문제를 일으킬 수 있습니다. 예를 들어, <code class="language-text">input</code> 엘리먼트를 <code class="language-text">v-if</code>와 <code class="language-text">v-else</code> 블록 양쪽에서 사용하면, <code class="language-text">input</code> 엘리먼트는 조건문에 따라 바뀌지 않고 최초에 렌더링 된 엘리먼트의 상태를 유지하고 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template v-if=&quot;loginType === &#39;Admin&#39;&quot;&gt;
 &lt;label&gt;Admin&lt;/label&gt;
 &lt;input placeholder=&quot;Enter your ID&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
 &lt;label&gt;Guest&lt;/label&gt;
 &lt;input placeholder=&quot;Enter your name&quot;&gt;
&lt;/template&gt;</code></pre></div>
<p>이 경우에서 <code class="language-text">input</code> 엘리먼트는 재사용되어서는 안 되기 때문에, <strong>key</strong> 속성을 이용해 두 개의 <code class="language-text">input</code> 엘리먼트를 별개의 것으로 취급하도록 선언할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">   &lt;template v-if=&quot;loginType === &#39;Admin&#39;&quot;&gt;
     &lt;label&gt;Admin&lt;/label&gt;
     &lt;input placeholder=&quot;Enter your ID&quot; key=&quot;admin-id&quot;&gt;
   &lt;/template&gt;
   &lt;template v-else&gt;
     &lt;label&gt;Guest&lt;/label&gt;
     &lt;input placeholder=&quot;Enter your name&quot; key=&quot;user-name&quot;&gt;
   &lt;/template&gt;</code></pre></div>
<p>위의 경우는 두 개의 <code class="language-text">input</code> 엘리먼트가 별개의 것으로 취급되며 서로에게 어떤 영향도 끼치지 않습니다.</p>
</li>
<li>
<h3 id="같은-엘리먼트에서-v-for와-v-if를-함께-쓰면-안-되는-이유는" style="position:relative;"><a href="#%EA%B0%99%EC%9D%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%97%90%EC%84%9C-v-for%EC%99%80-v-if%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B0%EB%A9%B4-%EC%95%88-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94" aria-label="같은 엘리먼트에서 v for와 v if를 함께 쓰면 안 되는 이유는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>같은 엘리먼트에서 v-for와 v-if를 함께 쓰면 안 되는 이유는</h3>
<p>v-for 지시자는 v-if 보다 더 높은 우선 순위를 갖고 있기 때문에, 한 엘리먼트 내에서 v-for와 v-if를 함께 쓰는 것은 권장되지 않습니다. 일반적으로 다음과 같은 이유 때문에 두 지시자를 함께 쓰곤 합니다.</p>
<ol>
<li>리스트의 요소를 필터링하기 위해 예를 들어, v-if 지시자를 이용해 리스트에 있는 아이템을 필터링하고 싶은 경우입니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;user.isActive&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;li&gt;
&lt;/ul&gt;</code></pre></div>
<p>이 경우는 아래와 같이 사전에 computed 속성을 이용해 필터링된 리스트를 만들어 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
      return user.isActive
    })
  }
}
...... //
...... //
&lt;ul&gt;
  &lt;li
    v-for=&quot;user in activeUsers&quot;
    :key=&quot;user.id&quot;&gt;
    {{ user.name }}
  &lt;li&gt;
&lt;/ul&gt;</code></pre></div>
<ol>
<li>리스트 자체가 숨겨져야 할 때 예를 들어, v-if를 이용해 반복되는 리스트를 숨기고 싶은 경우입니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;shouldShowUsers&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;li&gt;
&lt;/ul&gt;</code></pre></div>
<p>이 경우는 아래와 같이 조건문을 상위 엘리먼트로 옮김으로써 해결할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;li&gt;
&lt;/ul&gt;</code></pre></div>
</li>
<li>
<h3 id="v-for에서-key-속성이-필요한-이유" style="position:relative;"><a href="#v-for%EC%97%90%EC%84%9C-key-%EC%86%8D%EC%84%B1%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0" aria-label="v for에서 key 속성이 필요한 이유 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-for에서 key 속성이 필요한 이유</h3>
<p>Vue에서 개별 DOM 노드들을 추적하고 기존 엘리먼트의 재사용/재정렬을 위해, v-for의 요소에 고유한 key 속성을 제공해야 합니다. key에 대한 이상적인 값은 각 항목을 식별할 수 있는 고유한 ID입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  {{item.name}}
&lt;/div&gt;</code></pre></div>
<p>반복되는 DOM 내용이 단순한 경우나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는 경우를 제외하면, 가능하면 언제나 v-for에 key를 추가하는 것이 좋습니다. <strong>Note:</strong> 객체나 배열처럼, 기본 타입(Primitive value)이 아닌 값을 키로 사용해서는 안됩니다. 문자열이나 숫자를 사용하세요.</p>
</li>
<li>
<h3 id="배열을-변화시키는-함수mutation-method란" style="position:relative;"><a href="#%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%B3%80%ED%99%94%EC%8B%9C%ED%82%A4%EB%8A%94-%ED%95%A8%EC%88%98mutation-method%EB%9E%80" aria-label="배열을 변화시키는 함수mutation method란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>배열을 변화시키는 함수(Mutation method)란</h3>
<p>이름에서 볼 수 있듯, 배열을 변화시키는 함수(mutation methods)는 원본 배열을 변경시킵니다. 아래의 함수는 뷰(view) 업데이트를 일으킵니다.</p>
<ol>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ol>
<p>예를 들어, 아래와 같이 <code class="language-text">todos</code> 배열에 <code class="language-text">push</code> 함수를 실행시키면 뷰 업데이트가 일어납니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.todos.push({ message: &#39;Baz&#39; })</code></pre></div>
</li>
<li>
<h3 id="배열을-대체하는-함수non-mutation-method란" style="position:relative;"><a href="#%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%8C%80%EC%B2%B4%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98non-mutation-method%EB%9E%80" aria-label="배열을 대체하는 함수non mutation method란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>배열을 대체하는 함수(Non-mutation method)란</h3>
<p>배열을 대체하는 함수는 원본 배열을 수정하지 않고, 항상 새로운 배열을 반환합니다. 아래의 함수는 배열을 대체하는 함수입니다.</p>
<ol>
<li>filter()</li>
<li>concat()</li>
<li>slice()</li>
</ol>
<p>예를 들어, 아래와 같이 <code class="language-text">status</code> 속성에 따라 <code class="language-text">todos</code> 배열을 필터링한 새로운 배열을 반환받을 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.todos = vm.todos.filter(function (todo) {
  return todo.status.match(/Completed/)
})</code></pre></div>
<p>Vue가 DOM을 효율적으로 재사용하기 때문에, 전체 리스트가 새로 렌더링되지는 않습니다.</p>
</li>
<li>
<h3 id="배열-변경을-탐지할-때-주의할-점" style="position:relative;"><a href="#%EB%B0%B0%EC%97%B4-%EB%B3%80%EA%B2%BD%EC%9D%84-%ED%83%90%EC%A7%80%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90" aria-label="배열 변경을 탐지할 때 주의할 점 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>배열 변경을 탐지할 때 주의할 점</h3>
<p>Vue는 아래의 두 가지 경우의 변경 사항을 감지할 수 없습니다.</p>
<ol>
<li>인덱스로 배열에 있는 항목을 직접 할당하는 경우</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.todos[indexOfTodo] = newTodo</code></pre></div>
<ol>
<li>배열의 길이를 수정하는 경우</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.todos.length = todosLength</code></pre></div>
<p>이는 <code class="language-text">set</code>과 <code class="language-text">splice</code> 함수를 이용해 해결할 수 있습니다.</p>
<p><strong>첫 번째 경우</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Vue.set
Vue.set(vm.todos, indexOfTodo, newTodoValue)</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Array.prototype.splice
vm.todos.splice(indexOfTodo, 1, newTodoValue)</code></pre></div>
<p><strong>두 번째 경우</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.todos.splice(todosLength)</code></pre></div>
</li>
<li>
<h3 id="객체-변경을-탐지할-때-주의할-점" style="position:relative;"><a href="#%EA%B0%9D%EC%B2%B4-%EB%B3%80%EA%B2%BD%EC%9D%84-%ED%83%90%EC%A7%80%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90" aria-label="객체 변경을 탐지할 때 주의할 점 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 변경을 탐지할 때 주의할 점</h3>
<p>Vue는 추가되거나 삭제된 속성에 반응형으로 접근할 수 없습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var vm = new Vue({
  data: {
    user: {
      name: &#39;John&#39;
    }
  }
})

// `vm.name` is now reactive

vm.email = john@email.com // `vm.email` is NOT reactive</code></pre></div>
<p>이 경우는 <code class="language-text">Vue.set(object, key, value)</code>나 <code class="language-text">Object.assign()</code>를 이용함으로써 반응형 속성을 추가할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.set(vm.user, &#39;email&#39;, john@email.com);</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">vm.user = Object.assign({}, vm.user, {
  email: john@email.com
})</code></pre></div>
</li>
<li>
<h3 id="v-for를-특정-횟수만큼-반복하는-방법은" style="position:relative;"><a href="#v-for%EB%A5%BC-%ED%8A%B9%EC%A0%95-%ED%9A%9F%EC%88%98%EB%A7%8C%ED%81%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="v for를 특정 횟수만큼 반복하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-for를 특정 횟수만큼 반복하는 방법은?</h3>
<p><code class="language-text">v-for</code> 지시자에 정수를 사용해 특정 횟수만큼 반복해 렌더링 할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div&gt;
  &lt;span v-for=&quot;n in 20&quot;&gt;{{ n }} &lt;/span&gt;
&lt;/div&gt;</code></pre></div>
<p>이 경우 1부터 20까지 숫자가 출력됩니다.</p>
</li>
<li>
<h3 id="v-for로-템플릿을-반복하는-방법은" style="position:relative;"><a href="#v-for%EB%A1%9C-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9D%84-%EB%B0%98%EB%B3%B5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="v for로 템플릿을 반복하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-for로 템플릿을 반복하는 방법은</h3>
<p><code class="language-text">&lt;template&gt;</code>에서 v-if를 사용한 것과 유사하게, <code class="language-text">&lt;template&gt;</code>에서 v-for 문법을 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul&gt;
  &lt;template v-for=&quot;todo in todos&quot;&gt;
    &lt;li&gt;{{ todo.title }}&lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;</code></pre></div>
</li>
<li>
<h3 id="이벤트-핸들러를-사용하는-방법은" style="position:relative;"><a href="#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="이벤트 핸들러를 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이벤트 핸들러를 사용하는 방법은?</h3>
<p>VueJS에서는 순수 자바스크립트와 유사하게 이벤트 핸들러를 사용할 수 있습니다. 함수에서 <code class="language-text">$event</code> 변수를 호출해 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;button v-on:click=&quot;show(&#39;Welcome to VueJS world&#39;, $event)&quot;&gt;
  Submit
&lt;/button&gt;

methods: {
  show: function (message, event) {
    // now we have access to the native event
    if (event) event.preventDefault()
    console.log(message);
  }
}</code></pre></div>
</li>
<li>
<h3 id="vue에서-이벤트-수식어event-modifier란" style="position:relative;"><a href="#vue%EC%97%90%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%88%98%EC%8B%9D%EC%96%B4event-modifier%EB%9E%80" aria-label="vue에서 이벤트 수식어event modifier란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue에서 이벤트 수식어(Event modifier)란?</h3>
<p>일반적으로 자바스크립트에서는 이벤트 핸들러 내부에서 <code class="language-text">event.preventDefault()</code> 또는 <code class="language-text">event.stopPropagation()</code>를 제공합니다. Vue의 메소드 내부에서도 이 작업을 할 수 있지만, DOM에서 발생한 이벤트와 메소드의 로직은 별개로 구분하는 것이 좋습니다.</p>
<p>이 문제를 해결하기 위해, Vue는 <code class="language-text">v-on</code> 이벤트에 이벤트 수식어를 제공합니다. 수식어는 점으로 표시된 접미사 입니다.</p>
<ol>
<li><code class="language-text">.stop</code></li>
<li><code class="language-text">.prevent</code></li>
<li><code class="language-text">.capture</code></li>
<li><code class="language-text">.self</code></li>
<li><code class="language-text">.once</code></li>
<li><code class="language-text">.passive</code></li>
</ol>
<p><code class="language-text">.stop</code> 수식어를 예로 들어보겠습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- the click event&#39;s propagation will be stopped --&gt;
&lt;a v-on:click.stop=&quot;methodCall&quot;&gt;&lt;/a&gt;</code></pre></div>
<p>수식어는 연속해서 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- modifiers can be chained --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</code></pre></div>
</li>
<li>
<h3 id="키-수식어key-modifiers란" style="position:relative;"><a href="#%ED%82%A4-%EC%88%98%EC%8B%9D%EC%96%B4key-modifiers%EB%9E%80" aria-label="키 수식어key modifiers란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>키 수식어(Key modifiers)란?</h3>
<p>Vue는 키보드 이벤트를 제어하기 위해 <code class="language-text">v-on</code> 지시자에 키 수식어를 제공합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- only call `vm.show()` when the `keyCode` is 13 --&gt;
&lt;input v-on:keyup.13=&quot;show&quot;&gt;</code></pre></div>
<p>모든 키 코드를 외우는 것은 어렵기 때문에, Vue에서는 자주 사용되는 키들은 별칭을 제공하고 있습니다.</p>
<ol>
<li><code class="language-text">.enter</code></li>
<li><code class="language-text">.tab</code></li>
<li><code class="language-text">.delete</code> (“Delete”와 “Backspace” 포함)</li>
<li><code class="language-text">.esc</code></li>
<li><code class="language-text">.space</code></li>
<li><code class="language-text">.up</code></li>
<li><code class="language-text">.down</code></li>
<li><code class="language-text">.left</code></li>
<li><code class="language-text">.right</code></li>
</ol>
<p>위 예시의 키 코드는 아래와 같이 별칭으로 다시 쓸 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
// (OR)
&lt;!-- with shorthand notation--&gt;
&lt;input @keyup.enter=&quot;submit&quot;&gt;</code></pre></div>
<p><strong>키 코드 이벤트의 사용은 최신 브라우저에서는 지원되지 않을 수 있습니다.</strong></p>
</li>
<li>
<h3 id="키-수식어를-커스터마이징하는-방법은" style="position:relative;"><a href="#%ED%82%A4-%EC%88%98%EC%8B%9D%EC%96%B4%EB%A5%BC-%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="키 수식어를 커스터마이징하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>키 수식어를 커스터마이징하는 방법은?</h3>
<p>전역 <code class="language-text">config.keyCodes</code> 객체를 통해 키 수식어를 커스터마이징할 수 있습니다. 여기에는 몇 가지 규칙들이 있습니다.</p>
<ol>
<li>카멜 케이스(camelCase)를 대신 쌍따옴표로 감싸진 케밥 케이스(Kebab-case)를 사용해야 합니다.</li>
<li>배열을 이용해 한 번에 여러 값들을 정의할 수 있습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.config.keyCodes = {
  f1: 112,
  &quot;media-play-pause&quot;: 179,
  down: [40, 87]
}</code></pre></div>
</li>
<li>
<h3 id="시스템-수식어-키system-modifier-key란" style="position:relative;"><a href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%88%98%EC%8B%9D%EC%96%B4-%ED%82%A4system-modifier-key%EB%9E%80" aria-label="시스템 수식어 키system modifier key란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>시스템 수식어 키(System modifier key)란?</h3>
<p>Vue에서는 다음 수식어를 사용해 해당 수식어 키가 눌러진 경우에만 마우스 또는 키보드 이벤트를 발생시킬 수 있습니다.</p>
<ol>
<li><code class="language-text">.ctrl</code></li>
<li><code class="language-text">.alt</code></li>
<li><code class="language-text">.shift</code></li>
<li><code class="language-text">.meta</code></li>
</ol>
<p>아래는 컨트롤 키가 눌린 상태에서 클릭 이벤트를 활성화 하는 예시입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- Ctrl + Click --&gt;
&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</code></pre></div>
</li>
<li>
<h3 id="마우스-버튼-수식어mouse-button-modifier란" style="position:relative;"><a href="#%EB%A7%88%EC%9A%B0%EC%8A%A4-%EB%B2%84%ED%8A%BC-%EC%88%98%EC%8B%9D%EC%96%B4mouse-button-modifier%EB%9E%80" aria-label="마우스 버튼 수식어mouse button modifier란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>마우스 버튼 수식어(Mouse button modifier)란?</h3>
<p>Vue는 특정한 마우스 버튼으로 발생한 이벤트를 제어할 수 있습니다.</p>
<ol>
<li><code class="language-text">.left</code></li>
<li><code class="language-text">.right</code></li>
<li><code class="language-text">.middle</code></li>
</ol>
<p>마우스 이벤트로 <code class="language-text">.right</code>를 이용한 예시입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> &lt;button
   v-if=&quot;button === &#39;right&#39;&quot;
   v-on:mousedown.right=&quot;increment&quot;
   v-on:mousedown.left=&quot;decrement&quot;
 /&gt;</code></pre></div>
</li>
<li>
<h3 id="v-model의-역할은" style="position:relative;"><a href="#v-model%EC%9D%98-%EC%97%AD%ED%95%A0%EC%9D%80" aria-label="v model의 역할은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-model의 역할은?</h3>
<p><code class="language-text">v-model</code> 지시자를 이용해 <code class="language-text">input</code>, <code class="language-text">textarea</code>, <code class="language-text">select</code> 엘리먼트의 데이터를 양방향으로 제어할 수 있습니다. 아래의 <code class="language-text">input</code> 엘리먼트를 살펴보세요.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-model=&quot;message&quot; placeholder=&quot;Enter input here&quot;&gt;
&lt;p&gt;The message is: {{ message }}&lt;/p&gt;</code></pre></div>
<p><code class="language-text">v-model</code>은 모든 <code class="language-text">form</code> 엘리먼트에서 HTML 속성(attribute)으로 선언된 <code class="language-text">value</code>, <code class="language-text">checked</code> 그리고 <code class="language-text">selected</code>를 무시합니다. 그 대신 Vue 인스턴스에서 <code class="language-text">v-model</code>로 바인딩한 값을 이용합니다. 따라서 컴포넌트의 data에서 초기값을 선언해야 합니다.</p>
</li>
<li>
<h3 id="v-model에서-지원되는-수식어는" style="position:relative;"><a href="#v-model%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90%EB%90%98%EB%8A%94-%EC%88%98%EC%8B%9D%EC%96%B4%EB%8A%94" aria-label="v model에서 지원되는 수식어는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>v-model에서 지원되는 수식어는?</h3>
<p><code class="language-text">v-model</code> 지시자에는 세 가지 수식어가 지원됩니다.</p>
<p><strong>1. lazy:</strong> 기본적으로, <code class="language-text">v-model</code>은 하나의 키 입력 이벤트가 발생할 때마다 data가 업데이트됩니다. 이를 방지하기 위해서는 <code class="language-text">.lazy</code> 수식어를 이용합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- synced after &quot;change&quot; instead of &quot;input&quot; --&gt;
&lt;input v-model.lazy=&quot;msg&quot; &gt;</code></pre></div>
<p><strong>2. number:</strong> <code class="language-text">v-model</code>에 <code class="language-text">.number</code> 수식어를 붙이면 자동적으로 사용자의 입력의 자료형이 <code class="language-text">Number</code>로 변환됩니다. HTML <code class="language-text">input</code> 태그의 속성이 <code class="language-text">type=&quot;number&quot;</code>일지라도 반환되는 값의 자료형은 문자열이기 때문에, 숫자 자료형이 필요하다면 <code class="language-text">.number</code> 수식어를 사용해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre></div>
<p><strong>3. trim:</strong> <code class="language-text">.trim</code> 수식어를 사용자 입력에서 처음과 끝에 들어있는 공백을 자동으로 제거해줍니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre></div>
</li>
<li>
<h3 id="컴포넌트component란" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8component%EB%9E%80" aria-label="컴포넌트component란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트(Component)란?</h3>
<p>컴포넌트란 <strong>재사용 가능하면서 이름이 명명된 Vue 인스턴스</strong>입니다. 컴포넌트는 Vue처럼 data, computed, watch, methods, 라이프사이클 옵션을 갖고 있습니다. 아래는 Vue에 전역으로 컴포넌트를 추가하는 예시입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Define a new component called button-counter
Vue.component(&#39;button-counter&#39;, {
  template: &#39;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;&#39;
  data: function () {
    return {
      count: 0
    }
  },
})</code></pre></div>
<p>이 컴포넌트는 전역으로 선언되었기 때문에 Vue 인스턴스에서 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
  &lt;button-counter&gt;&lt;/button-counter&gt;
&lt;/div&gt;

var vm = new Vue({ el: &#39;#app&#39; });</code></pre></div>
</li>
<li>
<h3 id="props란" style="position:relative;"><a href="#props%EB%9E%80" aria-label="props란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>props란?</h3>
<p>props는 상위 컴포넌트의 정보를 하위 컴포넌트로 전달할 수 있는 사용자 지정의 속성입니다. 상위 컴포넌트에서 전달되는 props는 하위 컴포넌트의 속성으로 여겨지며, 하위 컴포넌트에서는 props 옵션을 사용하여 수신할 것으로 예상되는 props를 명시적으로 선언해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;todo-item&#39;, {
  props: [&#39;title&#39;],
  template: &#39;&lt;h2&gt;{{ title }}&lt;/h2&gt;&#39;
})</code></pre></div>
<p>하위 컴포넌트에서 props가 등록되고 나면, 상위 컴포넌트에서는 사용자 지정 속성을 이용해 값을 전달할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;todo-item title=&quot;Learn Vue conceptsnfirst&quot;&gt;&lt;/todo-item&gt;</code></pre></div>
</li>
<li>
<h3 id="컴포넌트에서-여러-엘리먼트를-쓰려면" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%93%B0%EB%A0%A4%EB%A9%B4" aria-label="컴포넌트에서 여러 엘리먼트를 쓰려면 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트에서 여러 엘리먼트를 쓰려면?</h3>
<p>템플릿이 여러 개의 엘리먼트들로 구성되어 있을 때, <strong>컴포넌트의 최상단 템플릿은 반드시 단일 엘리먼트로 감싸져 있어야 합니다.</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div class=&quot;todo-item&quot;&gt;
  &lt;h2&gt;{{ title }}&lt;/h2&gt;
  &lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre></div>
<p>그렇지 않다면, <code class="language-text">&quot;Component template should contain exactly one root element...&quot;</code>라는 에러를 발생시킵니다.</p>
</li>
<li>
<h3 id="하위-컴포넌트에서-상위-컴포넌트로-이벤트를-전달하는-방법은" style="position:relative;"><a href="#%ED%95%98%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%83%81%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="하위 컴포넌트에서 상위 컴포넌트로 이벤트를 전달하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>하위 컴포넌트에서 상위 컴포넌트로 이벤트를 전달하는 방법은?</h3>
<p>하위 컴포넌트에서 <code class="language-text">$event</code> 객체를 이용해 상위 컴포넌트로 이벤트를 발생킬 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;todo-tem&#39;, {
  props: [&#39;todo&#39;],
  template: `
    &lt;div class=&quot;todo-item&quot;&gt;
      &lt;h3&gt;{{ todo.title }}&lt;/h3&gt;
      &lt;button v-on:click=&quot;$emit(&#39;increment-count&#39;, 1)&quot;&gt;
        Add
      &lt;/button&gt;
      &lt;div v-html=&quot;todo.description&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
})</code></pre></div>
<p>이 때 상위 컴포넌트에서는 <code class="language-text">v-on</code> 지시자를 이용해 하위 컴포넌트에서 명명한 이벤트와 값을 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;ul v-for=&quot;todo in todos&quot;&gt;
 &lt;li&gt;
   &lt;todo-item
     v-bind:key=&quot;todo.id&quot;
     v-bind:todo=&quot;todo&quot;
     v-on:increment-count=&quot;total += 1&quot;&gt;
   &lt;/todo-item&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt; Total todos count is {{total}}&lt;/span&gt;</code></pre></div>
</li>
<li>
<h3 id="사용자-정의의-input-컴포넌트에서-v-model을-사용하는-법은" style="position:relative;"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98%EC%9D%98-input-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-v-model%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B2%95%EC%9D%80" aria-label="사용자 정의의 input 컴포넌트에서 v model을 사용하는 법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자 정의의 input 컴포넌트에서 v-model을 사용하는 법은?</h3>
<p>사용자 정의 input 컴포넌트에서도 <code class="language-text">v-model</code>을 활용할 수 있습니다. 해당 컴포넌트의 <code class="language-text">input</code>은 아래 규칙들을 준수해야 합니다.</p>
<ol>
<li><code class="language-text">input</code>의 <code class="language-text">value</code>를 props를 이용해 바인딩합니다.</li>
<li>새로운 값이 입력되는 <code class="language-text">input</code> 이벤트 발생 시, 해당 값을 <code class="language-text">emit</code>하여 상위 컴포넌트로 이벤트를 전달합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;custom-input&#39;, {
  props: [&#39;value&#39;],
  template: `
    &lt;input
      v-bind:value=&quot;value&quot;
      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;
    &gt;
  `
})</code></pre></div>
<p>이 경우 상위 컴포넌트에서 <code class="language-text">v-model</code>을 이용해 값을 바인딩할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;custom-input v-model=&quot;searchInput&quot;&gt;&lt;/custom-input&gt;</code></pre></div>
</li>
<li>
<h3 id="slots이란" style="position:relative;"><a href="#slots%EC%9D%B4%EB%9E%80" aria-label="slots이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>slots이란?</h3>
<p>Vue에서는 <code class="language-text">&lt;slot&gt;</code>을 이용해 상위 컴포넌트에서 하위 컴포넌트 내부에 사용자 정의의 컨텐츠를 집어 넣을 수 있습니다. 하위 컴포넌트에 <code class="language-text">&lt;slot&gt;</code>을 이용해 문구를 동적으로 넣을 수 있는 컴포넌트를 만들어봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;alert&#39;, {
  template: `
    &lt;div class=&quot;alert-box&quot;&gt;
      &lt;strong&gt;Error!&lt;/strong&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
  `
})</code></pre></div>
<p><code class="language-text">&lt;alert&gt;</code> 태그 안에 넣은 값은 컴포넌트 내부의 <code class="language-text">&lt;slot&gt;</code>의 컨텐츠로 들어가게 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;alert&gt;
  There is an issue with in application.
&lt;/alert&gt;</code></pre></div>
</li>
<li>
<h3 id="컴포넌트를-전역-등록하는-방법은" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%A0%84%EC%97%AD-%EB%93%B1%EB%A1%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="컴포넌트를 전역 등록하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트를 전역 등록하는 방법은?</h3>
<p>컴포넌트를 전역으로 등록하게 되면 모든 Vue 인스턴스에서 해당 컴포넌트를 사용할 수 있습니다. 컴포넌트는 <code class="language-text">Vue.component()</code> 함수를 이용해 전역 등록할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;my-component-name&#39;, {
  // ... options ...
})</code></pre></div>
<p>Vue 인스턴스에 여러 개의 컴포넌트를 전역 등록해봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;component-a&#39;, { /* ... */ })
Vue.component(&#39;component-b&#39;, { /* ... */ })
Vue.component(&#39;component-c&#39;, { /* ... */ })

new Vue({ el: &#39;#app&#39; })</code></pre></div>
<p>위의 컴포넌트들은 Vue 인스턴스 내에서 사용될 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
  &lt;component-a&gt;&lt;/component-a&gt;
  &lt;component-b&gt;&lt;/component-b&gt;
  &lt;component-c&gt;&lt;/component-c&gt;
&lt;/div&gt;</code></pre></div>
<p>전역으로 등록한 컴포넌트들은 하위 컴포넌트에서도 사용이 가능합니다.</p>
</li>
<li>
<h3 id="컴포넌트의-지역-등록이-필요한-이유는" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%A7%80%EC%97%AD-%EB%93%B1%EB%A1%9D%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0%EB%8A%94" aria-label="컴포넌트의 지역 등록이 필요한 이유는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트의 지역 등록이 필요한 이유는?</h3>
<p>전역 등록으로 인해 사용되지 않는 컴포넌트가 빌드 시에 여전히 남아있을 수 있습니다. 이는 불필요한 자바스크립트를 만들죠. 이를 방지하기 위해, 아래와 같이 컴포넌트를 지역 등록할 수 있습니다.</p>
<ol>
<li>우선 자바스크립트 객체로 컴포넌트를 정의합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }</code></pre></div>
<p>지역 등록한 컴포넌트는 다른 컴포넌트의 하위에서는 사용할 수 없습니다. 이 경우, <code class="language-text">components</code> 속성으로 컴포넌트를 추가해 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    &#39;component-a&#39;: ComponentA
  },
  // ...
}</code></pre></div>
<ol>
<li>Vue 인스턴스에서 <code class="language-text">components</code> 속성에 사용할 컴포넌트들을 정의할 수 있습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue({
  el: &#39;#app&#39;,
  components: {
    &#39;component-a&#39;: ComponentA,
    &#39;component-b&#39;: ComponentB
  }
})</code></pre></div>
</li>
<li>
<h3 id="모듈-시스템에서-전역-등록과-지역-등록의-차이점은" style="position:relative;"><a href="#%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C-%EC%A0%84%EC%97%AD-%EB%93%B1%EB%A1%9D%EA%B3%BC-%EC%A7%80%EC%97%AD-%EB%93%B1%EB%A1%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80" aria-label="모듈 시스템에서 전역 등록과 지역 등록의 차이점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>모듈 시스템에서 전역 등록과 지역 등록의 차이점은?</h3>
<p><strong>지역 등록</strong>의 경우, 각 컴포넌트를 디렉토리에 생성하고 각각의 컴포넌트는 다른 컴포넌트 안에서 <code class="language-text">import</code> 하여 사용하는 것이 권장됩니다. 만약 여러분들이 컴포넌트 C에서 컴포넌트 A와 B를 사용하고 싶다면 아래와 같은 설정을 해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import ComponentA from &#39;./ComponentA&#39;
import ComponentB from &#39;./ComponentC&#39;

export default {
  components: {
    ComponentA,
    ComponentB
  }
}</code></pre></div>
<p>위의 경우 컴포넌트 A와 컴포넌트 B는 컴포넌트 C의 템플릿에서 사용할 수 있습니다.</p>
<p><strong>전역 등록</strong>의 경우, 공통적으로 사용되는 컴포넌트를 각각의 파일에서 <code class="language-text">export</code>해야합니다. 하지만 <code class="language-text">webpack</code>과 같은 유명한 번들러들은 <code class="language-text">require.context</code>라는 문법을 이용해서 컴포넌트를 쉽게 전역적으로 등록할 수 있게 해줍니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import Vue from &#39;vue&#39;
import upperFirst from &#39;lodash/upperFirst&#39;
import camelCase from &#39;lodash/camelCase&#39;

const requireComponent = require.context(
  // The relative path of the components folder
  &#39;./components&#39;,
  // Whether or not to look in subfolders
  false,
  // The regular expression used to match base component filenames
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName =&gt; {
  // Get component config
  const componentConfig = requireComponent(fileName)

  // Get PascalCase name of component
  const componentName = upperFirst(
    camelCase(
      // Strip the leading `./` and extension from the filename
      fileName.replace(/^\.\/(.*)\.\w+$/, &#39;$1&#39;)
    )
  )

  // Register component globally
  Vue.component(
    componentName,
    // Look for the component options on `.default`, which will
    // exist if the component was exported with `export default`,
    // otherwise fall back to module&#39;s root.
    componentConfig.default || componentConfig
  )
})</code></pre></div>
</li>
<li>
<h3 id="prop-타입의-종류는" style="position:relative;"><a href="#prop-%ED%83%80%EC%9E%85%EC%9D%98-%EC%A2%85%EB%A5%98%EB%8A%94" aria-label="prop 타입의 종류는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prop 타입의 종류는?</h3>
<p><code class="language-text">props</code>에는 타입을 지정할 수도, 지정하지 않을 수도 있습니다. 하지만 일반적으로 타입을 지정하면 다른 개발자들이 해당 코드에서 잘못된 타입의 <code class="language-text">props</code>를 넘겨주는 실수를 줄여주기 때문에, 가능하면 타입을 지정해주는 것이 좋습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">props: {
  name: String,
  age: Number,
  isAuthenticated: Boolean,
  phoneNumbers: Array,
  address: Object
}</code></pre></div>
<p><code class="language-text">props</code> 객체의 속성과 값을 선언함으로서, 타입을 선언할 수 있습니다.</p>
</li>
<li>
<h3 id="props에-의한-데이터-흐름은" style="position:relative;"><a href="#props%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84%EC%9D%80" aria-label="props에 의한 데이터 흐름은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>props에 의한 데이터 흐름은?</h3>
<p>모든 <code class="language-text">props</code>는 하위 속성과 상위 속성 사이에서 단방향 바인딩을 형성합니다. 즉, 상위 속성이 변경되는 것은 하위 속성에게 전달되지만, 그 반대는 안됩니다. 원칙적으로, 하위 컴포넌트에서는 상위 컴포넌트에서 받은 <code class="language-text">props</code>을 수정해서는 안됩니다.</p>
<p>하위 컴포넌트에서 <code class="language-text">props</code> 수정의 필요성을 느낄 수 있는 몇 가지 경우가 있는데, 아래와 같은 방법으로 해결할 수 있습니다.</p>
<ol>
<li>상위 컴포넌트의 <code class="language-text">props</code>는 하위 컴포넌트의 초기값 설정에만 사용되고 그 이후에는 로컬 데이터 속성으로 활용되는 경우:</li>
</ol>
<p>이 경우, 하위 컴포넌트에서 사용할 속성을 <code class="language-text">data</code>에 선언하고, 그 값을 <code class="language-text">props</code>로 초기화하면 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">props: [&#39;defaultUser&#39;],
data: function () {
  return {
    username: this.defaultUser
  }
}</code></pre></div>
<ol>
<li>상위 컴포넌트에서 <code class="language-text">props</code>로 전해주는 값이 수정되는 경우</li>
</ol>
<p>이 경우, 하위 컴포넌트에서 <code class="language-text">computed</code> 속성을 이용해 <code class="language-text">props</code>의 값이 바뀔 때마다 신규 값을 얻을 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">props: [&#39;environment&#39;],
computed: {
  localEnvironment: function () {
    return this.environment.trim().toUpperCase()
  }
}</code></pre></div>
</li>
<li>
<h3 id="props가-아닌-속성은" style="position:relative;"><a href="#props%EA%B0%80-%EC%95%84%EB%8B%8C-%EC%86%8D%EC%84%B1%EC%9D%80" aria-label="props가 아닌 속성은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Props가 아닌 속성은?</h3>
<p><code class="language-text">props</code>가 아닌 속성이란, 컴포넌트에 전달되기는 하지만 해당 <code class="language-text">props</code>가 하위 컴포넌트에서 정의되지는 않은 속성을 말합니다. 만약 <code class="language-text">data-tooltip</code> 속성을 요구하는 컴포넌트를 사용하고 있다고 가정해봅시다. 이 속성을 컴포넌트 인스턴스에 다음과 같이 추가 할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;custom-input data-tooltip=&quot;Enter your input&quot; /&gt;</code></pre></div>
<p>상위 컴포넌트에서부터 <code class="language-text">props</code>가 아닌 속성을 넘겨주려 한다면, 하위 컴포넌트에서 같은 이름을 가진 속성은 덮어씌워집니다. 하지만 <code class="language-text">class</code>나 <code class="language-text">style</code>같은 <code class="language-text">props</code>는 예외로, 이 값들은 하위 컴포넌트와 합쳐집니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">//Parent component
&lt;custom-input class=&quot;custom-class&quot; /&gt;

//Child component
&lt;input type=&quot;date&quot; class=&quot;date-control&quot;&gt;</code></pre></div>
</li>
<li>
<h3 id="props를-검증하는-방법은" style="position:relative;"><a href="#props%EB%A5%BC-%EA%B2%80%EC%A6%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="props를 검증하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>props를 검증하는 방법은?</h3>
<p>Vue에서는 타입, 필수 여부, 디폴트 값 등 <code class="language-text">props</code>의 유효성 검증을 제공하고 있습니다. 아래와 같이 <code class="language-text">props</code>를 검증하는 규칙이 속성으로 담긴 객체를 제공하면 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;user-profile&#39;, {
  props: {
    // Basic type check (`null` matches any type)
    age: Number,
    // Multiple possible types
    identityNumber: [String, Number],
    // Required string
    email: {
      type: String,
      required: true
    },
    // Number with a default value
    minBalance: {
      type: Number,
      default: 10000
    },
    // Object with a default value
    message: {
      type: Object,
      // Object or array defaults must be returned from
      // a factory function
      default: function () {
        return { message: &#39;Welcome to Vue&#39; }
      }
    },
    // Custom validator function
    location: {
      validator: function (value) {
        // The value must match one of these strings
        return [&#39;India&#39;, &#39;Singapore&#39;, &#39;Australia&#39;].indexOf(value) !== -1
      }
    }
  }
})</code></pre></div>
</li>
<li>
<h3 id="컴포넌트에서-v-model을-사용자-정의하는-방법은" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-v-model%EC%9D%84-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="컴포넌트에서 v model을 사용자 정의하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트에서 v-model을 사용자 정의하는 방법은?</h3>
<p>일반적인 컴포넌트에서 <code class="language-text">v-model</code> 지시자는 <strong>value</strong>를 <code class="language-text">props</code>로 사용하고 <strong>input</strong>을 이벤트로 사용하지만, 체크 박스나 라디오 버튼같은 일부 입력 타입은 다른 목적으로 <code class="language-text">value</code> 속성을 사용할 수 있습니다. 이런 경우에는 <code class="language-text">v-model</code>을 커스터마이징해서 사용하는 것이 좋습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;custom-checkbox&#39;, {
  model: {
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;
    &gt;
  `
})</code></pre></div>
<p>이 컴포넌트에서 <code class="language-text">v-model</code>은 다음과 같이 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;custom-checkbox v-model=&quot;selectFramework&quot;&gt;&lt;/custom-checkbox&gt;</code></pre></div>
<p><code class="language-text">selectFramework</code> 속성은 <code class="language-text">props</code> 중 <code class="language-text">checked</code>로 넘어갈 것이고, 체크 박스 컴포넌트에서 값이 변경되면 이벤트를 발생시킬 것입니다.</p>
</li>
<li>
<h3 id="트랜지션-효과를-넣을-수-있는-방법은" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%A7%80%EC%85%98-%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EB%84%A3%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="트랜지션 효과를 넣을 수 있는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜지션 효과를 넣을 수 있는 방법은?</h3>
<p>Vue에서는 항목들이 DOM에서 추가, 갱신 또는 삭제될 때, 다양한 방법으로 트랜지션 효과를 입힐 수 있습니다.</p>
<ol>
<li>CSS 트랜지션과 애니메이션을 위한 클래스를 자동으로 적용</li>
<li>Animate.css와 같은 써드파티 CSS 애니메이션 라이브러리 통합</li>
<li>트랜지션 훅 중에 JavaScript를 사용하여 DOM을 직접 조작</li>
<li>Velocity.js와 같은 써드파티 JavaScript 애니메이션 라이브러리 통합</li>
</ol>
</li>
<li>
<h3 id="vue-router란" style="position:relative;"><a href="#vue-router%EB%9E%80" aria-label="vue router란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue Router란?</h3>
<p>Vue Router는 Vue에서 동작하는 공식적인 라우팅 라이브러리입니다.</p>
<ol>
<li>중첩된 라우트/뷰 매핑</li>
<li>모듈화된, 컴포넌트 기반의 라우터 설정</li>
<li>라우터 파라미터, 쿼리, 와일드카드</li>
<li>Vue의 트랜지션 시스템을 이용한 트랜지션 효과</li>
<li>세밀한 네비게이션 컨트롤</li>
<li>active CSS 클래스를 자동으로 추가해주는 링크</li>
<li>HTML5 히스토리 모드 또는 해시 모드(IE9에서 자동으로 폴백)</li>
<li>사용자 정의 가능한 스크롤 동작</li>
</ol>
</li>
<li>
<h3 id="vue-router를-사용하는-방법은" style="position:relative;"><a href="#vue-router%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="vue router를 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue Router를 사용하는 방법은?</h3>
<p>Vue를 사용하고 있다면, 쉽게 Vue Router를 통합할 수 있습니다.</p>
<p><strong>Step 1:</strong> 먼저 템플릿에서 <code class="language-text">&lt;router-link&gt;</code>태그를 설정합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;Welcome to Vue routing app!&lt;/h1&gt;
  &lt;p&gt;
    &lt;!-- use router-link component for navigation using `to` prop. It rendered as an `&lt;a&gt;` tag --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;
    &lt;router-link to=&quot;/services&quot;&gt;Services&lt;/router-link&gt;
  &lt;/p&gt;
  &lt;!-- route outlet in which component matched by the route will render here --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;</code></pre></div>
<p><strong>Step 2:</strong> <code class="language-text">main.js</code>에서 Vue와 Vue 라우터를 <code class="language-text">import</code>하고 <code class="language-text">Vue.use()</code>함수를 이용해 호출합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import Vue from &#39;vue&#39;;
import VueRouter from &#39;vue-router&#39;;

Vue.use(VueRouter)</code></pre></div>
<p><strong>Step 3:</strong> 라우트 컴포넌트를 정의하거나 <code class="language-text">import</code>합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const Home = { template: &#39;&lt;div&gt;Home&lt;/div&gt;&#39; }
const Services = { template: &#39;&lt;div&gt;Services&lt;/div&gt;&#39; }</code></pre></div>
<p><strong>Step 4:</strong> 라우트를 정의합니다. 각 라우트는 반드시 컴포넌트와 매핑되어야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const routes = [
  { path: &#39;/home&#39;, component: Home },
  { path: &#39;/services&#39;, component: Services }
]</code></pre></div>
<p><strong>Step 5:</strong> <code class="language-text">routes</code> 옵션과 함께 router 인스턴스를 만듭니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const router = new VueRouter({
  routes // short for `routes: routes`
})</code></pre></div>
<p><strong>Step 6:</strong> 루트 Vue 인스턴스를 만들고 <code class="language-text">mount</code>합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const app = new Vue({
  router
}).$mount(&#39;#app&#39;)</code></pre></div>
<p>이제 Vue 어플리케이션에서 다른 페이지(Home, Services)로 네비게이트 할 수 있습니다.</p>
</li>
<li>
<h3 id="동적-라우트-매칭이란" style="position:relative;"><a href="#%EB%8F%99%EC%A0%81-%EB%9D%BC%EC%9A%B0%ED%8A%B8-%EB%A7%A4%EC%B9%AD%EC%9D%B4%EB%9E%80" aria-label="동적 라우트 매칭이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동적 라우트 매칭이란?</h3>
<p>주어진 패턴을 가진 라우트를 동일한 컴포넌트에 매핑해야하는 경우가 자주 있습니다. 동적 세그먼트를 이용해 <code class="language-text">/user/john/post/123</code>나 <code class="language-text">/user/jack/post/235</code>와 같이 매핑된 URL을 가지는 컴포넌트를 만들어봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const User = {
  template: &#39;&lt;div&gt;User {{ $route.params.name }}, PostId: {{ route.params.postid }}&lt;/div&gt;&#39;
}

const router = new VueRouter({
  routes: [
    // dynamic segments start with a colon
    { path: &#39;/user/:name/post/:postid&#39;, component: User }
  ]
})</code></pre></div>
</li>
<li>
<h3 id="라우터-params를-반응적으로-만드는-방법은" style="position:relative;"><a href="#%EB%9D%BC%EC%9A%B0%ED%84%B0-params%EB%A5%BC-%EB%B0%98%EC%9D%91%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="라우터 params를 반응적으로 만드는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>라우터 params를 반응적으로 만드는 방법은?</h3>
<p>매개 변수와 함께 라우트를 사용할 때 주의 해야할 점은 사용자가 <code class="language-text">/user/foo</code>에서 <code class="language-text">/user/bar</code>로 이동할 때 동일한 컴포넌트 인스턴스가 재사용된다는 것입니다. 두 라우트 모두 동일한 컴포넌트를 렌더링하므로 이전 인스턴스를 삭제 한 다음 새 인스턴스를 만드는 것보다 효율적입니다. 그러나 이는 또한 컴포넌트의 라이프 사이클 훅이 호출되지 않음을 의미합니다.</p>
<p>동일한 컴포넌트의 <code class="language-text">params</code> 변경 사항에 반응하려면 <code class="language-text">$route</code> 객체를 보면됩니다.</p>
<ol>
<li><code class="language-text">watch</code>에서 <code class="language-text">$route</code> 관찰하기:</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const User = {
  template: &#39;&lt;div&gt;User {{ $route.params.name }} &lt;/div&gt;&#39;,
  watch: {
    &#39;$route&#39; (to, from) {
      // react to route changes...
    }
  }
}</code></pre></div>
<ol>
<li><code class="language-text">beforeRouteUpdate</code> 네비게이션 가드를 사용하기:</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const User = {
  template: &#39;&lt;div&gt;User {{ $route.params.name }} &lt;/div&gt;&#39;,
  beforeRouteUpdate (to, from, next) {
    // react to route changes and then call next()
  }
}</code></pre></div>
<p><code class="language-text">beforeRouteEnter</code> 가드에서는 <code class="language-text">this</code>에 접근할 권한이 없다는 것을 기억하세요. 대신, <code class="language-text">next</code> 콜백 함수를 이용해 인스턴스에 접근할 수 있습니다.</p>
</li>
<li>
<h3 id="라우트의-우선-순위는" style="position:relative;"><a href="#%EB%9D%BC%EC%9A%B0%ED%8A%B8%EC%9D%98-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84%EB%8A%94" aria-label="라우트의 우선 순위는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>라우트의 우선 순위는?</h3>
<p>동일한 URL이 여러 라우트와 일치하는 경우가 있습니다. 이 경우 일치하는 우선 순위는 라우트 정의의 순서에 따라 결정됩니다. 즉, 경로가 더 먼저 정의 될수록 우선 순위가 높아집니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const router = new VueRouter({
       routes: [
         // dynamic segments start with a colon
         { path: &#39;/user/:name&#39;, component: User } // This route gets higher priority
         { path: &#39;/user/:name&#39;, component: Admin }
         { path: &#39;/user/:name&#39;, component: Customer }
       ]
     })</code></pre></div>
</li>
<li>
<h3 id="중첩된-라우트란" style="position:relative;"><a href="#%EC%A4%91%EC%B2%A9%EB%90%9C-%EB%9D%BC%EC%9A%B0%ED%8A%B8%EB%9E%80" aria-label="중첩된 라우트란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>중첩된 라우트란?</h3>
<p>일반적으로 어플리케이션은 여러 단계의 중첩된 컴포넌트로 이루어져 있습니다. URL의 세그먼트 역시 중첩된 컴포넌트의 특정 구조와 일치합니다. 중첩된 아웃렛에서 컴포넌트를 렌더링하려면 <code class="language-text">VueRouter</code> 생성자에서 <code class="language-text">config</code>로 <code class="language-text">children</code>을 설정해야 합니다.</p>
<p>프로필과 포스트들이 상대적인 경로로 설정된 어플리케이션을 만들어봅시다. 매칭되는 하위 라우트가 없을 경우에 렌더링되는 라우트 컴포넌트를 설정할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const router = new VueRouter({
  routes: [
    { path: &#39;/user/:id&#39;, component: User,
      children: [
        {
          // UserProfile will be rendered inside User&#39;s &lt;router-view&gt; when /user/:id/profile is matched
          path: &#39;profile&#39;,
          component: UserProfile
        },
        {
          // UserPosts will be rendered inside User&#39;s &lt;router-view&gt; when /user/:id/posts is matched
          path: &#39;posts&#39;,
          component: UserPosts
        },
          // UserHome will be rendered inside User&#39;s &lt;router-view&gt; when /user/:id is matched
        {  path: &#39;&#39;,
           component: UserHome },
      ]
    }
  ]
})</code></pre></div>
</li>
<li>
<h3 id="싱글-파일-컴포넌트란" style="position:relative;"><a href="#%EC%8B%B1%EA%B8%80-%ED%8C%8C%EC%9D%BC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80" aria-label="싱글 파일 컴포넌트란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>싱글 파일 컴포넌트란?</h3>
<p>아마 하나의 페이지에서 HTML, CSS, JavaScript을 다른 파일로 분리해 관리해본 경험이 있을 것입니다. 하지만 싱글 파일 컴포넌트에서는 템플릿과 스타일, 로직들을 하나의 파일에 정리합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;Welcome {{ name }}!&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    module.exports = {
       data: function() {
           return {
               name: &#39;John&#39;
           }
       }
    }
&lt;/script&gt;

&lt;style scoped&gt;
    h1 {
        color: #34c779;
        padding: 3px;
    }
&lt;/style&gt;</code></pre></div>
</li>
<li>
<h3 id="관심사-분리separation-of-concerns이란" style="position:relative;"><a href="#%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%ACseparation-of-concerns%EC%9D%B4%EB%9E%80" aria-label="관심사 분리separation of concerns이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>관심사 분리(separation of concerns)이란?</h3>
<p>주목해야 할 중요한 점은 관심사 분리가 파일 타입 분리와 같지 않다는 것입니다. 현대적인 UI 개발에서 코드베이스를 서로 얽혀있는 세 개의 거대한 레이어로 나누는 대신, 느슨하게 결합 된 컴포넌트로 나누고 구성하는 것이 더 중요합니다. 컴포넌트 내부에서 템플릿, 로직 및 스타일이 본질적으로 결합되어 배치되면 컴포넌트의 응집력과 유지 보수성이 향상됩니다.</p>
<p>싱글 파일 컴포넌트에 대한 아이디어가 마음에 들지 않더라도 JavaScript와 CSS를 별도의 파일로 분리하여 핫 리로드 및 사전 컴파일 기능을 활용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
  &lt;div&gt;This section will be pre-compiled and hot reloaded&lt;/div&gt;
&lt;/template&gt;
&lt;script src=&quot;./my-component.js&quot;&gt;&lt;/script&gt;
&lt;style src=&quot;./my-component.css&quot;&gt;&lt;/style&gt;</code></pre></div>
</li>
<li>
<h3 id="싱글-파일-컴포넌트는-왜-필요할까" style="position:relative;"><a href="#%EC%8B%B1%EA%B8%80-%ED%8C%8C%EC%9D%BC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C" aria-label="싱글 파일 컴포넌트는 왜 필요할까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>싱글 파일 컴포넌트는 왜 필요할까?</h3>
<p>복잡한 프로젝트의 경우 또는 프론트엔드가 JavaScript 기반인 경우 단점이 분명해집니다. 싱글 파일 컴포넌트가 아닌 경우에는 아래와 같은 문제점이 있을 수 있습니다.</p>
<ol>
<li><strong>전역 정의</strong> 모든 구성 요소에 대해 고유한 이름을 지정하도록 강요됩니다.</li>
<li><strong>문자열 템플릿</strong> 구문 강조가 약해 여러 줄로 된 HTML에 보기 안좋은 슬래시가 많이 필요합니다.</li>
<li><strong>CSS 지원 없음</strong> HTML 및 JavaScript가 컴포넌트로 모듈화 되어 있으나 CSS가 빠져 있는 것을 말합니다.</li>
<li><strong>빌드 단계 없음</strong> Pug (이전의 Jade) 및 Babel과 같은 전처리기가 아닌 HTML 및 ES5 JavaScript로 제한됩니다.</li>
</ol>
<p>싱글 파일 컴포넌트는 JavaScript 기반에서 발생하는 문제점을 해결하기 위해, 별도의 <code class="language-text">.vue</code> 확장자의 파일로 작성합니다.</p>
</li>
<li>
<h3 id="filter란" style="position:relative;"><a href="#filter%EB%9E%80" aria-label="filter란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>filter란?</h3>
<p><code class="language-text">filter</code>는 텍스트 형식화를 위해 사용됩니다. 이 필터들은 자바스크립트 표현식에 파이프(<code class="language-text">|</code>) 기호와 함께 추가되어야 합니다. 크게 두 가지 경우에서 사용될 수 있습니다.</p>
<ol>
<li>중괄호 보간법</li>
<li><code class="language-text">v-bind</code> 표현식</li>
</ol>
<p>첫 글자를 대문자로 만드는 로컬 필터를 정의해봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">filters: {
  capitalize: function (value) {
    if (!value) return &#39;&#39;
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}</code></pre></div>
<p>이 필터를 중괄호 보간법 또는 <code class="language-text">v-bind</code> 표현식 함께 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- in mustaches --&gt;
{{ username | capitalize }}

&lt;!-- in v-bind --&gt;
&lt;div v-bind:id=&quot;username | capitalize&quot;&gt;&lt;/div&gt;</code></pre></div>
</li>
<li>
<h3 id="filter를-전역적-또는-지역적으로-만드는-법은" style="position:relative;"><a href="#filter%EB%A5%BC-%EC%A0%84%EC%97%AD%EC%A0%81-%EB%98%90%EB%8A%94-%EC%A7%80%EC%97%AD%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B2%95%EC%9D%80" aria-label="filter를 전역적 또는 지역적으로 만드는 법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>filter를 전역적 또는 지역적으로 만드는 법은?</h3>
<ol>
<li><strong>지역 필터(Local filters):</strong> 지역 필터는 컴포넌트의 옵션에서 정의할 수 있습니다. 이 경우, 필터는 해당 컴포넌트에서만 사용 가능합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">filters: {
  capitalize: function (value) {
    if (!value) return &#39;&#39;
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}</code></pre></div>
<ol>
<li><strong>전역 필터(Global filters):</strong> Vue 인스턴스를 만들기 전에 전역적으로 필터를 정의할 수 있습니다. 이 경우 Vue 인스턴스 내의 모든 컴포넌트에서 필터를 사용할 수 있습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.filter(&#39;capitalize&#39;, function (value) {
  if (!value) return &#39;&#39;
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})</code></pre></div>
</li>
<li>
<h3 id="filter를-연속해-쓰는-방법은" style="position:relative;"><a href="#filter%EB%A5%BC-%EC%97%B0%EC%86%8D%ED%95%B4-%EC%93%B0%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="filter를 연속해 쓰는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>filter를 연속해 쓰는 방법은?</h3>
<p>일반적으로 아래와 같이, 표현식에서 필터 뒤에 또 다른 필터를 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">{{ message | filterA | filterB | filterC ... }}</code></pre></div>
<p>각각의 필터는 파이프(<code class="language-text">|</code>)로 구분되며, <code class="language-text">message</code>는 <code class="language-text">filterA</code>의 결과가 <code class="language-text">filterB</code>의 영향을 받고, 그 결과가 다시 <code class="language-text">filterC</code>의 영향을 받습니다.</p>
<p>예를 들어, 날짜 형식의 데이터를 변경한 뒤 대문자로 변경하고 싶다면 아래와 같이 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">{{ birthday | dateFormat | uppercase }}</code></pre></div>
</li>
<li>
<h3 id="filter에-파라미터를-전달할-수-있을까" style="position:relative;"><a href="#filter%EC%97%90-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C" aria-label="filter에 파라미터를 전달할 수 있을까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>filter에 파라미터를 전달할 수 있을까?</h3>
<p>필터는 기본적으로 자바스크립트 함수이기 때문에, 아래와 같이 두 개 이상의 인수를 받을 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">{{ message | filterA(&#39;arg1&#39;, arg2) }}</code></pre></div>
<p>여기서 <code class="language-text">filterA</code>는 세 개의 인수를 받는 함수로 정의되었습니다. <code class="language-text">message</code>의 값은 첫번째 인수로 전달될 것이며, 순수 문자열인 <code class="language-text">&#39;arg1&#39;</code>은 두번째 인수로 전달될 것이며, 자바스크립트 표현식인 <code class="language-text">arg2</code>는 표현식이 실행된 이후에 세번째 인수로 전달될 것입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">{{ 2 | exponentialStrength(10) }} // prints 2 power 10 = 1024</code></pre></div>
</li>
<li>
<h3 id="플러그인이란" style="position:relative;"><a href="#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%B4%EB%9E%80" aria-label="플러그인이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>플러그인이란?</h3>
<p>플러그인은 일반적으로 전역 수준 기능을 Vue 어플리케이션에 추가합니다.</p>
<ol>
<li>전역 메소드 또는 속성 추가(<code class="language-text">&lt;vue-custom-element&gt;</code>)</li>
<li>하나 이상의 글로벌 에셋 추가(지시자, 필터, 트랜지션)</li>
<li>전역 믹스인으로 컴포넌트 옵션(vuex)</li>
<li><code class="language-text">Vue.prototype</code>를 이용해 Vue에 인스턴스 메소드를 추가</li>
<li>위의 기능과 함께 자체 API를 제공하는 라이브러리(vue-router)</li>
</ol>
</li>
<li>
<h3 id="플러그인을-만드는-방법은" style="position:relative;"><a href="#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="플러그인을 만드는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>플러그인을 만드는 방법은?</h3>
<p>플러그인에서는 <code class="language-text">install</code> 메소드를 정의해야 합니다. 이 메소드는 첫 번째 인자로 Vue 생성자와 외부에서 설정 가능한 옵션을 파라미터로 전달받습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">MyPlugin.install = function (Vue, options) {
  // 1. add global method or property
  Vue.myGlobalMethod = function () {
    // some logic ...
  }

  // 2. add a global asset
  Vue.directive(&#39;my-directive&#39;, {
    bind (el, binding, vnode, oldVnode) {
      // some logic ...
    }
    ...
  })

  // 3. inject some component options
  Vue.mixin({
    created: function () {
      // some logic ...
    }
    ...
  })

  // 4. add an instance method
  Vue.prototype.$myMethod = function (methodOptions) {
    // some logic ...
  }
}</code></pre></div>
</li>
<li>
<h3 id="플러그인을-사용하는-방법은" style="position:relative;"><a href="#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="플러그인을 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>플러그인을 사용하는 방법은?</h3>
<p><code class="language-text">Vue.use()</code> 전역 메소드를 호출하여 플러그인을 사용할 수 있습니다. 이 함수는 생성자 <code class="language-text">new Vue()</code>로 Vue 인스턴스를 생성하기 전에 호출되어야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// calls `MyPlugin.install(Vue, { someOption: true })`
Vue.use(MyPlugin)

new Vue({
  //... options
})</code></pre></div>
</li>
<li>
<h3 id="믹스인이란" style="position:relative;"><a href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%B4%EB%9E%80" aria-label="믹스인이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>믹스인이란?</h3>
<p>Mixins는 Vue 컴포넌트에 재사용 가능한 기능을 배포하는 유연한 방법입니다. 믹스인에 존재하는 기능들은 호출된 컴포넌트의 기능들과 합쳐집니다.</p>
<p>mixin 객체는 모든 구성 요소 옵션을 포함할 수 있습니다. 다른 컴포넌트에서 재사용될 수 있는 <code class="language-text">created</code> 라이프사이클 훅을 가진 믹스인을 작성해봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const myMixin = {
  created(){
    console.log(&quot;Welcome to Mixins!&quot;)
  }
}
var app = new Vue({
  el: &#39;#root&#39;,
  mixins: [myMixin]
})</code></pre></div>
<p><strong>Note:</strong> 여러 믹스인은 배열의 형태로 사용할 수 있습니다.</p>
</li>
<li>
<h3 id="전역-믹스인이란" style="position:relative;"><a href="#%EC%A0%84%EC%97%AD-%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%B4%EB%9E%80" aria-label="전역 믹스인이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>전역 믹스인이란?</h3>
<p>Vue 어플리케이션의 모든 컴포넌트에 동일한 옵션이나 기능을 확장해 사용할 필요가 있을 수 있습니다. 이 경우, 전역 믹스인을 활용해 Vue의 모든 컴포넌트에 영향을 줄 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.mixin({
   created(){
     console.log(&quot;Write global mixins&quot;)
   }
})

new Vue({
  el: &#39;#app&#39;
})</code></pre></div>
<p>위의 전역 믹스인은 해당 Vue 인스턴스에서 각 컴포넌트가 생성될 때마다 <code class="language-text">created</code> 훅에서 로그를 발생시킵니다. 즉 모든 단일 Vue 인스턴스에 영향을 주기 때문에 적게 이용하고 신중하게 사용해야 합니다.</p>
</li>
<li>
<h3 id="cli-환경에서-믹스인을-사용하는-법은" style="position:relative;"><a href="#cli-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B2%95%EC%9D%80" aria-label="cli 환경에서 믹스인을 사용하는 법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CLI 환경에서 믹스인을 사용하는 법은?</h3>
<p>Vue CLI를 사용한다면, 믹스인은 일반적으로 <code class="language-text">/src/mixins</code> 디렉토리에서 <code class="language-text">.js</code>파일로 작성합니다. <code class="language-text">export</code> 키워드로 외부에 내보낸다는 것을 선언해야 하며 사용할 Vue 컴포넌트에서 <code class="language-text">import</code> 키워드로 불러올 수 있습니다.</p>
</li>
<li>
<h3 id="믹스인의-옵션이-컴포넌트의-옵션과-충돌한다면" style="position:relative;"><a href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%98-%EC%98%B5%EC%85%98%EC%9D%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%98%B5%EC%85%98%EA%B3%BC-%EC%B6%A9%EB%8F%8C%ED%95%9C%EB%8B%A4%EB%A9%B4" aria-label="믹스인의 옵션이 컴포넌트의 옵션과 충돌한다면 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>믹스인의 옵션이 컴포넌트의 옵션과 충돌한다면?</h3>
<p>믹스인과 컴포넌트에서 충돌하는 옵션이 있다면, 옵션은 몇 가지 방법을 통해 충돌하는 옵션을 병합합니다.</p>
<ol>
<li><code class="language-text">data</code>는 재귀적으로 병합하되, 충돌되는 속성은 컴포넌트의 데이터가 우선적으로 병합됩니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var mixin = {
  data: function () {
    return {
      message: &#39;Hello, this is a Mixin&#39;
    }
  }
 }
new Vue({
  mixins: [mixin],
  data: function () {
    return {
      message: &#39;Hello, this is a Component&#39;
    }
  },
  created: function () {
    console.log(this.$data); // =&gt; { message: &quot;Hello, this is a Component&#39;&quot; }
  }
})</code></pre></div>
<ol>
<li>라이프사이클 훅 함수는 믹스인 함수가 먼저 실행되고, 그 다음에 컴포넌트의 함수가 실행됩니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const myMixin = {
  created(){
    console.log(&quot;Called from Mixin&quot;)
  }
}

new Vue({
  el: &#39;#root&#39;,
  mixins:[myMixin],
  created(){
    console.log(&quot;Called from Component&quot;)
  }
})

//Called from Mixin
//Called from Component</code></pre></div>
<ol>
<li><code class="language-text">methods</code>, <code class="language-text">components</code>, <code class="language-text">directives</code> 역시 재귀적으로 병합하되, 이러한 객체에 충돌하는 키가 있을 경우 컴포넌트의 옵션이 우선순위를 갖습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">var mixin = {
  methods: {
    firstName: function () {
      console.log(&#39;John&#39;)
    },
    contact: function () {
      console.log(&#39;+65 99898987&#39;)
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    lastName: function () {
      console.log(&#39;Murray&#39;)
    },
    contact: function () {
      console.log(&#39;+91 893839389&#39;)
    }
  }
})

vm.firstName() // &quot;John&quot;
vm.lastName() // &quot;Murray&quot;
vm.contact() // &quot;+91 893839389&quot;</code></pre></div>
</li>
<li>
<h3 id="믹스인의-병합-방법을-사용자-정의하는-방법은" style="position:relative;"><a href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%98-%EB%B3%91%ED%95%A9-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="믹스인의 병합 방법을 사용자 정의하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>믹스인의 병합 방법을 사용자 정의하는 방법은?</h3>
<p>Vue에서는 사용자 지정 옵션을 병합할 때 기본적으로 기존 값을 덮어는 방법을 이용합니다. 만약 사용자 정의의 로직을 사용해 커스텀 옵션을 병합하려면,<code class="language-text">Vue.config.optionMergeStrategies</code>에 함수를 추가할 필요가 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // return mergedVal
}</code></pre></div>
<p>더 고급 예제는 Vuex의 1.x 병합 전략에서 확인하실 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const merge = Vue.config.optionMergeStrategies.computed
Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
  if (!toVal) return fromVal
  if (!fromVal) return toVal
  return {
    getters: merge(toVal.getters, fromVal.getters),
    state: merge(toVal.state, fromVal.state),
    actions: merge(toVal.actions, fromVal.actions)
  }
}</code></pre></div>
</li>
<li>
<h3 id="사용자-정의-지시자custom-directive란" style="position:relative;"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%A7%80%EC%8B%9C%EC%9E%90custom-directive%EB%9E%80" aria-label="사용자 정의 지시자custom directive란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자 정의 지시자(Custom directive)란?</h3>
<p>지시자는 DOM 엘리먼트에 부착할 수 있는 명령어입니다. 위에서 본 것처럼 <code class="language-text">v-</code>로 시작하는 문법을 사용해 Vue가 이 명령어를 인식할 수 있도록 해야 합니다. 일반적으로 하위 수준의 DOM을 제어하기 위해 직접 접근해야 할 필요가 있을 때 유용하게 사용됩니다.</p>
<p>페이지가 로드될 때 <code class="language-text">input</code>에 자동으로 포커싱되는 사용자 정의 지시자를 전역으로 만들어봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Register a global custom directive called `v-focus`
Vue.directive(&#39;focus&#39;, {
  // When the bound element is inserted into the DOM...
  inserted: function (el) {
    // Focus the element
    el.focus()
  }
})</code></pre></div>
<p>이제 이 지시자는 <code class="language-text">v-focus</code>라는 문법과 함께 어떤 컴포넌트에서든 사용될 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-focus&gt;</code></pre></div>
</li>
<li>
<h3 id="지시자를-지역-등록하는-방법은" style="position:relative;"><a href="#%EC%A7%80%EC%8B%9C%EC%9E%90%EB%A5%BC-%EC%A7%80%EC%97%AD-%EB%93%B1%EB%A1%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="지시자를 지역 등록하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>지시자를 지역 등록하는 방법은?</h3>
<p>지시자를 지역 등록하기 위해서는 <code class="language-text">directives</code> 옵션을 이용합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">directives: {
  focus: {
    // directive definition
    inserted: function (el) {
      el.focus()
    }
  }
}</code></pre></div>
<p>이 지시자는 선언된 해당 컴포넌트에서만 사용될 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;input v-focus&gt;</code></pre></div>
</li>
<li>
<h3 id="지시자에-의해-제공되는-라이프-사이클-훅은" style="position:relative;"><a href="#%EC%A7%80%EC%8B%9C%EC%9E%90%EC%97%90-%EC%9D%98%ED%95%B4-%EC%A0%9C%EA%B3%B5%EB%90%98%EB%8A%94-%EB%9D%BC%EC%9D%B4%ED%94%84-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9B%85%EC%9D%80" aria-label="지시자에 의해 제공되는 라이프 사이클 훅은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>지시자에 의해 제공되는 라이프 사이클 훅은?</h3>
<p>지시자 객체가 등록될 때 몇 개의 라이프 사이클 훅을 제공합니다.</p>
<ol>
<li><code class="language-text">bind</code>: 지시자가 처음 엘리먼트에 부착될 때 한 번 호출됩니다.</li>
<li><code class="language-text">inserted</code>: 지시자가 부착된 엘리먼트가 DOM에 삽입되었을 때 호출됩니다.</li>
<li><code class="language-text">update</code>: 해당 엘리먼트가 업데이트 될 때 호출됩니다. 하지만 아직 하위 엘리먼트는 업데이트 되지 않은 상태입니다.</li>
<li><code class="language-text">componentUpdated</code>: 하위 컴포넌트까지 업데이트 된 상태일 때 호출됩니다.</li>
<li><code class="language-text">unbind</code>: 지시자가 엘리먼트에서부터 삭제될 때 호출됩니다.</li>
</ol>
<p><strong>Note:</strong> 위의 훅에서는 특정한 전달인자(Argument)를 받는다.</p>
</li>
<li>
<h3 id="디렉티브-훅의-전달인자는" style="position:relative;"><a href="#%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C-%ED%9B%85%EC%9D%98-%EC%A0%84%EB%8B%AC%EC%9D%B8%EC%9E%90%EB%8A%94" aria-label="디렉티브 훅의 전달인자는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디렉티브 훅의 전달인자는?</h3>
<p>모든 훅에서는 전달인자로 <code class="language-text">el</code>, <code class="language-text">binding</code>와 <code class="language-text">vnode</code>를 갖고 있습니다. 그와 함께, <strong>update</strong>와 <strong>componentUpdated</strong>훅에서는 새 값과 이전 값을 비교하기 위해 <code class="language-text">oldVnode</code>를 추가적으로 갖고 있습니다.</p>
<ol>
<li><code class="language-text">el</code>: 해당 지시자가 부착된 엘리먼트로, 이를 이용해 DOM을 조작할 수 있습니다.</li>
<li>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">binding</code></pre></div>
<p>: 아래의 속성을 가진 객체입니다.</p>
<ol>
<li><code class="language-text">name</code>: 지시자의 이름으로, <code class="language-text">v-</code> 접두사가 제거된 이름입니다.</li>
<li><code class="language-text">value</code>: 지시자에서 전달 받은 값입니다. 만약 <code class="language-text">v-my-directive=&quot;1 + 1&quot;</code>라면 <code class="language-text">2</code>가 됩니다.</li>
<li><code class="language-text">oldValue</code>: 이전 값으로, <code class="language-text">update</code>와 <code class="language-text">componentUpdated</code>훅에서만 사용할 수 있습니다. 이를 통해 값이 변경되었는지 아닌지를 확인할 수 있습니다.</li>
<li><code class="language-text">expression</code>: 문자열로 바인딩된 표현식입니다. 만약 <code class="language-text">v-my-directive=&quot;1 + 1&quot;</code>라면 <code class="language-text">&quot;1 + 1&quot;</code>이 됩니다..</li>
<li><code class="language-text">arg</code>: 지시자의 전달인자입니다. 만약 <code class="language-text">v-my-directive:foo</code>라면 <code class="language-text">&quot;foo&quot;</code>가 됩니다..</li>
<li><code class="language-text">modifiers</code>: 수식어가 포함된 객체입니다. 만약 <code class="language-text">v-my-directive.foo.bar</code>라면 <code class="language-text">{ foo: true, bar: true }</code>가 됩니다.</li>
</ol>
</li>
<li><code class="language-text">vnode</code>: Vue의 컴파일러에 의해 생성된 가상 노드입니다.</li>
<li><code class="language-text">oldVnode</code>: 이 전의 가상 노드로, <code class="language-text">update</code>와 <code class="language-text">componentUpdated</code>훅에서만 사용할 수 있습니다.</li>
</ol>
<p><a href="https://github.com/sudheerj/vuejs-interview-questions/blob/master/images/custom-directives.svg" target="_blank" rel="nofollow noopener noreferrer"><img src="https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/custom-directives.svg" alt="custom-directives"></a></p>
</li>
<li>
<h3 id="지시자에-여러-값들을-전달하는-방법은" style="position:relative;"><a href="#%EC%A7%80%EC%8B%9C%EC%9E%90%EC%97%90-%EC%97%AC%EB%9F%AC-%EA%B0%92%EB%93%A4%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="지시자에 여러 값들을 전달하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>지시자에 여러 값들을 전달하는 방법은?</h3>
<p>지시자는 유효한 자바스크립트 표현식은 모두 수용할 수 있습니다. 따라서 지사자에 여러 값들을 전달하려면, 자바스크립트 객체 리터럴을 이용해 전달할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div v-avatar=&quot;{ width: 500, height: 400, url: &#39;path/logo&#39;, text: &#39;Iron Man&#39; }&quot;&gt;&lt;/div&gt;</code></pre></div>
<p>이제 <code class="language-text">v-avatar</code> 지시자를 전역으로 설정해봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.directive(&#39;avatar&#39;, function (el, binding) {
  console.log(binding.value.width) // 500
  console.log(binding.value.height)  // 400
  console.log(binding.value.url) // path/logo
  console.log(binding.value.text)  // &quot;Iron Man&quot;
})</code></pre></div>
</li>
<li>
<h3 id="지시자-훅에서-함수-약어는" style="position:relative;"><a href="#%EC%A7%80%EC%8B%9C%EC%9E%90-%ED%9B%85%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EC%95%BD%EC%96%B4%EB%8A%94" aria-label="지시자 훅에서 함수 약어는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>지시자 훅에서 함수 약어는?</h3>
<p>드문 경우지만, 다른 훅과는 상관없이 <code class="language-text">bind</code>나 <code class="language-text">update</code> 훅에서 같은 동작을 하기 원할 수 있습니다. 이 경우에는 함수 약어를 사용할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.directive(&#39;theme-switcher&#39;, function (el, binding) {
  el.style.backgroundColor = binding.value
})</code></pre></div>
</li>
<li>
<h3 id="render-함수를-사용하는-이유는" style="position:relative;"><a href="#render-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94" aria-label="render 함수를 사용하는 이유는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>render 함수를 사용하는 이유는?</h3>
<p>일반적인 경우 Vue의 템플릿을 이용해 HTML을 작성하는 것을 권장합니다. 하지만 <code class="language-text">input</code>이나 <code class="language-text">slot</code>의 값을 이용해 동적인 컴포넌트를 생성하는 것처럼, 일부 특별한 경우에는 JavaScript가 필요한 경우가 있습니다. 이때 <code class="language-text">render</code> 함수를 사용하며, <code class="language-text">render</code>함수는 JavaScript로 작성하기 때문에 프로그래밍 환경을 온전히 이용할 수 있다는 장점이 있습니다.</p>
</li>
<li>
<h3 id="render-함수란" style="position:relative;"><a href="#render-%ED%95%A8%EC%88%98%EB%9E%80" aria-label="render 함수란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>render 함수란?</h3>
<p><code class="language-text">render</code> 함수는 <code class="language-text">createElement</code>라는 함수를 첫 번째 인자로 받아 가상 노드를 생성하는 함수입니다. 내부적으로 Vue의 템플릿은 빌드 타임에서 <code class="language-text">render</code> 함수를 이용해 컴파일하고 있습니다. 그러므로 템플릿은 <code class="language-text">render</code> 함수를 문법적으로 보기 쉽게 만들어 놓은 것에 가깝습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
 &lt;div :class=&quot;{&#39;is-rounded&#39;: isRounded}&quot;&gt;
   &lt;p&gt;Welcome to Vue render functions&lt;/p&gt;
 &lt;/div&gt;
&lt;/template&gt;</code></pre></div>
<p>위의 템플릿을 <code class="language-text">render</code> 함수로 작성하면 아래와 같습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">render: function (createElement) {
   return createElement(&#39;div&#39;, {
     &#39;class&#39;: {
         &#39;is-rounded&#39;: this.isRounded
     }
   }, [
     createElement(&#39;p&#39;, &#39;Welcome to Vue render functions&#39;)
   ]);
  },</code></pre></div>
</li>
<li>
<h3 id="createelement-함수란" style="position:relative;"><a href="#createelement-%ED%95%A8%EC%88%98%EB%9E%80" aria-label="createelement 함수란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>createElement 함수란?</h3>
<p><code class="language-text">createElement</code> 함수는 몇 가지의 약속된 전달인자를 받는데, 이를 이용해 템플릿에서 사용되는 기능을 JavaScript 코드로 작성할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// @returns {VNode}
createElement(
  // An HTML tag name, component options, or async function resolving to one of these.
  // Type is {String | Object | Function}
  // Required.
  &#39;div&#39;,

  // A data object corresponding to the attributes you would use in a template.
  //Type is {Object}
  // Optional.
  {
      // Normal HTML attributes
      attrs: {
        id: &#39;someId&#39;
      },
      // Component props
      props: {
        myProp: &#39;somePropValue&#39;
      },
      // DOM properties
      domProps: {
        innerHTML: &#39;This is some text&#39;
      },
      // Event handlers are nested under `on`
      on: {
          click: this.clickHandler
        },
      // Similar to `v-bind:style`, accepting either a string, object, or array of objects.
       style: {
          color: &#39;red&#39;,
          fontSize: &#39;14px&#39;
       },
       //Similar to `v-bind:class`, accepting either a string, object, or array of strings and objects.
        class: {
           classsName1: true,
           classsName2: false
        },
        ....
  },

  // Children VNodes, built using `createElement()`, or using strings to get &#39;text VNodes&#39;.
  // Type is {String | Array}
  // Optional.
  [
    &#39;Learn about createElement arguments.&#39;,
    createElement(&#39;h1&#39;, &#39;Headline as a child virtual node&#39;),
    createElement(MyComponent, {
      props: {
        someProp: &#39;This is a prop value&#39;
      }
    })
  ]
)</code></pre></div>
<p>자세한 내용은 <a href="https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth" target="_blank" rel="nofollow noopener noreferrer">공식 문서</a>에서 확인할 수 있습니다.</p>
</li>
<li>
<h3 id="가상-노드를-여러-번-사용할-수-있는-방법은" style="position:relative;"><a href="#%EA%B0%80%EC%83%81-%EB%85%B8%EB%93%9C%EB%A5%BC-%EC%97%AC%EB%9F%AC-%EB%B2%88-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="가상 노드를 여러 번 사용할 수 있는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>가상 노드를 여러 번 사용할 수 있는 방법은?</h3>
<p>컴포넌트 트리의 모든 가상 노드(VNodes)는 고유해야 합니다. 즉, 직접 가상 노드를 여러 번 사용할 수는 없습니다. 만약 같은 엘리먼트나 컴포넌트를 여러 번 반복해서 사용해야 한다면, 팩토리 패턴을 이용해 작성해야 합니다.</p>
<p>아래의 <code class="language-text">render</code> 함수는 <code class="language-text">h1</code> 엘리먼트를 세 번 반복하려 했기 때문에 유효하지 않습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">render: function (createElement) {
  var myHeadingVNode = createElement(&#39;h1&#39;, &#39;This is a Virtual Node&#39;)
  return createElement(&#39;div&#39;, [
    myHeadingVNode, myHeadingVNode, myHeadingVNode
  ])
}</code></pre></div>
<p>팩토리 패턴을 이용하면 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">render: function (createElement) {
  return createElement(&#39;div&#39;,
    Array.apply(null, { length: 3 }).map(function () {
      return createElement(&#39;h1&#39;, &#39;This is a Virtual Node&#39;)
    })
  )
}</code></pre></div>
</li>
<li>
<h3 id="render-함수와-템플릿을-비교한다면" style="position:relative;"><a href="#render-%ED%95%A8%EC%88%98%EC%99%80-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9D%84-%EB%B9%84%EA%B5%90%ED%95%9C%EB%8B%A4%EB%A9%B4" aria-label="render 함수와 템플릿을 비교한다면 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>render 함수와 템플릿을 비교한다면?</h3>
<p>Vue에서 HTML을 작성하는데 사용되는 템플릿과 render 함수를 비교해봅시다.</p>
<table>
<thead>
<tr>
<th>템플릿(Templates)</th>
<th>렌더 함수(Render function)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-text">v-if</code>와 <code class="language-text">v-for</code>를 이용해 조건문/반복문 실행</td>
<td>JavaScript의 <code class="language-text">if else</code>문과 <code class="language-text">map</code> 메소드로 조건문/반복문 실행</td>
</tr>
<tr>
<td><code class="language-text">v-model</code>로 양방향 바인딩</td>
<td>바인딩과 이벤트를 직접 설정</td>
</tr>
<tr>
<td>Capture 이벤트 수식어는 <code class="language-text">.passive</code>, <code class="language-text">.capture</code>, <code class="language-text">.once,</code> <code class="language-text">.capture.once</code>, <code class="language-text">.once.capture</code></td>
<td>&#x26;, !, ~, ~!</td>
</tr>
<tr>
<td>이벤트 수식어와 키 수식어: <code class="language-text">.stop</code>, <code class="language-text">.prevent</code>, <code class="language-text">.self</code>, keys(<code class="language-text">.enter</code>, <code class="language-text">.13</code>) and Modifiers Keys(<code class="language-text">.ctrl</code>, <code class="language-text">.alt</code>, <code class="language-text">.shift</code>, <code class="language-text">.meta</code>)</td>
<td>JavaScript로 해결, <code class="language-text">event.stopPropagation()</code>, <code class="language-text">event.preventDefault()</code>, <code class="language-text">if (event.target !== event.currentTarget) return</code>, <code class="language-text">if (event.keyCode !== 13) return</code>, <code class="language-text">if (!event.ctrlKey) return</code></td>
</tr>
<tr>
<td>슬롯 속성 활용</td>
<td>렌더 함수의 <code class="language-text">this.$slots</code>와 <code class="language-text">this.$scopedSlots</code> 활용</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="함수형-컴포넌트functional-component란" style="position:relative;"><a href="#%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8functional-component%EB%9E%80" aria-label="함수형 컴포넌트functional component란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수형 컴포넌트(Functional component)란?</h3>
<p>함수형 컴포넌트는 <code class="language-text">context</code>를 통해 전달받은 정보로만 생성되는 간단한 컴포넌트입니다.</p>
<ol>
<li><strong>상태 없음(Stateless):</strong> 즉 <code class="language-text">data</code>가 없습니다</li>
<li><strong>인스턴스 없음(Instanceless):</strong> 즉 <code class="language-text">this</code>가 없습니다</li>
</ol>
<p>이 경우, <code class="language-text">functional: true</code> 속성을 이용해 컴포넌트를 함수형으로 작성할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;my-component&#39;, {
  functional: true,
  // Props are optional
  props: {
    // ...
  },
  // To compensate for the lack of an instance,
  // we are now provided a 2nd context argument.
  render: function (createElement, context) {
    // ...
  }
})</code></pre></div>
</li>
<li>
<h3 id="vue와-react의-공통점은" style="position:relative;"><a href="#vue%EC%99%80-react%EC%9D%98-%EA%B3%B5%ED%86%B5%EC%A0%90%EC%9D%80" aria-label="vue와 react의 공통점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue와 React의 공통점은?</h3>
<ol>
<li>두 프레임워크 모두 <strong>가상 DOM</strong> 모델을 사용합니다.</li>
<li>반응적이고 조합 가능한 컴포넌트를 제공합니다.</li>
<li>코어 라이브러리에만 집중하고 있고, 라우팅 및 상태 관리와 같은 라이브러리가 부가적으로 있습니다.</li>
</ol>
</li>
<li>
<h3 id="vue와-react의-차이점은" style="position:relative;"><a href="#vue%EC%99%80-react%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80" aria-label="vue와 react의 차이점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue와 React의 차이점은?</h3>
<table>
<thead>
<tr>
<th>특징</th>
<th>Vue</th>
<th>React</th>
</tr>
</thead>
<tbody>
<tr>
<td>타입</td>
<td>JavaScript MVC 프레임워크</td>
<td>JavaScript 라이브러리</td>
</tr>
<tr>
<td>플랫폼</td>
<td>웹을 우선적으로</td>
<td>웹과 네이티브 모두</td>
</tr>
<tr>
<td>복잡도</td>
<td>상대적으로 간단</td>
<td>상대적으로 복잡</td>
</tr>
<tr>
<td>빌드 어플리케이션</td>
<td>Vue-cli</td>
<td>CRA (<code class="language-text">Create-React-App</code>)</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="vue가-react에-비해-나은-점은" style="position:relative;"><a href="#vue%EA%B0%80-react%EC%97%90-%EB%B9%84%ED%95%B4-%EB%82%98%EC%9D%80-%EC%A0%90%EC%9D%80" aria-label="vue가 react에 비해 나은 점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue가 React에 비해 나은 점은?</h3>
<ol>
<li>가볍고 빠릅니다.</li>
<li>템플릿이 개발 과정을 쉽게 만들어줍니다.</li>
<li>JSX에 비해 가벼운 JavaScript 문법을 사용합니다.</li>
</ol>
</li>
<li>
<h3 id="react가-vue에-비해-나은-점은" style="position:relative;"><a href="#react%EA%B0%80-vue%EC%97%90-%EB%B9%84%ED%95%B4-%EB%82%98%EC%9D%80-%EC%A0%90%EC%9D%80" aria-label="react가 vue에 비해 나은 점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React가 Vue에 비해 나은 점은?</h3>
<ol>
<li>큰 규모의 어플리케이션을 유연하게 만들 수 있습니다.</li>
<li>테스트가 쉽습니다.</li>
<li>모바일 앱 제작에도 적합합니다.</li>
<li>생태계가 크고 풍부합니다.</li>
</ol>
</li>
<li>
<h3 id="vue와-angularjs의-차이점은" style="position:relative;"><a href="#vue%EC%99%80-angularjs%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80" aria-label="vue와 angularjs의 차이점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue와 AngularJS의 차이점은?</h3>
<p>Vue의 개발 초기 단계에서 AngularJS를 참고했기 때문에, Vue와 AngularJS의 문법은 상당히 비슷합니다. 하지만 차이점 역시 존재합니다.</p>
<table>
<thead>
<tr>
<th>특징</th>
<th>Vue</th>
<th>AngularJS</th>
</tr>
</thead>
<tbody>
<tr>
<td>복잡도</td>
<td>배우기 쉬운 API와 디자인</td>
<td>프레임워크가 꽤 크고 타입스크립트 등의 지식 필요</td>
</tr>
<tr>
<td>데이터 바인딩</td>
<td>양방향 바인딩</td>
<td>단방향 바인딩</td>
</tr>
<tr>
<td>초기 릴리즈</td>
<td>2014</td>
<td>2016</td>
</tr>
<tr>
<td>모델</td>
<td>가상 DOM 기반</td>
<td>MVC</td>
</tr>
<tr>
<td>작성된 언어</td>
<td>JavaScript</td>
<td>TypeScript</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="동적-컴포넌트란" style="position:relative;"><a href="#%EB%8F%99%EC%A0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80" aria-label="동적 컴포넌트란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동적 컴포넌트란?</h3>
<p><code class="language-text">&lt;component&gt;</code> 태그에서 <code class="language-text">v-bind:is</code>로 바인딩된 컴포넌트를 동적으로 전환할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue({
  el: &#39;#app&#39;,
  data: {
    currentPage: &#39;home&#39;
  },
  components: {
    home: {
      template: &quot;&lt;p&gt;Home&lt;/p&gt;&quot;
    },
    about: {
      template: &quot;&lt;p&gt;About&lt;/p&gt;&quot;
    },
    contact: {
      template: &quot;&lt;p&gt;Contact&lt;/p&gt;&quot;
    }
  }
})</code></pre></div>
<p>이제 템플릿에서 <code class="language-text">&lt;component&gt;</code> 태그에 바인딩 될 컴포넌트를 설정할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;div id=&quot;app&quot;&gt;
   &lt;component v-bind:is=&quot;currentPage&quot;&gt;
       &lt;!-- component changes when currentPage changes! --&gt;
       &lt;!-- output: Home --&gt;
   &lt;/component&gt;
&lt;/div&gt;</code></pre></div>
</li>
<li>
<h3 id="keep-alive-태그란" style="position:relative;"><a href="#keep-alive-%ED%83%9C%EA%B7%B8%EB%9E%80" aria-label="keep alive 태그란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>keep-alive 태그란?</h3>
<p><code class="language-text">&lt;keep-alive&gt;</code>는 컴포넌트의 상태를 보존해서 재 렌더링을 막아주는 추상 컴포넌트입니다. 만약 동적인 컴포넌트를 <code class="language-text">&lt;keep-alive&gt;</code> 태그로 감싼다면, 컴포넌트 인스턴스를 없애지 않고 메모리에 유지해 보존합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- Inactive components will be cached! --&gt;
&lt;keep-alive&gt;
  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;</code></pre></div>
<p>만약 조건문이 있다면, 해당 조건의 하위 컴포넌트만 렌더링됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;!-- multiple conditional children --&gt;
&lt;keep-alive&gt;
  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;
  &lt;comp-b v-else&gt;&lt;/comp-b&gt;
&lt;/keep-alive&gt;</code></pre></div>
<p><strong>Note:</strong> <code class="language-text">&lt;keep-alive&gt;</code>는 DOM에 렌더링 되지 않습니다.</p>
</li>
<li>
<h3 id="비동기-컴포넌트async-component란" style="position:relative;"><a href="#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8async-component%EB%9E%80" aria-label="비동기 컴포넌트async component란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비동기 컴포넌트(Async component)란?</h3>
<p>대규모 응용 프로그램에서는 응용 프로그램을 더 작은 덩어리로 나누고 실제로 필요할 때만 서버에서 컴포넌트를 로드해야 할 수도 있습니다. Vue를 사용하면 컴포넌트 정의를 비동기식으로 해결하는 팩토리 함수로 컴포넌트를 정의 할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;async-webpack-example&#39;, function (resolve, reject) {
  // Webpack automatically split your built code into bundles which are loaded over Ajax requests.
  require([&#39;./my-async-component&#39;], resolve)
})</code></pre></div>
<p>Vue는 Vue는 컴포넌트가 렌더링되어야 할 때만 팩토리 함수를 실행시키고, 이후의 나중에 있을 리렌더링을 위해 결과를 캐시합니다.</p>
</li>
<li>
<h3 id="비동기-컴포넌트-팩토리-패턴이란" style="position:relative;"><a href="#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80" aria-label="비동기 컴포넌트 팩토리 패턴이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비동기 컴포넌트 팩토리 패턴이란?</h3>
<p>비동기 컴포넌트 팩토리는 다음 형태의 객체를 반환할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const AsyncComponent = () =&gt; ({
  // The component to load (should be a Promise)
  component: import(&#39;./MyComponent.vue&#39;),
  // A component to use while the async component is loading
  loading: LoadingComponent,
  // A component to use if the load fails
  error: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000
})</code></pre></div>
</li>
<li>
<h3 id="인라인-템플릿inline-templates이란" style="position:relative;"><a href="#%EC%9D%B8%EB%9D%BC%EC%9D%B8-%ED%85%9C%ED%94%8C%EB%A6%BFinline-templates%EC%9D%B4%EB%9E%80" aria-label="인라인 템플릿inline templates이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>인라인 템플릿(inline templates)이란?</h3>
<p>하위 컴포넌트에 <code class="language-text">inline-template</code> 속성이 존재할 때, 컴포넌트는 내부 컨텐츠를 템플릿으로 사용합니다. 따라서 보다 유연한 템플릿 작성이 가능합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;my-component inline-template&gt;
   &lt;div&gt;
       &lt;h1&gt;Inline templates&lt;/p&gt;
       &lt;p&gt;Treated as component component owne content&lt;/p&gt;
   &lt;/div&gt;
&lt;/my-component&gt;</code></pre></div>
<p><strong>Note:</strong> <code class="language-text">inline-template</code>은 템플릿의 범위를 추론하기 어렵게 만듭니다. 가장 좋은 방법은 <code class="language-text">template</code> 옵션을 사용하거나 <code class="language-text">.vue</code> 파일의 <code class="language-text">template</code> 엘리먼트를 사용하여 컴포넌트 내부에 템플릿을 정의하는 것입니다.</p>
</li>
<li>
<h3 id="x-templates이란" style="position:relative;"><a href="#x-templates%EC%9D%B4%EB%9E%80" aria-label="x templates이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>X-Templates이란?</h3>
<p>템플릿를 정의하는 또 다른 방법은 <code class="language-text">text/x-template</code> 유형의 스크립트 엘리먼트 내부의 ID로 템플릿을 참조하는 것입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;script type=&quot;text/x-template&quot; id=&quot;script-template&quot;&gt;
  &lt;p&gt;Welcome to X-Template feature&lt;/p&gt;
&lt;/script&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;x-template-example&#39;, {
  template: &#39;#script-template&#39;
})</code></pre></div>
</li>
<li>
<h3 id="재귀-컴포넌트recursive-components란" style="position:relative;"><a href="#%EC%9E%AC%EA%B7%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8recursive-components%EB%9E%80" aria-label="재귀 컴포넌트recursive components란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>재귀 컴포넌트(recursive components)란?</h3>
<p>컴포넌트는 자신의 템플릿에서 자기 자신을 재귀적으로 호출할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;recursive-component&#39;, {
  template: `&lt;!--Invoking myself!--&gt;
             &lt;recursive-component&gt;&lt;/recursive-component&gt;`
});</code></pre></div>
<p>재귀 컴포넌트는 블로그의 덧글이나 메뉴처럼 상위 컴포넌트와 하위 컴포넌트가 동등한 기능을 할 때 유용합니다.</p>
<p><strong>Note:</strong> 위와 같은 컴포넌트는 최대 스택 크기 초과 오류가 발생하므로 재귀 호출이 조건부인지 확인해야 합니다.</p>
</li>
<li>
<h3 id="컴포넌트-사이의-순환-참조-해결-방법은" style="position:relative;"><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="컴포넌트 사이의 순환 참조 해결 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴포넌트 사이의 순환 참조 해결 방법은?</h3>
<p>복잡한 어플리케이션에서 Vue 컴포넌트가 서로가 서로를 호출하고 있는 상황이 발생할 수 있습니다. 컴포넌트 A와 컴포넌트 B가 서로 순환 참조를 하고 있는 상황을 살펴봅시다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">//ComponentA
&lt;div&gt;
  &lt;component-b &gt;
&lt;/div&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">//ComponentB
&lt;div&gt;
  &lt;component-b &gt;
&lt;/div&gt;</code></pre></div>
<p>이런 경우는 <code class="language-text">beforeCreate</code> 라이프 사이클 훅 시점까지 기다렸다가 해당 컴포넌트를 등록하거나, 웹팩의 비동기 <code class="language-text">import</code>를 활용합니다.</p>
<p><strong>Solution1:</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">beforeCreate: function () {
 this.$options.components.componentB = require(&#39;./component-b.vue&#39;).default
}</code></pre></div>
<p><strong>Solution2:</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">components: {
 componentB: () =&gt; import(&#39;./component-b.vue&#39;)
}</code></pre></div>
</li>
<li>
<h3 id="csp-환경에서-vue-어플리케이션을-빌드하는-법은" style="position:relative;"><a href="#csp-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-vue-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%84-%EB%B9%8C%EB%93%9C%ED%95%98%EB%8A%94-%EB%B2%95%EC%9D%80" aria-label="csp 환경에서 vue 어플리케이션을 빌드하는 법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSP 환경에서 Vue 어플리케이션을 빌드하는 법은?</h3>
<p>Google 크롬 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를 적용하여 표현식을 평가하는 데 <code class="language-text">new Function()</code> 을 사용할 수 없습니다. 전체 빌드는 이 기능을 사용하여 템플릿을 컴파일하므로 이러한 환경에서는 사용할 수 없습니다.</p>
<p>반면 런타임 전용 빌드는 CSP와 완벽하게 호환됩니다. Webpack + vue-loader 또는 Browserify + vueify로 런타임 전용 빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 <code class="language-text">render</code> 함수로 미리 컴파일됩니다.</p>
</li>
<li>
<h3 id="전체-빌드와-런타임-빌드의-차이점은" style="position:relative;"><a href="#%EC%A0%84%EC%B2%B4-%EB%B9%8C%EB%93%9C%EC%99%80-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%B9%8C%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80" aria-label="전체 빌드와 런타임 빌드의 차이점은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>전체 빌드와 런타임 빌드의 차이점은?</h3>
<p><strong>1. 전체 빌드(Full):</strong> 컴파일러와 런타임 빌드를 동시에 포함합니다. 템플릿을 작성한 경우 필요합니다.</p>
<p><strong>2. 런타임 빌드(Runtime):</strong> Vue 인스턴스 생성과 <code class="language-text">render</code> 함수, 가상 돔을 포함하고 있지만 컴파일러 빌드를 포함하고 있지 않습니다.</p>
</li>
<li>
<h3 id="vue의-빌드-종류는" style="position:relative;"><a href="#vue%EC%9D%98-%EB%B9%8C%EB%93%9C-%EC%A2%85%EB%A5%98%EB%8A%94" aria-label="vue의 빌드 종류는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue의 빌드 종류는?</h3>
<table>
<thead>
<tr>
<th>타입</th>
<th>UMD</th>
<th>CommonJS</th>
<th>ES Module (for bundlers)</th>
<th>ES Module (for browsers)</th>
</tr>
</thead>
<tbody>
<tr>
<td>전체 빌드</td>
<td>vue.js</td>
<td>vue.common.js</td>
<td>vue.esm.js</td>
<td>vue.esm.browser.js</td>
</tr>
<tr>
<td>런타임 빌드</td>
<td>vue.runtime.js</td>
<td>vue.runtime.common.js</td>
<td>vue.runtime.esm.js</td>
<td>NA</td>
</tr>
<tr>
<td>전체 빌드 (배포 모드)</td>
<td>vue.min.js</td>
<td>NA</td>
<td>NA</td>
<td>vue.esm.browser.min.js</td>
</tr>
<tr>
<td>런타임 빌드 (배포 모드)</td>
<td>vue.runtime.min.js</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="웹팩에서-vue-설정을-하는-방법은" style="position:relative;"><a href="#%EC%9B%B9%ED%8C%A9%EC%97%90%EC%84%9C-vue-%EC%84%A4%EC%A0%95%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="웹팩에서 vue 설정을 하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>웹팩에서 Vue 설정을 하는 방법은?</h3>
<p><code class="language-text">alias</code>를 이용해 Vue를 설정할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">module.exports = {
  // ...
  resolve: {
    alias: {
      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39; // &#39;vue/dist/vue.common.js&#39; for webpack 1
    }
  }
}</code></pre></div>
</li>
<li>
<h3 id="vue-컴파일러의-목적은" style="position:relative;"><a href="#vue-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80" aria-label="vue 컴파일러의 목적은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue 컴파일러의 목적은?</h3>
<p>Vue는 컴파일러를 이용해 템플릿을 <code class="language-text">render</code> 함수로 변환합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// this requires the compiler
new Vue({
  template: &#39;&lt;div&gt;{{ message }}&lt;/div&gt;&#39;
})

// this does not
new Vue({
  render (h) {
    return h(&#39;div&#39;, this.message)
  }
})</code></pre></div>
</li>
<li>
<h3 id="devtool이란" style="position:relative;"><a href="#devtool%EC%9D%B4%EB%9E%80" aria-label="devtool이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DevTool이란?</h3>
<p>DevTool은 Vue 어플리케이션을 사용자 친화적인 인터페이스로 디버그 할 수 있게 도와주는 브라우저 확장 프로그램입니다.</p>
<p><img src="https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/DevTools.png" alt="img"></p>
<p><strong>Note:</strong> Vue 페이지가 배포 모드일 경우에는 DevTool로 디버그할 수 없습니다.</p>
</li>
<li>
<h3 id="vuejs의-브라우저-지원은" style="position:relative;"><a href="#vuejs%EC%9D%98-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90%EC%9D%80" aria-label="vuejs의 브라우저 지원은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>VueJS의 브라우저 지원은?</h3>
<p>ECMAScript5를 지원하는 브라우저에서 동작 가능합니다. IE8 이하의 브라우저에서는 지원하지 않습니다.</p>
</li>
<li>
<h3 id="cdn으로-vue를-사용하는-방법은" style="position:relative;"><a href="#cdn%EC%9C%BC%EB%A1%9C-vue%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="cdn으로 vue를 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CDN으로 Vue를 사용하는 방법은?</h3>
<p>Vue는 jsdelivr, unpkg, cdnjs에서 제공하는 CDN을 이용해서도 사용이 가능합니다. 일반적으로 초기 기획, 학습용으로 적합합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.js&quot;&gt;&lt;/script&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;script type=&quot;module&quot;&gt;
  import Vue from &#39;https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.esm.browser.js&#39;
&lt;/script&gt;</code></pre></div>
<p><strong>Note:</strong> 버전 정보를 지우면 항상 최신 버전을 가져옵니다.</p>
</li>
<li>
<h3 id="강제로-업데이트를-발생시키는-방법은" style="position:relative;"><a href="#%EA%B0%95%EC%A0%9C%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%A5%BC-%EB%B0%9C%EC%83%9D%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="강제로 업데이트를 발생시키는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>강제로 업데이트를 발생시키는 방법은?</h3>
<p>매우 드문 경우지만, 데이터가 변경되지 않았음에도 재 렌더링을 위해 강제로 업데이트를 발생시켜야 할 수도 있습니다. 이 경우 <code class="language-text">vm.$forceUpdate()</code> API 메소드를 이용할 수 있습니다.</p>
<p><strong>Note:</strong> 모든 하위 컴포넌트에는 영향이 미치지 않으며, 슬롯 그 자체가 삽입된 슬롯 자체 및 하위 컴포넌트에만 영향을 미칩니다.</p>
</li>
<li>
<h3 id="템플릿에서-once-지시자를-쓰는-이유는" style="position:relative;"><a href="#%ED%85%9C%ED%94%8C%EB%A6%BF%EC%97%90%EC%84%9C-once-%EC%A7%80%EC%8B%9C%EC%9E%90%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94" aria-label="템플릿에서 once 지시자를 쓰는 이유는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>템플릿에서 once 지시자를 쓰는 이유는?</h3>
<p>많은 양의 정적 컨텐츠를 렌더링 할 때, 성능 향상을 위해 엘리먼트 및 컴포넌트를 한번만 렌더링하는 용도로 사용합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.component(&#39;legal-terms&#39;, {
  template: `
    &lt;div v-once&gt;
      &lt;h1&gt;Legal Terms&lt;/h1&gt;
      ... a lot of static content goes here...
    &lt;/div&gt;
  `
})</code></pre></div>
<p><strong>Note:</strong> 정적 컨텐츠가 많아서 느려지는 일이 발생하지 않는 한, 과다하게 사용하지 않는 것이 좋습니다.</p>
</li>
<li>
<h3 id="루트-vue-인스턴스에-접근하는-방법은" style="position:relative;"><a href="#%EB%A3%A8%ED%8A%B8-vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="루트 vue 인스턴스에 접근하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>루트 Vue 인스턴스에 접근하는 방법은?</h3>
<p>루트 Vue 인스턴스(<code class="language-text">new Vue()</code>)는 <code class="language-text">$root</code> 속성을 이용해 접근할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// The root Vue instance
new Vue({
  data: {
    age: 26
  },
  computed: {
    fullName: function () { /* ... */ }
  },
  methods: {
    interest: function () { /* ... */ }
  }
})</code></pre></div>
<p>루트 인스턴스의 데이터와 메소드들을 하위 컴포넌트에서 아래와 같은 방법으로 접근할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Get root data
this.$root.age

// Set root data
this.$root.age = 29

// Access root computed properties
this.$root.fullName

// Call root methods
this.$root.interest()</code></pre></div>
<p>상태 관리를 위한 용도라면 Vuex를 사용하는 것이 낫습니다.</p>
</li>
<li>
<h3 id="vue를-사용하고-있는-기업들은" style="position:relative;"><a href="#vue%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EA%B8%B0%EC%97%85%EB%93%A4%EC%9D%80" aria-label="vue를 사용하고 있는 기업들은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue를 사용하고 있는 기업들은?</h3>
<p>아래는 Vue를 사용하고 있는 유명 기업들입니다.</p>
<ol>
<li>Facebook</li>
<li>Netflix</li>
<li>Adobe</li>
<li>Xiaomi</li>
<li>Alibaba</li>
<li>WizzAir</li>
<li>EuroNews</li>
<li>Laracasts</li>
<li>GitLab</li>
<li>Laracasts</li>
</ol>
</li>
<li>
<h3 id="rendererror-메소드의-목적은" style="position:relative;"><a href="#rendererror-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80" aria-label="rendererror 메소드의 목적은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>renderError 메소드의 목적은?</h3>
<p>기본 <code class="language-text">render</code> 함수가 렌더링 도중 에러가 발생하면, 대체되는 렌더링 결과를 제공합니다. <code class="language-text">renderError</code>의 두 번째 전달인자로 에러가 전달됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue({
  render (h) {
    throw new Error(&#39;An error&#39;)
  },
  renderError (h, err) {
    return h(&#39;div&#39;, { style: { color: &#39;red&#39; }}, err.stack)
  }
}).$mount(&#39;#app&#39;)</code></pre></div>
</li>
<li>
<h3 id="하위-컴포넌트에서-상위-컴포넌트로-직접-접근하는-방법은" style="position:relative;"><a href="#%ED%95%98%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%83%81%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EC%A7%81%EC%A0%91-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="하위 컴포넌트에서 상위 컴포넌트로 직접 접근하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>하위 컴포넌트에서 상위 컴포넌트로 직접 접근하는 방법은?</h3>
<p> 상위 컴포넌트에서는 하위 컴포넌트들을 <code class="language-text">$children</code> 배열로 참조하며, 하위 컴포넌트에서 상위 컴포넌트를 <code class="language-text">$parent</code> 속성으로 참조합니다.</p>
</li>
<li>
<h3 id="vuex란" style="position:relative;"><a href="#vuex%EB%9E%80" aria-label="vuex란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vuex란?</h3>
<p> Vuex는 Vue.js 애플리케이션을 위한 상태 관리 패턴 + 라이브러리(Flux에서 영감을 받은 애플리케이션 아키텍처)입니다. 예측 가능한 방식으로만 상태가 변경될 수 있도록 보장하는 규칙을 가지고 있는 애플리케이션의 모든 컴포넌트를 위한 중앙 집중식 저장소입니다.</p>
</li>
<li>
<h3 id="상태-관리-패턴의-주요-구성-요소는-무엇입니까" style="position:relative;"><a href="#%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C" aria-label="상태 관리 패턴의 주요 구성 요소는 무엇입니까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상태 관리 패턴의 주요 구성 요소는 무엇입니까?</h3>
<p> 상태 관리의 주요 구성요소는 상태 및 뷰, 액션입니다. 이러한 구성요소에 따른 패턴을 애플리케이션에서 상태 관리 패턴이라고 합니다. 아래에 자세한 구성 요소가 자세히 설명되어 있습니다.</p>
<ol>
<li><strong>상태</strong>는 앱을 구동시키는 원천입니다.</li>
<li><strong>뷰</strong>는 단지 상태의 선언적 매핑입니다.</li>
<li><strong>액션</strong>은 뷰에서 사용자 입력에 반응하여 상태가 변할 수 있도록 하는 방법입니다. 위의 3가지 구성요소와 함께 상태 관리 패턴을 따르는 카운터 예를 들어보겠습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">new Vue({
  // state
  data () {
    return {
      count: 0
    }
  },
  // view
  template: `
    &lt;div&gt;{{ count }}&lt;/div&gt;
  `,
  // actions
  methods: {
    increment () {
      this.count++
    }
  }
})</code></pre></div>
</li>
<li>
<h3 id="vuex에서-단방향-데이터-흐름-모델을-어떻게-표현합니까" style="position:relative;"><a href="#vuex%EC%97%90%EC%84%9C-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%91%9C%ED%98%84%ED%95%A9%EB%8B%88%EA%B9%8C" aria-label="vuex에서 단방향 데이터 흐름 모델을 어떻게 표현합니까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vuex에서 단방향 데이터 흐름 모델을 어떻게 표현합니까?</h3>
<p> Vue.js는 props 속성을 통해 단방향 데이터 흐름 모델을 표현합니다. vuex에서 이와 동일한 개념은 아래와 같이 나타낼 수 있습니다.</p>
<p> <img src="https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/flow.png" alt="img"></p>
</li>
<li>
<h3 id="vuejs-loader는-무엇입니까" style="position:relative;"><a href="#vuejs-loader%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C" aria-label="vuejs loader는 무엇입니까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vuejs loader는 무엇입니까?</h3>
<p> Vue loader는 Vue 컴포넌트를 싱글 파일 컴포넌트(SFC, SFCs)라고 하는 형식으로 작성할 수 있는 웹팩용 로더입니다. 예를 들어 <code class="language-text">HelloWorld</code> 라는 SFC를 작성하면 아래와 같습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
  &lt;div class=&quot;greeting&quot;&gt;{{ message }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data () {
    return {
      message: &#39;Hello world for vueloader!&#39;
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
.greeting {
  color: blue;
}
&lt;/style&gt;</code></pre></div>
</li>
<li>
<h3 id="웹팩에서-vue-loader를-설정하는-방법은" style="position:relative;"><a href="#%EC%9B%B9%ED%8C%A9%EC%97%90%EC%84%9C-vue-loader%EB%A5%BC-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="웹팩에서 vue loader를 설정하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>웹팩에서 vue loader를 설정하는 방법은?</h3>
<p> <code class="language-text">Vue-Loader</code>의 설정은 웹팩 설정에 Vue Loader의 플러그인을 추가하기 때문에 다른 로더와는 약간 다릅니다. Vue 로더 플러그인은 정의된 다른 규칙(js 및 css 규칙)을 복제하여 <code class="language-text">.vue</code> 파일에서 해당 언어 블록(<code class="language-text">script</code> 및 <code class="language-text">style</code>)에 적용하기 위해 필요합니다. Vue 로더에 대한 웹팩 구성의 간단한 예는 다음과 같습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)

module.exports = {
  mode: &#39;development&#39;,
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      },
      // this will apply to both plain `.js` files and `&lt;script&gt;` blocks in `.vue` files
      {
        test: /\.js$/,
        loader: &#39;babel-loader&#39;
      },
      // this will apply to both plain `.css` files and `&lt;style&gt;` blocks in `.vue` files
      {
        test: /\.css$/,
        use: [
          &#39;vue-style-loader&#39;,
          &#39;css-loader&#39;
        ]
      }
    ]
  },
  plugins: [
    // make sure to include the plugin for cloning and mapping them to respective language blocks
    new VueLoaderPlugin()
  ]
}</code></pre></div>
</li>
<li>
<h3 id="vue-loader의-asset-url-핸들링-규칙은" style="position:relative;"><a href="#vue-loader%EC%9D%98-asset-url-%ED%95%B8%EB%93%A4%EB%A7%81-%EA%B7%9C%EC%B9%99%EC%9D%80" aria-label="vue loader의 asset url 핸들링 규칙은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vue-loader의 Asset URL 핸들링 규칙은?</h3>
<ol>
<li><strong>절대 경로(Absolute path)</strong>: 만약 URL 경로가 <code class="language-text">/images/loader.png</code>와 같은 절대 경로라면 그대로 보존됩니다.</li>
<li><strong>상대 경로(Relative path)</strong>: 만약 URL 경로가 <code class="language-text">./images/loader.png</code>와 같은 절대 경로라면 상대 모듈 요청(<code class="language-text">require(./images/loader.png)</code>)으로 컴파일되고 파일 시스템의 폴더 구조를 기반으로 해결됩니다.</li>
<li><strong>~로 시작하는 경로(URLs starts with ~ symbol)</strong>: 만약 URL 경로가 <code class="language-text">./some-node-package/loader.png</code>와 같은 <code class="language-text">~</code>로 시작된다면, 모듈 요청으로 컴파일됩니다.</li>
<li><strong>@로 시작하는 경로(URLs starts with @ symbol)</strong>: 만약 URL 경로가 <code class="language-text">@</code>로 시작된다면, 모듈 요청으로 컴파일됩니다. 이것은 웹팩 <code class="language-text">config</code>에 <code class="language-text">@</code>에 대한 별칭이 있는 경우에 유용하며, 기본적으로 <code class="language-text">vue-cli</code>가 만든 모든 프로젝트에서 <code class="language-text">/src</code>를 가리킵니다.</li>
</ol>
</li>
<li>
<h3 id="vue-loader에서-전처리기를-사용하는-경우라면" style="position:relative;"><a href="#vue-loader%EC%97%90%EC%84%9C-%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EB%9D%BC%EB%A9%B4" aria-label="vue loader에서 전처리기를 사용하는 경우라면 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vue loader에서 전처리기를 사용하는 경우라면?</h3>
<p> <code class="language-text">Vue-loader</code>는 작성된 언어 블록의 <code class="language-text">lang</code> 속성을 이용해 적절한 로더를 적용하고 웹팩 설정에 적용된 규칙을 따릅니다. <code class="language-text">Vue-loader</code>에서 SASS, LESS, Stylus나 PostCSS 같은 전처리기를 사용할 수 있습니다.</p>
</li>
<li>
<h3 id="범위-cssscoped-css란" style="position:relative;"><a href="#%EB%B2%94%EC%9C%84-cssscoped-css%EB%9E%80" aria-label="범위 cssscoped css란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>범위 CSS(Scoped CSS)란?</h3>
<p> 범위를 가지는 CSS(Scoped CSS)는 Vue에서 싱글 파일 컴포넌트에서 해당 컴포넌트에 작성된 CSS가 다른 컴포넌트에 영향을 미치지 않도록 그 적용 범위를 제한하는 것을 의미합니다. 즉, <code class="language-text">&lt;style&gt;</code> 태그가 <code class="language-text">scoped</code> 속성을 가지고 있다면, 해당 CSS는 해당 컴포넌트에서만 영향을 미칩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;style scoped&gt;
.greeting {
  color: green;
}
&lt;/style&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
  &lt;div class=&quot;greeting&quot;&gt;Let&#39;s start Scoped CSS&lt;/div&gt;
&lt;/template&gt;</code></pre></div>
<p> 위의 코드는 아래로 변환됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> &lt;style scoped&gt;
 .greeting[data-v-f3f3eg9] {
   color: green;
 }
 &lt;/style&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
  &lt;div class=&quot;greeting&quot; data-v-f3f3eg9&gt;Let&#39;s start Scoped CSS&lt;/div&gt;
&lt;/template&gt;</code></pre></div>
</li>
<li>
<h3 id="범위-css와-전역-css를-함께-쓸-수-있을까" style="position:relative;"><a href="#%EB%B2%94%EC%9C%84-css%EC%99%80-%EC%A0%84%EC%97%AD-css%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B8-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C" aria-label="범위 css와 전역 css를 함께 쓸 수 있을까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>범위 CSS와 전역 CSS를 함께 쓸 수 있을까?</h3>
<p> 범위가 지정된 스타일과 범위가 지정되지 않은 스타일은 동일한 컴포넌트에 포함할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;style&gt;
/* global styles */
&lt;/style&gt;

&lt;style scoped&gt;
/* local styles */
&lt;/style&gt;</code></pre></div>
</li>
<li>
<h3 id="범위-css가-자식-컴포넌트에-영향을-미치게-하는-방법은" style="position:relative;"><a href="#%EB%B2%94%EC%9C%84-css%EA%B0%80-%EC%9E%90%EC%8B%9D-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EB%AF%B8%EC%B9%98%EA%B2%8C-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="범위 css가 자식 컴포넌트에 영향을 미치게 하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>범위 CSS가 자식 컴포넌트에 영향을 미치게 하는 방법은?</h3>
<p> 범위가 지정된 CSS에서, 자식 컴포넌트에 영향을 미치게 하는 방법은 <code class="language-text">&gt;&gt;&gt;</code> 연산자를 사용하면 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;style scoped&gt;
.class1 &gt;&gt;&gt; .class2 { /* ... */ }
&lt;/style&gt;</code></pre></div>
<p> 위의 CSS는 아래로 컴파일됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">.class1[data-v-f3f3eg9] .class2 { /* ... */ }</code></pre></div>
<p> <strong>Note:</strong> SASS에서는 <code class="language-text">&gt;&gt;&gt;</code> 연산자가 제대로 작동하지 않을 수 있습니다. 이때는 <code class="language-text">/deep/</code> 또는 <code class="language-text">::v-deep</code> 선택자를 대신 이용합니다.</p>
</li>
<li>
<h3 id="상위-컴포넌트의-범위-css가-하위-컴포넌트에-영향을-주는가" style="position:relative;"><a href="#%EC%83%81%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%B2%94%EC%9C%84-css%EA%B0%80-%ED%95%98%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EB%8A%94%EA%B0%80" aria-label="상위 컴포넌트의 범위 css가 하위 컴포넌트에 영향을 주는가 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상위 컴포넌트의 범위 CSS가 하위 컴포넌트에 영향을 주는가?</h3>
<p> 일반적으로 상위 컴포넌트의 스타일은 하위 컴포넌트에 영향을 미치지 않습니다. 하지만 하위 컴포넌트의 루트 노드는 상위 컴포넌트와 하위 컴포넌트의 스타일에 모두 영향을 받습니다. 즉, 하위 컴포넌트의 루트 노드에 상위 컴포넌트에서 사용된 클래스가 사용된다면, 상위 컴포넌트의 스타일이 하위 컴포넌트에도 영향을 끼칩니다. 이는 상위 컴포넌트에서 레이아웃을 위해 하위 컴포넌트에 영향을 미칠 수 있도록 디자인된 것입니다. 아래의 예시는 상위 컴포넌트의 <code class="language-text">background</code>가 하위 컴포넌트에까지 영향을 미치는 예제입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// parent.vue
&lt;template&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;parent&lt;/p&gt;
    &lt;ChildMessageComponent/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ChildMessageComponent from &quot;./components/child&quot;;

export default {
  name: &quot;App&quot;,
  components: {
    ChildMessageComponent
  }
};
&lt;/script&gt;

&lt;style scoped&gt;
.wrapper {
  background: blue;
}
&lt;/style&gt;</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">//child.vue
&lt;template&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;p&gt;child&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &quot;Hello, Scoped CSS&quot;,
};
&lt;/script&gt;
&lt;style scoped&gt;
.wrapper {
  background: red;
}
&lt;/style&gt;</code></pre></div>
<p> 하위 컴포넌트의 <code class="language-text">wrapper</code> 클래스의 배경색은 빨간색이 아니라 파란색이 됩니다.</p>
</li>
<li>
<h3 id="동적으로-생성된-컨텐츠에-범위-css를-적용시키는-방법은" style="position:relative;"><a href="#%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%9C-%EC%BB%A8%ED%85%90%EC%B8%A0%EC%97%90-%EB%B2%94%EC%9C%84-css%EB%A5%BC-%EC%A0%81%EC%9A%A9%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="동적으로 생성된 컨텐츠에 범위 css를 적용시키는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동적으로 생성된 컨텐츠에 범위 CSS를 적용시키는 방법은?</h3>
<p> 범위 CSS는 <code class="language-text">v-html</code> 지시자로 동적으로 생성된 내용에 영향을 주지 않습니다. 이 경우, <code class="language-text">deep</code> 선택자를 통해 문제를 해결할 수 있습니다.</p>
</li>
<li>
<h3 id="vue에서-css-모듈을-사용할-수-있을까" style="position:relative;"><a href="#vue%EC%97%90%EC%84%9C-css-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C" aria-label="vue에서 css 모듈을 사용할 수 있을까 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue에서 CSS 모듈을 사용할 수 있을까?</h3>
<p> CSS 모듈은 CSS를 모듈화하고 구성하는데 널리 사용되는 시스템입니다. <code class="language-text">vue-loader</code>는 시뮬레이트된 범위 CSS의 대안으로 CSS 모듈과 함께 1급 클래스로의 통합을 제공합니다.</p>
</li>
<li>
<h3 id="모든-템플릿에-대해-런타임-빌드를-할-수-있는가" style="position:relative;"><a href="#%EB%AA%A8%EB%93%A0-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%97%90-%EB%8C%80%ED%95%B4-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%B9%8C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EA%B0%80" aria-label="모든 템플릿에 대해 런타임 빌드를 할 수 있는가 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>모든 템플릿에 대해 런타임 빌드를 할 수 있는가?</h3>
<p> 안 됩니다. Vue에서 사용되는 템플릿은 오직 <code class="language-text">.vue</code> 파일에서만 사용되며, 다른 경우라면 <code class="language-text">render</code> 함수가 필요합니다.</p>
</li>
<li>
<h3 id="vue에서-css-모듈을-사용하는-방법은" style="position:relative;"><a href="#vue%EC%97%90%EC%84%9C-css-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="vue에서 css 모듈을 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue에서 CSS 모듈을 사용하는 방법은?</h3>
<ol>
<li><strong>CSS 모듈 활성화:</strong> <code class="language-text">webpack.config.js</code>의 <code class="language-text">css-loader</code>에서 <code class="language-text">modules: true</code> 옵션을 활성화해줍니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
{
  module: {
    rules: [
      // ... other rules omitted
      {
        test: /\.css$/,
        use: [
          &#39;vue-style-loader&#39;,
          {
            loader: &#39;css-loader&#39;,
            options: {
              // enable CSS Modules
              modules: true,
              // customize generated class names
              localIdentName: &#39;[local]_[hash:base64:8]&#39;
            }
          }
        ]
      }
    ]
  }
}</code></pre></div>
<ol>
<li><strong>모듈 속성 추가:</strong> <code class="language-text">&lt;style&gt;</code> 태그에 <code class="language-text">module</code> 속성을 추가합니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;style module&gt;
.customStyle {
  background: blue;
}
&lt;/style&gt;</code></pre></div>
<ol>
<li><strong>CSS 모듈 주입:</strong> <code class="language-text">computed</code> 속성인 <code class="language-text">$style</code>을 통해 CSS 모듈을 객체로 접근할 수 있습니다.</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template&gt;
  &lt;div :class=&quot;$style.blue&quot;&gt;
    Background color should be in blue
  &lt;/p&gt;
&lt;/template&gt;</code></pre></div>
<p> <code class="language-text">:class</code>의 객체, 배열 문법에도 동작합니다.</p>
</li>
<li>
<h3 id="css-모듈을-전처리기에서-사용할-수-있는가" style="position:relative;"><a href="#css-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EA%B0%80" aria-label="css 모듈을 전처리기에서 사용할 수 있는가 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 모듈을 전처리기에서 사용할 수 있는가?</h3>
<p> CSS 모듈을 전처리기에서 사용할 수 있습니다. 예를 들어, Sass 전처리기는 웹팩에서 아래와 같이 설정할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js -&gt; module.rules
{
  test: /\.scss$/,
  use: [
    &#39;vue-style-loader&#39;,
    {
      loader: &#39;css-loader&#39;,
      options: { modules: true }
    },
    &#39;sass-loader&#39;
  ]
}</code></pre></div>
</li>
<li>
<h3 id="css-모듈에-사용자-정의의-이름을-사용할-수-있는가" style="position:relative;"><a href="#css-%EB%AA%A8%EB%93%88%EC%97%90-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EA%B0%80" aria-label="css 모듈에 사용자 정의의 이름을 사용할 수 있는가 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 모듈에 사용자 정의의 이름을 사용할 수 있는가?</h3>
<p> 주입된 CSS 모듈에 <code class="language-text">module</code> 속성을 부여해서, 모듈의 이름을 커스터마이징할 수 있습니다. <code class="language-text">*.vue</code> 파일에서 둘 이상의 <code class="language-text">&lt;style&gt;</code> 태그가 존재할 때, 스타일이 서로 덮어쓰지 않게 하는 데 유용합니다. 예를 들어, 아래와 같이 속성을 줄 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;style module=&quot;a&quot;&gt;
  /* identifiers injected as a */
&lt;/style&gt;

&lt;style module=&quot;b&quot;&gt;
  /* identifiers injected as b */
&lt;/style&gt;</code></pre></div>
</li>
<li>
<h3 id="핫-리로드hot-reload란" style="position:relative;"><a href="#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%93%9Chot-reload%EB%9E%80" aria-label="핫 리로드hot reload란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>핫 리로드(Hot Reload)란?</h3>
<p> 핫 리로드는 <code class="language-text">*.vue</code> 파일을 편집할 때 단순히 페이지를 다시 로드하는 것이 아닙니다. 핫 리로드 기능을 사용하면 <code class="language-text">*.vue</code> 파일을 편집할 때 해당 컴포넌트의 모든 인스턴스가 페이지를 리로딩하지 않고 변경됩니다. 심지어 앱의 현재 상태와 변경된 컴포넌트를 보존합니다. 이것은 템플릿 또는 컴포넌트의 스타일을 수정할 때 개발 환경이 크게 개선됩니다.</p>
</li>
<li>
<h3 id="핫-리로드가-비활성화-될-때는" style="position:relative;"><a href="#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%93%9C%EA%B0%80-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94-%EB%90%A0-%EB%95%8C%EB%8A%94" aria-label="핫 리로드가 비활성화 될 때는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>핫 리로드가 비활성화 될 때는?</h3>
<p> 핫 리로드는 아래의 상황에서는 비활성화 되어있습니다.</p>
<ol>
<li>웹팩의 <code class="language-text">target</code>이 <code class="language-text">node</code>일 때 (SSR)</li>
<li>웹팩이 코드를 minify할 때</li>
<li><code class="language-text">process.env.NODE_ENV === &#39;production&#39;</code>일 때</li>
</ol>
</li>
<li>
<h3 id="핫-리로드를-명시적으로-비활성화하는-방법은" style="position:relative;"><a href="#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%93%9C%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="핫 리로드를 명시적으로 비활성화하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>핫 리로드를 명시적으로 비활성화하는 방법은?</h3>
<p> <code class="language-text">hotReload: false</code> 옵션을 웹팩 로더에서 설정하면 됩니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">module: {
  rules: [
    {
      test: /\.vue$/,
      loader: &#39;vue-loader&#39;,
      options: {
        hotReload: false // disables Hot Reload
      }
    }
  ]
}</code></pre></div>
</li>
<li>
<h3 id="핫-리로드를-활성화하는-방법은" style="position:relative;"><a href="#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="핫 리로드를 활성화하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>핫 리로드를 활성화하는 방법은?</h3>
<p> <code class="language-text">vue-loader</code> 플러그인은 내부적으로 핫 리로드를 사용하고 있습니다. 만약 <code class="language-text">vue-cli</code>를 이용해 프로젝트를 시작했다면, 핫 리로드를 바로 사용할 수 있습니다. 만약 프로젝트를 직접 세팅했다면, <code class="language-text">webpack-dev-server --hot</code>옵션으로 프로젝트를 시작해 활성화 할 수 있습니다.</p>
</li>
<li>
<h3 id="핫-리로드에서-상태가-보존되는-규칙은" style="position:relative;"><a href="#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%93%9C%EC%97%90%EC%84%9C-%EC%83%81%ED%83%9C%EA%B0%80-%EB%B3%B4%EC%A1%B4%EB%90%98%EB%8A%94-%EA%B7%9C%EC%B9%99%EC%9D%80" aria-label="핫 리로드에서 상태가 보존되는 규칙은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>핫 리로드에서 상태가 보존되는 규칙은?</h3>
<ol>
<li>컴포넌트의 <code class="language-text">&lt;template&gt;</code>을 수정할 때, 수정된 컴포넌트는 모든 상태를 보존한 채로 다시 렌더링됩니다.</li>
<li>컴포넌트의 <code class="language-text">&lt;script&gt;</code>를 수정할 때, 수정된 컴포넌트는 해체(destroy) 된 후 다시 생성(re-create)됩니다.</li>
<li>컴포넌트의 <code class="language-text">&lt;style&gt;</code>을 수정할 때, 핫 리로드는 <code class="language-text">vue-style-loader</code>에 의해 실행되며 상태에 영향을 끼치지 않습니다.</li>
</ol>
</li>
<li>
<h3 id="vue-loader를-이용해-함수형-컴포넌트를-생성하는-방법은" style="position:relative;"><a href="#vue-loader%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="vue loader를 이용해 함수형 컴포넌트를 생성하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue loader를 이용해 함수형 컴포넌트를 생성하는 방법은?</h3>
<p> <code class="language-text">functional</code> 속성을 템플릿에 추가해 함수형 컴포넌트를 생성할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template functional&gt;
  &lt;div&gt;{{ props.msg }}&lt;/div&gt;
&lt;/template&gt;</code></pre></div>
</li>
<li>
<h3 id="함수형-컴포넌트에서-전역-속성에-접근하는-방법은" style="position:relative;"><a href="#%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%84%EC%97%AD-%EC%86%8D%EC%84%B1%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="함수형 컴포넌트에서 전역 속성에 접근하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수형 컴포넌트에서 전역 속성에 접근하는 방법은?</h3>
<p> <code class="language-text">Vue.prototype</code>에 전역으로 정의된 속성에 접근해야 한다면, <code class="language-text">parent</code> 속성을 이용해 접근할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;template functional&gt;
  &lt;div&gt;{{ parent.$someProperty }}&lt;/div&gt;
&lt;/template&gt;</code></pre></div>
</li>
<li>
<h3 id="vue에서-테스트-하는-방법은" style="position:relative;"><a href="#vue%EC%97%90%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="vue에서 테스트 하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue에서 테스트 하는 방법은?</h3>
<ol>
<li><strong>vue-cli:</strong> 유닛 테스트와 e2e 테스트 환경이 미리 설정되어 제공됩니다.</li>
<li><strong>직접 세팅:</strong> <code class="language-text">@vue/test-utils</code>에서 <code class="language-text">mocha-webpack</code>이나 <code class="language-text">jest</code>를 <code class="language-text">*.vue</code> 파일을 대상으로 직접 설정합니다.</li>
</ol>
</li>
<li>
<h3 id="css에-lint를-설정하는-방법은" style="position:relative;"><a href="#css%EC%97%90-lint%EB%A5%BC-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="css에 lint를 설정하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS에 Lint를 설정하는 방법은?</h3>
<p> Stylelint를 이용해 Vue의 싱글 파일 컴포넌트의 스타일 부분의 Lint를 설정할 수 있습니다. 특정 <code class="language-text">.vue</code> 파일의 Lint는 아래와 같이 실행합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">stylelint MyComponent.vue</code></pre></div>
<p> 다른 방법은 웹팩에서 <code class="language-text">stylelint-webpack-plugin</code>를 <code class="language-text">dev-dependency</code>로 설치하고, 웹팩 설정에서 아래와 같이 설정하는 방법입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
const StyleLintPlugin = require(&#39;stylelint-webpack-plugin&#39;);
module.exports = {
  // ... other options
  plugins: [
    new StyleLintPlugin({
      files: [&#39;**/*.{vue,htm,html,css,sss,less,scss,sass}&#39;],
    })
  ]
}</code></pre></div>
</li>
<li>
<h3 id="eslint-플러그인을-사용하는-방법은" style="position:relative;"><a href="#eslint-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80" aria-label="eslint 플러그인을 사용하는 방법은 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>eslint 플러그인을 사용하는 방법은?</h3>
<p> 공식 <code class="language-text">eslint-plugin-vue</code> 플러그인은 Vue의 싱글 파일 컴포넌트의 템플릿과 스크립트 부분에 대해 Lint를 제공합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// .eslintrc.js
module.exports = {
  extends: [
    &quot;plugin:vue/essential&quot;
  ]
}</code></pre></div>
<p> 특정 파일에 대한 Lint는 아래와 같이 실행할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">eslint --ext js,vue MyComponent.vue</code></pre></div>
</li>
<li>
<h3 id="eslint-loader를-사용하는-이유는" style="position:relative;"><a href="#eslint-loader%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94" aria-label="eslint loader를 사용하는 이유는 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>eslint-loader를 사용하는 이유는?</h3>
<p> <code class="language-text">eslint-loader</code>를 이용하면 개발 도중에 자동으로 <code class="language-text">*.vue</code> 파일들에 대해 Lint를 적용시킬 수 있습니다.</p>
<p> 우선 아래와 같이 NPM 모듈을 설치해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">npm install -D eslint eslint-loader</code></pre></div>
<p> 그 후 웹팩의 설정에 추가해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
module.exports = {
  // ... other options
  module: {
    rules: [
      {
        enforce: &#39;pre&#39;,
        test: /\.(js|vue)$/,
        loader: &#39;eslint-loader&#39;,
        exclude: /node_modules/
      }
    ]
  }
}</code></pre></div>
</li>
<li>
<h3 id="css-단일-파일-추출이란" style="position:relative;"><a href="#css-%EB%8B%A8%EC%9D%BC-%ED%8C%8C%EC%9D%BC-%EC%B6%94%EC%B6%9C%EC%9D%B4%EB%9E%80" aria-label="css 단일 파일 추출이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 단일 파일 추출이란?</h3>
<p> CSS 단일 파일 추출(CSS Extraction)은 모든 Vue 컴포넌트에서 사용된 CSS를 단일 CSS 파일로 추출하는 것을 의미합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">npm install -D mini-css-extract-plugin</code></pre></div>
<p> 그 후 웹팩의 설정에 추가해야 합니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
var MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)

module.exports = {
  // other options...
  module: {
    rules: [
      // ... other rules omitted
      {
        test: /\.css$/,
        use: [
          process.env.NODE_ENV !== &#39;production&#39;
            ? &#39;vue-style-loader&#39;
            : MiniCssExtractPlugin.loader,
          &#39;css-loader&#39;
        ]
      }
    ]
  },
  plugins: [
    // ... Vue Loader plugin omitted
    new MiniCssExtractPlugin({
      filename: &#39;style.css&#39;
    })
  ]
}</code></pre></div>
</li>
<li>
<h3 id="사용자-정의-블록이란" style="position:relative;"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EB%B8%94%EB%A1%9D%EC%9D%B4%EB%9E%80" aria-label="사용자 정의 블록이란 permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자 정의 블록이란?</h3>
<p> 사용자 정의 블록(Custom block)은 <code class="language-text">*.vue</code> 파일에서 사용할 수 있는 <code class="language-text">&lt;template&gt;</code>, <code class="language-text">&lt;script&gt;</code>, <code class="language-text">&lt;style&gt;</code> 태그 블록 이외의 블록을 정의하는 것을 말합니다. <code class="language-text">lang</code> 속성, 태그 이름, 웹팩 설정의 <code class="language-text">resourceQuery</code> 속성에 의해 정의할 수 있습니다. 아래 예시는 <code class="language-text">*.vue</code> 파일에서 <code class="language-text">&lt;message&gt;</code>로 정의된 태그를 찾는 방법입니다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">{
  module: {
    rules: [
      {
        resourceQuery: /blockType=message/,
        loader: &#39;loader-to-use&#39;
      }
    ]
  }
}</code></pre></div>
</li>
<li>
<h3 id="what-are-the-features-of-stylelint" style="position:relative;"><a href="#what-are-the-features-of-stylelint" aria-label="what are the features of stylelint permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are the features of stylelint?</h3>
<p> Below are the list of major stylelint features</p>
<ol>
<li>It has more than <strong>160 built-in rules</strong> to catch errors, apply limits and enforce stylistic conventions</li>
<li>Understands <strong>latest CSS syntax</strong> including custom properties and level 4 selectors</li>
<li>It <strong>extracts embedded styles</strong> from HTML, markdown and CSS-in-JS object &#x26; template literals</li>
<li>Parses <strong>CSS-like syntaxes</strong> like SCSS, Sass, Less and SugarSS</li>
<li>Supports <strong>Plugins</strong> for reusing community plugins and creating own plugins</li>
</ol>
</li>
<li>
<h3 id="what-are-the-principles-for-vuex-application-structure" style="position:relative;"><a href="#what-are-the-principles-for-vuex-application-structure" aria-label="what are the principles for vuex application structure permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are the principles for vuex application structure?</h3>
<p> Vuex enforces below rules to structure any application.</p>
<ol>
<li>Application-level state is centralized in the store.</li>
<li>The only way to mutate the state is by committing mutations, which are synchronous transactions.</li>
<li>Asynchronous logic should be encapsulated in, and can be composed with actions. The project structure for any non-trivial application would be as below,</li>
</ol>
<p> <img src="https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/vuex-app-structure.png" alt="img"></p>
</li>
<li>
<h3 id="is-vuex-supports-hot-reloading" style="position:relative;"><a href="#is-vuex-supports-hot-reloading" aria-label="is vuex supports hot reloading permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is Vuex supports hot reloading?</h3>
<p> Yes, Vuex supports hot-reloading for mutations, modules, actions and getters during development. You need to use either webpack’s hot module replacement API or browserify’s hot module replacement plugin.</p>
</li>
<li>
<h3 id="what-is-the-purpose-of-hotupdate-api-of-vuex-store" style="position:relative;"><a href="#what-is-the-purpose-of-hotupdate-api-of-vuex-store" aria-label="what is the purpose of hotupdate api of vuex store permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is the purpose of hotUpdate API of vuex store?</h3>
<p> The store.hotUpdate() API method is used for mutations and modules. For example, you need to configure vuex store as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// store.js
import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
import mutations from &#39;./mutations&#39;
import myModule from &#39;./modules/myModule&#39;

Vue.use(Vuex)

const state = { message: &quot;Welcome to hot reloading&quot; }

const store = new Vuex.Store({
  state,
  mutations,
  modules: {
    moduleA: myModule
  }
})

if (module.hot) {
  // accept actions and mutations as hot modules
  module.hot.accept([&#39;./mutations&#39;, &#39;./modules/newMyModule&#39;], () =&gt; {
    // Get the updated modules
    const newMutations = require(&#39;./mutations&#39;).default
    const newMyModule = require(&#39;./modules/myModule&#39;).default
    //swap in the new modules and mutations
    store.hotUpdate({
      mutations: newMutations,
      modules: {
        moduleA: newMyModule
      }
    })
  })
}</code></pre></div>
</li>
<li>
<h3 id="how-do-you-test-mutations" style="position:relative;"><a href="#how-do-you-test-mutations" aria-label="how do you test mutations permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you test mutations?</h3>
<p> Since mutations are just functions that completely rely on their arguments it will be easier to test. You need to keep mutations inside your store.js file and should also export the mutations as a named export apart from default export. Let’s take an example of increment mutations,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// mutations.js
export const mutations = {
  increment: state =&gt; state.counter++
}</code></pre></div>
<p> And test them using mocha and chai as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// mutations.spec.js
import { expect } from &#39;chai&#39;
import { mutations } from &#39;./store&#39;

// destructure assign `mutations`
const { increment } = mutations

describe(&#39;mutations&#39;, () =&gt; {
  it(&#39;INCREMENT&#39;, () =&gt; {
    // mock state
    const state = { counter: 10 }
    // apply mutation
    increment(state)
    // assert result
    expect(state.counter).to.equal(11)
  })
})</code></pre></div>
</li>
<li>
<h3 id="how-do-you-test-your-getters" style="position:relative;"><a href="#how-do-you-test-your-getters" aria-label="how do you test your getters permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you test your getters?</h3>
<p> It is easier to test getters similar to mutations. It is recommended to test these getters if they have complicated computation. Let’s take a simple todo filter as a getter</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// getters.js
export const getters = {
  filterTodos (state, status) {
    return state.todos.filter(todo =&gt; {
      return todo.status === status
    })
  }
}</code></pre></div>
<p> And the test case for above getter as follows,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// getters.spec.js
import { expect } from &#39;chai&#39;
import { getters } from &#39;./getters&#39;

describe(&#39;getters&#39;, () =&gt; {
  it(&#39;filteredTodos&#39;, () =&gt; {
    // mock state
    const state = {
      todos: [
        { id: 1, title: &#39;design&#39;, status: &#39;Completed&#39; },
        { id: 2, title: &#39;testing&#39;, status: &#39;InProgress&#39; },
        { id: 3, title: &#39;development&#39;, status: &#39;Completed&#39; }
      ]
    }
    // mock getter
    const filterStatus = &#39;Completed&#39;

    // get the result from the getter
    const result = getters.filterTodos(state, filterStatus)

    // assert the result
    expect(result).to.deep.equal([
      { id: 1, title: &#39;design&#39;, status: &#39;Completed&#39; },
      { id: 2, title: &#39;development&#39;, status: &#39;Completed&#39; }
    ])
  })
})</code></pre></div>
</li>
<li>
<h3 id="what-is-the-procedure-to-run-tests-in-node" style="position:relative;"><a href="#what-is-the-procedure-to-run-tests-in-node" aria-label="what is the procedure to run tests in node permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is the procedure to run tests in node?</h3>
<p> By proper mocking, you can bundle tests with webpack and run them on node without having depenceny on Browser API. It involves 2 steps,</p>
<ol>
<li><strong>Create webpack config:</strong> Create webpack config with proper .babelrc</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// webpack.config.js
module.exports = {
  entry: &#39;./test.js&#39;,
  output: {
    path: __dirname,
    filename: &#39;test-bundle.js&#39;
  },
  module: {
    loaders: [
      {
        test: /\.js$/,
        loader: &#39;babel-loader&#39;,
        exclude: /node_modules/
      }
    ]
  }
}</code></pre></div>
<ol>
<li>** Run testcases:** First you need to bundle and then run them using mocha as below,</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">webpack
mocha test-bundle.js</code></pre></div>
</li>
<li>
<h3 id="what-is-the-procedure-to-run-tests-in-browser" style="position:relative;"><a href="#what-is-the-procedure-to-run-tests-in-browser" aria-label="what is the procedure to run tests in browser permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is the procedure to run tests in browser?</h3>
<p> Below are the steps to run tests in real browser,</p>
<ol>
<li>Install <code class="language-text">mocha-loader</code>.</li>
<li>Configure webpack config entry point to ‘mocha-loader!babel-loader!./test.js’.</li>
<li>Start webpack-dev-server using the config.</li>
<li>Go to localhost:8080/webpack-dev-server/test-bundle to see the test result</li>
</ol>
</li>
<li>
<h3 id="what-is-the-purpose-of-strict-mode-in-vuex" style="position:relative;"><a href="#what-is-the-purpose-of-strict-mode-in-vuex" aria-label="what is the purpose of strict mode in vuex permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is the purpose of strict mode in vuex?</h3>
<p> In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. It make sure that all state mutations can be explicitly tracked by debugging tools. You can just enable this by passing <code class="language-text">strict: true</code> while creating the vuex store.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const store = new Vuex.Store({
  // ...
  strict: true
})</code></pre></div>
</li>
<li>
<h3 id="can-i-use-strict-mode-in-production-environment" style="position:relative;"><a href="#can-i-use-strict-mode-in-production-environment" aria-label="can i use strict mode in production environment permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Can I use strict mode in production environment?</h3>
<p> No, it is not recommended to use strict mode in production environment. Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations and it can be quite expensive when you perform large amount of mutations. i.e, It can impact performance if you enable in production mode. Hence it should be handled through build tools,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const store = new Vuex.Store({
  // ...
  strict: process.env.NODE_ENV !== &#39;production&#39;
})</code></pre></div>
</li>
<li>
<h3 id="what-is-vuex-plugin" style="position:relative;"><a href="#what-is-vuex-plugin" aria-label="what is vuex plugin permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is vuex plugin?</h3>
<p> The vuex plugin is an option hat exposes hooks for each mutation. It is a normal function that receives the store as the only argument. You can create your own plugin or use built-in plugins. The plugin skeleton would be as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const myPlugin = store =&gt; {
  // called when the store is initialized
  store.subscribe((mutation, state) =&gt; {
    // called after every mutation.
    // The mutation comes in the format of `{ type, payload }`.
  })
}</code></pre></div>
<p> After that plugin can be configured for plugins options as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const store = new Vuex.Store({
  // ...
  plugins: [myPlugin]
})</code></pre></div>
</li>
<li>
<h3 id="how-do-you-mutate-state-in-plugins" style="position:relative;"><a href="#how-do-you-mutate-state-in-plugins" aria-label="how do you mutate state in plugins permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you mutate state in plugins?</h3>
<p> Similar to components you can’t mutate state directly but they can trigger changes by by committing mutations. This way a plugin can be used to sync a data source to the store. For example, createWebSocketPlugin plugin is used to sync a websocket data source to the store.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">export default function createWebSocketPlugin (socket) {
  return store =&gt; {
    socket.on(&#39;data&#39;, data =&gt; {
      store.commit(&#39;receiveData&#39;, data)
    })
    store.subscribe(mutation =&gt; {
      if (mutation.type === &#39;UPDATE_DATA&#39;) {
        socket.emit(&#39;update&#39;, mutation.payload)
      }
    })
  }
}</code></pre></div>
<p> And then configure plugin in vuex store as below</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const plugin = createWebSocketPlugin(socket)

const store = new Vuex.Store({
  state,
  mutations,
  plugins: [plugin]
})</code></pre></div>
</li>
<li>
<h3 id="what-is-vuex-store" style="position:relative;"><a href="#what-is-vuex-store" aria-label="what is vuex store permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is vuex store?</h3>
<p> A Vuex “store” is basically a container that holds your application state. The store creation is pretty straightforward. Below are the list of instructions to use vuex in an increment application,</p>
<ol>
<li>Configure vuex in vuejs ecosystem</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import Vuex from &quot;vuex&quot;;
Vue.use(Vuex)</code></pre></div>
<ol>
<li>Provide an initial state object and some mutations</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Make sure to call Vue.use(Vuex) first if using a module system

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})</code></pre></div>
<ol>
<li>Trigger state change with commit and access state variables,</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.commit(&#39;increment&#39;)

console.log(store.state.count) // -&gt; 1</code></pre></div>
</li>
<li>
<h3 id="what-are-the-differences-of-vuex-store-and-plain-global-object" style="position:relative;"><a href="#what-are-the-differences-of-vuex-store-and-plain-global-object" aria-label="what are the differences of vuex store and plain global object permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are the differences of vuex store and plain global object?</h3>
<p> Below are the two major differences between vuex store and plain global object</p>
<ol>
<li><strong>Vuex stores are reactive:</strong> If the store’s state changes then vue components will reactively and efficiently get updated</li>
<li><strong>Cannot directly mutate the store’s state:</strong> The store’s state is changed by explicitly committing mutations to ensure that every state change leaves a track-able record for tooling purpose</li>
</ol>
</li>
<li>
<h3 id="what-is-the-reason-not-to-update-the-state-directly" style="position:relative;"><a href="#what-is-the-reason-not-to-update-the-state-directly" aria-label="what is the reason not to update the state directly permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is the reason not to update the state directly?</h3>
<p> We want to explicitly track application state in order to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging. So we need to commit a mutation instead of changing store’s state directly.</p>
</li>
<li>
<h3 id="what-is-single-state-tree" style="position:relative;"><a href="#what-is-single-state-tree" aria-label="what is single state tree permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Single state tree?</h3>
<p> Vuex’s single state tree is single object contains all your application level state and serves as the “single source of truth”. It does not conflict with modularity when you split state and mutations into sub modules.</p>
</li>
<li>
<h3 id="how-do-you-install-vuex" style="position:relative;"><a href="#how-do-you-install-vuex" aria-label="how do you install vuex permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you install vuex?</h3>
<p> You can install vuex using npm or yarn as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">npm install vuex --save
(or)
yarn add vuex</code></pre></div>
<p> In a module system, you must explicitly install Vuex via Vue.use()</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;

Vue.use(Vuex)</code></pre></div>
<p> (OR) You can also install it using CDN links such as unpkg.cpm which provides NPM-based CDN links. Just include vuex after Vue and it will install itself automatically.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;script src=&quot;https://unpkg.com/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/vuex.js&quot;&gt;&lt;/script&gt;</code></pre></div>
<p> <strong>Note:</strong> You can use a specific version/tag via URLs like <a href="https://unpkg.com/vuex@2.0.0" target="_blank" rel="nofollow noopener noreferrer">https://unpkg.com/vuex@2.0.0</a>. If you don’t mention any version then it will point to latest version.</p>
</li>
<li>
<h3 id="do-i-need-promise-for-vuex" style="position:relative;"><a href="#do-i-need-promise-for-vuex" aria-label="do i need promise for vuex permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Do I need promise for vuex?</h3>
<p> Yes, Vuex requires Promise. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as es6-promise using npm or yarn.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">npm install es6-promise --save # NPM
yarn add es6-promise # Yarn</code></pre></div>
<p> After that import into anywhere in your application,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import &#39;es6-promise/auto&#39;</code></pre></div>
</li>
<li>
<h3 id="how-do-you-display-store-state-in-vue-components" style="position:relative;"><a href="#how-do-you-display-store-state-in-vue-components" aria-label="how do you display store state in vue components permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you display store state in vue components?</h3>
<p> Since Vuex stores are reactive, you can retrieve” state from store by simply returning store’s state from within a computed property. i.e, Whenever store state changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates. Let’s take a hello word component which display store’s state in the template,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// let&#39;s create a hello world component
const Greeting = {
  template: `&lt;div&gt;{{ greet }}&lt;/div&gt;`,
  computed: {
    greet () {
      return store.state.msg
    }
  }
}</code></pre></div>
</li>
<li>
<h3 id="how-do-you-inject-store-into-child-components" style="position:relative;"><a href="#how-do-you-inject-store-into-child-components" aria-label="how do you inject store into child components permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you inject store into child components?</h3>
<p> Vuex provides a mechanism to “inject” the store into all child components from the root component with the store option. It will be enabled by vue.use(vuex). For example, let’s inject into our app component as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const app = new Vue({
  el: &#39;#app&#39;,
  // provide the store using the &quot;store&quot; option.
  // this will inject the store instance to all child components.
  store,
  components: { Greeting },
  template: `
    &lt;div class=&quot;app&quot;&gt;
      &lt;greeting&gt;&lt;/greeting&gt;
    &lt;/div&gt;
  `
})</code></pre></div>
<p> Now the store will be injected into all child components of the root and will be available on them as <strong>this.$store</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> // let&#39;s create a hello world component
     const Greeting = {
       template: `&lt;div&gt;{{ greet }}&lt;/div&gt;`,
       computed: {
         greet () {
           return this.$store.state.msg
         }
       }
     }</code></pre></div>
</li>
<li>
<h3 id="what-is-mapstate-helper" style="position:relative;"><a href="#what-is-mapstate-helper" aria-label="what is mapstate helper permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is mapState helper?</h3>
<p> In Vuex application, creating a computed property every time whenever we want to access the store’s state property or getter is going to be repetitive and verbose, especially if a component needs more than one state property. In this case, we can make use of the mapState helper of vuex which generates computed getter functions for us. Let’s take an increment example to demonstrate mapState helper,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// in full builds helpers are exposed as Vuex.mapState
import { mapState } from &#39;vuex&#39;

export default {
  // ...
  computed: mapState({
    // arrow functions can make the code very succinct!
    username: state =&gt; state.username,

    // passing the string value &#39;username&#39; is same as `state =&gt; state.username`
    usernameAlias: &#39;username&#39;,

    // to access local state with `this`, a normal function must be used
     greeting (state) {
      return this.localTitle + state.username
    }
  })
}</code></pre></div>
<p> We can also pass a string array to mapState when the name of a mapped computed property is the same as a state sub tree name</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">computed: mapState([
  // map this.username to store.state.username
  &#39;username&#39;
])</code></pre></div>
</li>
<li>
<h3 id="how-do-you-combine-local-computed-properties-with-mapstate-helper" style="position:relative;"><a href="#how-do-you-combine-local-computed-properties-with-mapstate-helper" aria-label="how do you combine local computed properties with mapstate helper permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you combine local computed properties with mapState helper?</h3>
<p> You can use object spread operator syntax in order to combine mapState helper(which returns an object) with other local computed properties. This way it simplify merging techniques using utilities.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">computed: {
  localComputed () { /* ... */ },
  // mix this into the outer object with the object spread operator
  ...mapState({
    // ...
  })
}</code></pre></div>
</li>
<li>
<h3 id="do-you-need-to-replace-entire-local-state-with-vuex" style="position:relative;"><a href="#do-you-need-to-replace-entire-local-state-with-vuex" aria-label="do you need to replace entire local state with vuex permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Do you need to replace entire local state with vuex?</h3>
<p> No, if a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. i.e, Eventhough vuex used in the application, it doesn’t mean that you need to keep all the local state in vuex store. Other the code becomes more verbose and indirect although it makes your state mutations more explicit and debuggable.</p>
</li>
<li>
<h3 id="what-are-vuex-getters" style="position:relative;"><a href="#what-are-vuex-getters" aria-label="what are vuex getters permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are vuex getters??</h3>
<p> Vuex getters acts as computed properties for stores to compute derived state based on store state. Similar to computed properties, a getter’s result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed. Let’s take a todo example which as completedTodos getter to find all completed todos,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: &#39;Vue course&#39;, completed: true },
      { id: 2, text: &#39;Vuex course&#39;, completed: false },
      { id: 2, text: &#39;Vue Router course&#39;, completed: true }
    ]
  },
  getters: {
    completedTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.completed)
    }
  }
})</code></pre></div>
<p> <strong>Note:</strong>Getters receive state as first argument.</p>
</li>
<li>
<h3 id="what-is-a-property-style-access" style="position:relative;"><a href="#what-is-a-property-style-access" aria-label="what is a property style access permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a property style access?</h3>
<p> You can access values of store’s getter object(store.getters) as properties. This is known as property style access. For example, you can access todo’s status as a property,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.getters.todosStatus</code></pre></div>
<p> The getters can be passed as 2nd argument for other getters. For example, you can derive completed todo’s count based on their status as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">getters: {
  completedTodosCount: (state, getters) =&gt; {
    return getters.todosStatus === &#39;completed&#39;
  }
}</code></pre></div>
<p> <strong>Note:</strong> The getters accessed as properties are cached as part of Vue’s reactivity system.</p>
</li>
<li>
<h3 id="what-is-a-method-style-access" style="position:relative;"><a href="#what-is-a-method-style-access" aria-label="what is a method style access permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a method style access?</h3>
<p> You can access store’s state in a method style by passing arguments. For example, you can pass user id to find user profile information as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">getters: {
  getUserProfileById: (state) =&gt; (id) =&gt; {
    return state.users.find(user =&gt; user.id === id)
  }
}</code></pre></div>
<p> After that you can access it as a method call,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.getters.getUserProfileById(111); {id: &#39;111&#39;, name: &#39;John&#39;, age: 33}</code></pre></div>
</li>
<li>
<h3 id="what-is-mapgetter-helper" style="position:relative;"><a href="#what-is-mapgetter-helper" aria-label="what is mapgetter helper permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is mapGetter helper??</h3>
<p> The mapGetters is a helper that simply maps store getters to local computed properties. For example, the usage of getters for todo app would be as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import { mapGetters } from &#39;vuex&#39;

export default {
  computed: {
    // mix the getters into computed with object spread operator
    ...mapGetters([
      &#39;completedTodos&#39;,
      &#39;todosCount&#39;,
      // ...
    ])
  }
}</code></pre></div>
</li>
<li>
<h3 id="what-are-mutations" style="position:relative;"><a href="#what-are-mutations" aria-label="what are mutations permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are mutations?</h3>
<p> Vuex mutations are similar to any events with a string <code class="language-text">type</code> and a <code class="language-text">handler</code>. The handler function is where we perform actual state modifications, and it will receive the state as the first argument. For example, the counter example with increment mutation would be as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      // mutate state
      state.count++
    }
  }
})</code></pre></div>
<p> You can’t directly invoke mutation instead you need to call <code class="language-text">store.commit</code> with its type. The above mutation would be triggered as folows</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.commit(&#39;increment&#39;)</code></pre></div>
</li>
<li>
<h3 id="how-do-you-commit-with-payload" style="position:relative;"><a href="#how-do-you-commit-with-payload" aria-label="how do you commit with payload permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you commit with payload?</h3>
<p> You can also pass <strong>payload</strong> for the mutation as an additional argument to <code class="language-text">store.commit</code>. For example, the counter mutation with payload object would be as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">mutations: {
  increment (state, payload) {
    state.count += payload.increment
  }
}</code></pre></div>
<p> And then you can trigger increment commit</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.commit(&#39;increment&#39;, {
  increment: 20
})</code></pre></div>
<p> <strong>Note:</strong> You can also pass primitives as payload.</p>
</li>
<li>
<h3 id="what-is-object-style-commit" style="position:relative;"><a href="#what-is-object-style-commit" aria-label="what is object style commit permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is object style commit?</h3>
<p> You can also commit a mutation is by directly using an object that has a <strong>type</strong> property.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">store.commit({
  type: &#39;increment&#39;,
  value: 20
})</code></pre></div>
<p> Now the entire object will be passed as the payload to mutation handlers(i.e, without any changes to handler signature).</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">mutations: {
  increment (state, payload) {
    state.count += payload.value
  }
}</code></pre></div>
</li>
<li>
<h3 id="what-are-the-caveats-with-vuex-mutations" style="position:relative;"><a href="#what-are-the-caveats-with-vuex-mutations" aria-label="what are the caveats with vuex mutations permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are the caveats with vuex mutations?</h3>
<p> Since a Vuex store’s state is made reactive by Vue, the same reactivity caveats of vue will apply to vuex mutations. These are the rules should be followed for vuex mutations,</p>
<ol>
<li>It is recommended to initialize store’s initial state with all desired fields upfront</li>
<li>Add new properties to state Object either by set method or object spread syntax</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Vue.set(stateObject, &#39;newProperty&#39;, &#39;John&#39;)</code></pre></div>
<p> (OR)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">state.stateObject = { ...state.stateObject, newProperty: &#39;John&#39; }</code></pre></div>
</li>
<li>
<h3 id="why-mutations-should-be-synchronous" style="position:relative;"><a href="#why-mutations-should-be-synchronous" aria-label="why mutations should be synchronous permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why mutations should be synchronous?</h3>
<p> You need to remember that mutation handler functions must be synchronous. This is why because any state mutation performed in the callback is essentially un-trackable. It is going to be problematic when the devtool will need to capture a “before” and “after” snapshots of the state during the mutations.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">mutations: {
  someMutation (state) {
    api.callAsyncMethod(() =&gt; {
      state.count++
    })
  }
}</code></pre></div>
</li>
<li>
<h3 id="how-do-you-perform-mutations-in-components" style="position:relative;"><a href="#how-do-you-perform-mutations-in-components" aria-label="how do you perform mutations in components permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you perform mutations in components?</h3>
<p> You can commit mutations in components with either <strong>this.$store.commit(‘mutation name’)</strong> or mapMutations helper to map component methods to <strong>store.commit</strong> calls. For example, the usage of mapMutations helper on counter example would be as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">import { mapMutations } from &#39;vuex&#39;

export default {
  methods: {
    ...mapMutations([
      &#39;increment&#39;, // map `this.increment()` to `this.$store.commit(&#39;increment&#39;)`

      // `mapMutations` also supports payloads:
      &#39;incrementBy&#39; // map `this.incrementBy(amount)` to `this.$store.commit(&#39;incrementBy&#39;, amount)`
    ]),
    ...mapMutations({
      add: &#39;increment&#39; // map `this.add()` to `this.$store.commit(&#39;increment&#39;)`
    })
  }
}</code></pre></div>
</li>
<li>
<h3 id="is-it-mandatory-to-use-constants-for-mutation-types" style="position:relative;"><a href="#is-it-mandatory-to-use-constants-for-mutation-types" aria-label="is it mandatory to use constants for mutation types permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is it mandatory to use constants for mutation types?</h3>
<p> No, it is not mandatory. But you might observed that State management implementations such Flux and Redux use constants for mutation types. This convention is just a preference and useful to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application. For example, the mutations can be declared as below,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// mutation-types.js
export const SOME_MUTATION = &#39;SOME_MUTATION&#39;</code></pre></div>
<p> And you can configure them in store as follows,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// store.js
import Vuex from &#39;vuex&#39;
import { SOME_MUTATION } from &#39;./mutation-types&#39;

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // ES2015 computed property name feature to use a constant as the function name
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})</code></pre></div>
</li>
<li>
<h3 id="how-do-you-perform-asynchronous-operations" style="position:relative;"><a href="#how-do-you-perform-asynchronous-operations" aria-label="how do you perform asynchronous operations permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How do you perform asynchronous operations?</h3>
<p> In Vuex, mutations are synchronous transactions. But if you want to handle asynchronous operations then you should use <strong>actions</strong>.</p>
</li>
<li>
<h3 id="what-are-differences-between-mutations-and-actions" style="position:relative;"><a href="#what-are-differences-between-mutations-and-actions" aria-label="what are differences between mutations and actions permalink" class="anchor-header before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are differences between mutations and actions?</h3>
<p> Actions are similar to mutations, but there are two main differences,</p>
<ol>
<li>Mutations perform mutations on the state, actions commit mutations.</li>
<li>Actions can contain arbitrary asynchronous operations unlike mutations.</li>
</ol>
</li>
</ol></div></div></div><div class="MuiGrid-root stickyvisible MuiGrid-item MuiGrid-grid-md-2 MuiGrid-grid-lg-2"><div class="styled__VisibleTable-sc-1hokm1n-10 hAenLH"></div></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><div class="style__CommentDiv-f1ulxg-6 iRLYFX"></div></div></div></main><footer><nav class="styled__FooterDiv-sc-1a50tl6-0 dmGmmo"><h6 class="text">Copyright © 2021 JIGGLOG  |  MADE BY 염동환  |  Nest.js, Gatsby, React, Redux, Docker, Aws ec2</h6></nav></footer></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/vue공부1일차/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-a62b28eb55c66165547c.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-7b6c7523be1d990f6e10.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx-29751da91c34d5595464.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-179c8c5887f9f9dd2a90.js"],"component---src-templates-categorized-list-jsx":["/component---src-templates-categorized-list-jsx-f2d596ed615c3b380332.js"],"component---src-templates-list-jsx":["/component---src-templates-list-jsx-5259317eb861abaf9105.js"],"component---src-templates-portfolio-jsx":["/component---src-templates-portfolio-jsx-66fdb425658dae5bda75.js"],"component---src-templates-portfolios-jsx":["/component---src-templates-portfolios-jsx-c6a8f1688496b4942030.js"],"component---src-templates-post-jsx":["/component---src-templates-post-jsx-dfab648e2dcf638ae7e0.js"],"component---src-templates-resume-jsx":["/component---src-templates-resume-jsx-f1b4f4be42c69a08f20a.js"],"component---src-templates-tagged-list-jsx":["/component---src-templates-tagged-list-jsx-f3acb7813b1cb9f3bce7.js"]};/*]]>*/</script><script src="/component---src-templates-post-jsx-dfab648e2dcf638ae7e0.js" async=""></script><script src="/c2c45664921f384cbb57e917886f75ed18a7c772-507cfa34282fddb19c00.js" async=""></script><script src="/73bb605ea3e8982cb7cb1d831bcb96853dcd1a75-8dc90ba7f3de59cbdfbd.js" async=""></script><script src="/468967d5554fbdfaa4755e6d87845426800be832-8d47232650e59cbb1969.js" async=""></script><script src="/7608a4a4e80a2d64cce96855cef341673398a342-88208b24539781f28490.js" async=""></script><script src="/0c428ae2-dcb1cda6f06718491f22.js" async=""></script><script src="/1bfc9850-111378d602944f040fd6.js" async=""></script><script src="/78e521c3-dc074188099d099a0295.js" async=""></script><script src="/fb7d5399-a04be0fcb814b11f1f30.js" async=""></script><script src="/545f34e4-699a489d72ce4efc69d8.js" async=""></script><script src="/styles-ae6d046c35c187471a06.js" async=""></script><script src="/app-a62b28eb55c66165547c.js" async=""></script><script src="/framework-ffd9c0bba7cdf399bad4.js" async=""></script><script src="/webpack-runtime-9a069dfb23f8443c2eef.js" async=""></script></body></html>