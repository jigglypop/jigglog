{"componentChunkName":"component---src-templates-markdown-tsx","path":"/markdown/우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기/","result":{"data":{"site":{"siteMetadata":{"title":"jigglog","author":"JIGGLYPOP","homepage":"https://jigglog.netlify.app"}},"post":{"id":"495cf3dd-6729-525a-abce-914195f97ce3","html":"<blockquote>\n<p>우아한 테크 캠프 4기 중 만들고 있는 우아한 리액트 연재글입니다</p>\n<p>다음 프로젝트는 <a href=\"https://github.com/jigglypop/woowa-react\">https://github.com/jigglypop/woowa-react</a> 에서 보실 수 있습니다.</p>\n</blockquote>\n<h1>1. 들어가기에 앞서</h1>\n<hr>\n<ul>\n<li>안녕하세요 이번에 우아한 테크 캠프 4기에 합류하게 된 염동환입니다. 우아한 테크 캠프 4기 합격 발표 이후 바로 시작해서 지금까지 바닐라로 리액트를 만들어보고자 혼자 고군분투하고 있습니다.</li>\n<li>그리고 첫 주 금요일 미니 세미나때 이 내용에 대해 발표를 했었고, 그 부분과 어떤 부분에서 어려움이 있었는지 기능별로 쭉 정리를 해보고자 합니다</li>\n</ul>\n<h2>1) 왜 만드는가</h2>\n<hr>\n<ul>\n<li>저는 리액트를 거의 1년여동안 써 오면서 막연하게 useState는 이렇게 동작하겠구나..하고 써왔고 원리에 대해서는 매우 무지하다는 것을 깨달았습니다.</li>\n<li>그리고 우아한 테크 캠프에서 공개된 커리큘럼을 보면 1달 정도는 리액트를 사용할 수 없는데, 그 동안 쓸 바닐라 자바스크립트를 좀 준비해 볼 겸, 공부를 할 겸 만들게 되었습니다</li>\n</ul>\n<h2>2) 어떻게 만드는가</h2>\n<ul>\n<li>우선 클래스형 리액트는 다양한 과제 테스트에서 사용해 보았고, 비교적 큰 어려움은 없었던 것 같습니다. 하지만 함수형 리액트는 몇배는 더 어려운 과정이라고 생각합니다. 그만큼 코드가 간결하기 때문입니다.</li>\n<li>리액트 함수형의 가장 큰 핵심은 훅이라고 생각합니다. 그리고 그 훅의 가장 핵심은 <code>클로저</code>입니다</li>\n</ul>\n<h2>3) 클로저</h2>\n<hr>\n<ul>\n<li>먼저 사전적 정의는 이렇습니다</li>\n</ul>\n<blockquote>\n<p>“A closure is the combination of a function and the lexical environment within which that function was declared.”\n클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.</p>\n<p>(MDN)</p>\n</blockquote>\n<ul>\n<li>공식적인 설명은 이렇습니다만...확실히 와닿지는 않는 개념입니다. 예제를 보겠습니다</li>\n</ul>\n<pre><code class=\"language-javascript\">const Redux = function () {\n  let count = 0;\n  return {\n    setCount() {\n      count++;\n      return count;\n    },\n    getCount() {\n      return count;\n    },\n  };\n};\nconst redux1 = new Redux();\nredux1.setCount();\nconst redux2 = new Redux();\nredux2.setCount();\nredux2.setCount();\n\n\nconsole.log(redux1.getCount());\nconsole.log(redux2.getCount());\n</code></pre>\n<ul>\n<li>다음과 같이 redux라는 함수를 따로따로 new 생성자로 생성해주었다고 합시다. setCount의 입장에서 보면 count는 이해할 수 없습니다. setCount 아무곳에서도 count가 선언된 곳을 찾을 수 없기 때문입니다.</li>\n<li>하지만 결론적으로 말하자면 count를 setCount에서 쓸 수 있습니다. 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수이기 때문입니다.</li>\n<li>그래서 count가 선언된 새로 생성된 redux1, 그리고 redux2의 환경에서 따로 setCount를 해 주었을 경우, 각각의 기억된 환경의 count를 추가합니다</li>\n<li>따라서 답은 <code>1, 2</code>입니다.</li>\n<li>그리고 리액트는 각각의 컴포넌트에서 useState를 해 줄 경우 각각 다른 상태를 모두 저장합니다. 모든 컴포넌트에 클로저를 잡아주면 useState를 사용할 수 있다는 말입니다.</li>\n</ul>\n<h1>2. 이제 만들어보자</h1>\n<ul>\n<li>오늘 만들 개략적인 파일 트리는 이렇습니다</li>\n</ul>\n<pre><code class=\"language-javascript\">// 리액트 실행부입니다. 이 부분만 우리가 건드릴 겁니다\nreact\n    // 클로저를 생성할 파일\n    ㄴ Closure.js\n    // uuid 만들기\n    ㄴ getID.js\n    // 앱 시작할 때\n    ㄴ initApp.js\n    // 전역 상태를 저장할 전역 클로저\n    ㄴ memo.js\n    // 핵심부. 훅 등이 들어있음\n    ㄴ react.js\n    // 정규표현식으로 jsx를 파싱할 곳\n    ㄴ tag.js\n// 사용자가 작성할 파일\nsrc\n    ㄴ [components]\n        ㄴ count.js\n        ㄴ word.js\n        ㄴ wordB.js\n    ㄴApp.js\n...\n// 인덱스 파일. 전역 클로저 시작부분입니다. 그리고 이 곳에 모듈을 등록해주어야 합니다.\nindex.js\n</code></pre>\n<ul>\n<li>이번 시간에는 react.js의 useState, useEffect만 볼겁니다.</li>\n<li>우선 가장 핵심부 react.js부터 보시죠</li>\n</ul>\n<h2>1) react.js</h2>\n<hr>\n<ul>\n<li>이 곳에서 useState, useEffect와 같은 핵심 처리가 이루어집니다.</li>\n<li>나중에 클로저로 감싸질 곳이고, global이라는 변수로 전역의 상태를 공유하고, i인덱스로 훅의 순서를 잡습니다. 또한 $target으로 자신의 부모 노드를 가리킵니다.</li>\n</ul>\n<pre><code class=\"language-javascript\">const React = function () {\n  // 클로저 내부(훅 인덱스, 루트 타겟)\n  let global = {\n    hooks: [],\n    callback: {}\n  };\n  let i = 0;\n  let $target = null;\n\n  // useState\n  function useState(state) {\n    // 훅에서 상태 찾기\n    const hooks = global.hooks;\n    const _state = global.hooks[i] || state;\n    hooks[i] = _state;\n    // setState(클로저 내의 클로저)\n    const setState = (function () {\n      // 내부 클로저 index 고정\n      let _i = i;\n      let target = $target;\n      return function (value) {\n        global.hooks[_i] = value;\n        // 리렌더링 함수로\n        rerender(global.Component, target, target, global.params);\n      };\n    })();\n    // 인덱스 늘리기\n    i++;\n    return [_state, setState];\n  }\n\n  // useEffect\n  function useEffect(cb, value) {\n    const hooks = global.hooks;\n    let _value = hooks[i];\n    let changed = true;\n    // value에서 변한 것이 있는지 찾음\n    if (_value) changed = value.some((d, i) => d !== _value[i]);\n    // 바뀌었으면 콜백 함수 글로벌에 push\n    if (changed) {\n      cb()\n    }\n    hooks[i] = value;\n    // 인덱스 늘리기\n    i++;\n  }\n  return {\n    render,\n    useState,\n    useEffect,\n  };\n};\n\nexport default React;\n</code></pre>\n<ul>\n<li>개략적으로 다음과 같이 됩니다.</li>\n</ul>\n<pre><code class=\"language-javascript\">  // 클로저 내부(훅 인덱스, 루트 타겟)\n  let global = {\n    hooks: [],\n  };\n  let i = 0;\n  let $target = null;\n</code></pre>\n<ul>\n<li>이 부분에서 global 내의 hooks를 정의합니다. 나중에 hook을 저장하고 여기에서 꺼내오게 됩니다</li>\n</ul>\n<pre><code class=\"language-javascript\">  // useState\n  function useState(state) {\n    // 훅에서 상태 찾기\n    const _state = global.hooks[i] || state;\n    global.hooks[i] = _state;\n    // setState(클로저 내의 클로저)\n    const setState = (function () {\n      // 내부 클로저 index 고정\n      let _i = i;\n      let target = $target;\n      return function (value) {\n        global.hooks[_i] = value;\n        // 리렌더링 함수로\n        rerender(global.Component, target, target, global.params);\n      };\n    })();\n    // 인덱스 늘리기\n    i++;\n    return [_state, setState];\n  }\n</code></pre>\n<ul>\n<li>useState입니다.</li>\n<li>처음 선언할 당시 useState는 초기값을 받습니다. 그리고 글로벌 내의 훅에서 현재 인덱스로 상태를 찾아온 뒤 있으면 그 값을 갱신하기 위해 _state를 global.hooks[i]로 하고 , 아니면 state(초기값)으로 합니다.</li>\n<li>setState는 클로저 내의 클로저입니다. setState는 클로저 내부에 target과 i를 고정시키고 호출될 시 global.hooks의 클로저 내부 지정된 인덱스 값을 갱신해주고 rerender링 해줍니다. </li>\n<li>마지막으로 다른 훅을 위해 인덱스를 늘려주고 state와 setState함수를 리턴해주고 마칩니다.</li>\n</ul>\n<pre><code class=\"language-javascript\">  // useEffect\n  function useEffect(cb, hook) {\n    // const hooks = global.hooks;\n    let _hook = global.hooks[i];\n    let changed = true;\n    // hook에서 변한 것이 있는지 찾음\n    if (_hook) {\n      changed = hook.some((h, i) => h !== _hook[i]);\n    }\n    // 바뀌었으면 콜백 함수 글로벌에 push\n    if (changed) {\n      memoset.setCallback(global.id, i, cb);\n    }\n    global.hooks[i] = hook;\n    // 인덱스 늘리기\n    i++;\n  }\n</code></pre>\n<ul>\n<li>useEffect입니다. 이 함수는 아시다시피 뒤에 배열로 바뀐 것을 추적할 값을 넣어줍니다. 빈 배열이면 그냥 초기 렌더링 이후에 실행되구요. </li>\n<li>value가 값들의 배열입니다. 호출될 시 훅이 변했을 시 호출됩니다.</li>\n</ul>\n<h2>어려웠던 점?</h2>\n<hr>\n<h3>리액트는 컴포넌트마다 클로저를 잡아준다</h3>\n<ul>\n<li>리액트는 컴포넌트 하나하나마다 모두 클로저가 있습니다.</li>\n<li>저도 그렇게 만들고자 노력했을 때 상당한 난관에 부딪혔습니다. </li>\n<li>훅을 잡아 준 상위 컴포넌트에서 재랜더링이 호출되어 자식 컴포넌트를 다시 랜더링할 당시 클로저가 삭제되어버렸기 때문입니다.</li>\n<li>이 부분은 트리구조를 다시 공부하면서 하나하나 자식부터 순회하면서 클로저를 복원시켜주면서 해결해야 했습니다. </li>\n<li>상당히 난이도가 있는 작업이었기 때문에 알고리즘을 다시 공부하면서 혼자 3일정도를 보고 해결해 왔던 것 같습니다.</li>\n</ul>\n<h3>this 바인딩과 컴포넌트별로 분리</h3>\n<ul>\n<li>리액트라는 객체를 거쳐서 빠져나온 컴포넌트 자식별로 리액트스럽게 분리시키고 싶었습니다</li>\n<li>하지만 그 부분에서 다시 반복되는 코드가 많이 들어가는 등의 문제가 있었습니다.</li>\n<li>그리고 하나하나가 제대로 분리되지 않는 문제점이 발생하였습니다.</li>\n<li>이 부분은 this의 명시적 바인딩 bind로 해결하였고, this의 개념을 다시 공부하는 계기가 되었습니다.</li>\n</ul>\n<h2>마무리</h2>\n<hr>\n<ul>\n<li>\n<p>대략적인 훅의 개념을 알아봤습니다. 진짜 리액트는 이것보다 더 복잡하고 잘 구현되어 있을 겁니다. </p>\n<p>부족하지만 리액트를 이해하기 위해서 구현해봤습니다. 다음에는 본격적인 렌더링을 구현해보겠습니다. </p>\n</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#1-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\">1. 들어가기에 앞서</a></p>\n<ul>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#1-%EC%99%9C-%EB%A7%8C%EB%93%9C%EB%8A%94%EA%B0%80\">1) 왜 만드는가</a></li>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#2-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94%EA%B0%80\">2) 어떻게 만드는가</a></li>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#3-%ED%81%B4%EB%A1%9C%EC%A0%80\">3) 클로저</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#2-%EC%9D%B4%EC%A0%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90\">2. 이제 만들어보자</a></p>\n<ul>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#1-reactjs\">1) react.js</a></li>\n<li>\n<p><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#%EC%96%B4%EB%A0%A4%EC%9B%A0%EB%8D%98-%EC%A0%90\">어려웠던 점?</a></p>\n<ul>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%8A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A7%88%EB%8B%A4-%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EC%9E%A1%EC%95%84%EC%A4%80%EB%8B%A4\">리액트는 컴포넌트마다 클로저를 잡아준다</a></li>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#this-%EB%B0%94%EC%9D%B8%EB%94%A9%EA%B3%BC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%B3%84%EB%A1%9C-%EB%B6%84%EB%A6%AC\">this 바인딩과 컴포넌트별로 분리</a></li>\n</ul>\n</li>\n<li><a href=\"/%EC%9A%B0%EC%95%84%ED%95%9C%20%ED%85%8C%ED%81%AC%20%EC%BA%A0%ED%94%84%204%EA%B8%B0%20-%20%EC%9A%B0%EC%95%84%ED%95%9C%20%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기","path":"/우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기/","images":["images/woowa.jpg"],"category":"우아한 리액트","tags":["우아한 테크 캠프","우아한 테크 캠프 4기","우아한 리액트","리액트"],"date":"2021-07-11T19:21:00000Z","components":null,"tweets":null,"summary":"우아한 테크 캠프 4기 - 우아한 리액트 만들기 - useState, useEffect 만들기"}}},"pageContext":{"match":"/우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기/"}}}