{"componentChunkName":"component---src-templates-markdown-tsx","path":"/markdown/자바스크립트 요점 정리 - this/","result":{"data":{"site":{"siteMetadata":{"title":"jigglog","author":"JIGGLYPOP","homepage":"https://jigglog.netlify.app"}},"post":{"id":"1435c79c-6574-5371-a370-247a22834a00","html":"<blockquote>\n<p>자바스크립트 요점 정리 - this 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요</p>\n</blockquote>\n<h1>this</h1>\n<hr>\n<h2>1) 개요</h2>\n<hr>\n<ul>\n<li>함수 내에서 함수 호출 컨텍스트(맥락)을 의미</li>\n<li>자바스크립트 런타임 시에 바인딩이 이루어지는 실행 컨텍스트 중 하나 </li>\n<li>해당 함수가 실행되는 동안에 사용할 수 있으며 함수 호출 부분에서 this가 가리키는 것이 무엇인지를 확인 가능</li>\n</ul>\n<h2>2) this의 상황별 용법</h2>\n<h3>(1) 전역 공간에서의 this</h3>\n<hr>\n<ul>\n<li>전역 공간에서의 this : 전역 객체</li>\n<li>브라우저 환경 : window</li>\n<li>node.js 환경 : global</li>\n<li>strict mode(엄격 모드)에서도 동일</li>\n</ul>\n<pre><code class=\"language-javascript\">'use strict';\nvar x = this;\nconsole.log(x); //Window\n</code></pre>\n<h3>(2) 메서드 호출 시 this</h3>\n<hr>\n<ul>\n<li>함수 : 자체적으로 독립적 기능 수행</li>\n<li>메서드 : 자신을 호출한 객체에 관한 동작 수행</li>\n</ul>\n<pre><code class=\"language-javascript\">// 함수\nconst func = function (x) {\n  console.log(this, x);\n};\n\nfunc(1);\n// Window {...}\n\n\n// 메서드\nconst obj = {\n  method: func,\n};\nobj.method(2);\n// { method: f } 2\n</code></pre>\n<ul>\n<li>함수 앞에 점이 있으면 메서드</li>\n</ul>\n<h4>1) 메서드 내부에서의 this</h4>\n<ul>\n<li>마지막 점 앞에 명시된 객체</li>\n</ul>\n<pre><code class=\"language-javascript\">const obj = {\n  methodA: function () {\n    console.log(this);\n  },\n  inner: {\n    methodB: function () {\n      console.log(this);\n    },\n  },\n};\n\nobj.methodA();\nobj[\"methodA\"]();\n// {\n//    methodA: [Function: methodA],\n//    inner: { methodB: [Function: methodB] }\n// }\n// obj 를 가리킴\nobj.inner.methodB();\nobj.inner[\"methodB\"]();\nobj[\"inner\"].methodB();\nobj[\"inner\"][\"methodB\"]();\n// { methodB: [Function: methodB] }\n// obj.inner 를 가리킴\n</code></pre>\n<h5>(2) 함수 안에서 쓴 this</h5>\n<ul>\n<li>함수 안에서 this는 함수의 주인에게 바인딩 </li>\n</ul>\n<pre><code class=\"language-javascript\">const obj1 = {\n  outer: function () {\n    console.log(this);\n    const innerFunc = function () {\n      console.log(this);\n    };\n    // (2) widow\n    innerFunc();\n\n    const obj2 = {\n      innerMethod: innerFunc,\n    };\n    // (3) obj2\n    obj2.innerMethod();\n  },\n};\n// (1) obj1\nobj1.outer();\n</code></pre>\n<pre><code class=\"language-javascript\">function myFunction() {\n  return this;\n}\nconsole.log(myFunction()); //Window\nvar num = 0;\nfunction addNum() {\n  this.num = 100;\n  num++;\n  \n  console.log(num); // 101\n  console.log(window.num); // 101\n  console.log(num === window.num); // true\n}\n \naddNum();\n\n//위 코드에서 this.num의 this는 window 객체를 가리킵니다.\n//따라서 num은 전역 변수를 가리키게 됩니다.\n</code></pre>\n<ul>\n<li>strict mode(엄격 모드)에서는 함수 내의 this에 디폴트 바인딩이 없기 때문에 undefined</li>\n</ul>\n<pre><code class=\"language-javascript\">\"use strict\";\nfunction myFunction() {\n  return this;\n}\nconsole.log(myFunction()); //undefined\n\"use strict\";\nvar num = 0;\nfunction addNum() {\n  this.num = 100; //ERROR! Cannot set property 'num' of undefined\n  num++;\n}\n \naddNum();\n\n// 따라서 this.num을 호출하면 undefined.num을 호출하는 것과 마찬가지기 때문에 에러가 납니다.\n</code></pre>\n<h5>(3) 메서드 안에서 쓴 this</h5>\n<ul>\n<li>메서드 호출 시 메서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩</li>\n</ul>\n<pre><code class=\"language-javascript\">var person = {\n  firstName: 'John',\n  lastName: 'Doe',\n  fullName: function () {\n    return this.firstName + ' ' + this.lastName;\n  },\n};\nperson.fullName(); //\"John Doe\"\n\nvar num = 0;\nfunction showNum() {\n  console.log(this.num);\n}\nshowNum(); //0\n \nvar obj = {\n  num: 200,\n  func: showNum,\n};\nobj.func(); //200\n</code></pre>\n<h5>(4) 이벤트 핸들러 안에서 쓴 this</h5>\n<ul>\n<li>이벤트를 받는 HTML 요소를 가리킴</li>\n</ul>\n<pre><code class=\"language-javascript\">var btn = document.querySelector('#btn')\nbtn.addEventListener('click', function () {\n  console.log(this); //#btn\n});\n</code></pre>\n<h5>(5) new 생성자 안에서 쓴 this</h5>\n<ul>\n<li>생성자 함수가 생성하는 객체로 this가 바인딩</li>\n</ul>\n<pre><code class=\"language-javascript\">function Person(name) {\n  this.name = name;\n}\nvar kim = new Person('kim');\nvar lee = new Person('lee');\nconsole.log(kim.name); //kim\nconsole.log(lee.name); //lee\n</code></pre>\n<ul>\n<li>new로 바인딩이 되지 않았을 때</li>\n</ul>\n<pre><code class=\"language-javascript\">var name = 'window';\nfunction Person(name) {\n  this.name = name;\n}\nvar kim = Person('kim');\nconsole.log(window.name); //kim\n</code></pre>\n<pre><code class=\"language-javascript\">var children = document.body.children; // HTMLCollection\n \nchildren.forEach(function (el) {\n  el.classList.add('on'); //ERROR! (children.forEach is not a function)\n});\nvar children = document.body.children; // HTMLCollection\n \nArray.from(children).forEach(function (el) {\n  el.classList.add('on'); \n});\n</code></pre>\n<h5>(6) 화살표 함수로 쓴 this</h5>\n<ul>\n<li>화살표 함수는 전역 컨텍스트에서 실행되더라도 this를 새로 정의하지 않고 바로 바깥 함수나 클래스의 this를 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">var Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n  this.say = function () {\n    console.log(this); // Person {name: \"Nana\", age: 28}\n \n    setTimeout(function () {\n      console.log(this); // Window\n      console.log(this.name + ' is ' + this.age + ' years old');\n    }, 100);\n  };\n};\nvar me = new Person('Nana', 28);\nme.say(); //global is undefined years old\n\n// --------------------------------------------------------------------\n// --------------------------------------------------------------------\n\n\nvar Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n  this.say = function () {\n    console.log(this); // Person {name: \"Nana\", age: 28}\n    setTimeout(() => {\n      console.log(this); // Person {name: \"Nana\", age: 28}\n      console.log(this.name + ' is ' + this.age + ' years old'); \n    }, 100);\n  };\n};\nvar me = new Person('Nana', 28); //Nana is 28 years old\n</code></pre>\n<h4>(1) 일반함수의 this와 화살표 함수의 this</h4>\n<ul>\n<li>내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴</li>\n<li>일반함수의 this는 window(전역) 을 가르키며,</li>\n<li>화살표 함수의 this는 언제나 상위스코프의 this를 가르킴</li>\n</ul>\n<h1>Call, Apply, Bind</h1>\n<h2>1) call</h2>\n<ul>\n<li>메서드의 호출 주체인 함수를 즉시 실행하도록 함</li>\n</ul>\n<pre><code class=\"language-javascript\">const func = function (a, b, c) {\n console.log(this.x, a, b, c);\n};\n\nfunc.call({ x: 1 }, 2, 3, 4);\n\n// 1 2 3 4\n</code></pre>\n<ul>\n<li>메서드를 그냥 호출하면 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정 가능</li>\n</ul>\n<pre><code class=\"language-javascript\">var obj = {\n  a: 1,\n  method: function (x, y) {\n    console.log(this.a, x, y);\n  },\n};\n\nobj.method(2, 3);\nobj.method.call({ a: 2 }, 2, 3);\n\n// 1 2 3 \n// 2 2 3\n</code></pre>\n<h5>(6) 명시적 바인딩을 한 this</h5>\n<ul>\n<li>apply() 와 call() 메서드는 Function Object에 기본적으로 정의된 메서드. 인자를 this로 만들어주는 기능</li>\n</ul>\n<pre><code class=\"language-javascript\">function whoisThis() {\n  console.log(this);\n}\nwhoisThis(); //window\nvar obj = {\n  x: 123,\n};\nwhoisThis.call(obj); //{x:123}\n</code></pre>\n<ul>\n<li>apply()에서 매개변수로 받은 첫 번째 값은 함수 내부에서 사용되는 this에 바인딩, 두 번째 값인 배열은 자신을 호출한 함수의 인자로 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">function Character(name, level) {\n  this.name = name;\n  this.level = level;\n}\n \nfunction Player(name, level, job) {\n  this.name = name;\n  this.level = level;\n  this.job = job;\n}\n</code></pre>\n<pre><code class=\"language-javascript\">function Character(name, level) {\n  this.name = name;\n  this.level = level;\n}\n \nfunction Player(name, level, job) {\n  Character.apply(this, [name, level]);\n  this.job = job;\n}\n \nvar me = new Player('Nana', 10, 'Magician');\n</code></pre>\n<ul>\n<li>call() :  인수 목록을 받음</li>\n<li>apply() : 인수 배열을 받음</li>\n</ul>\n<pre><code class=\"language-javascript\">function Character(name, level) {\n  this.name = name;\n  this.level = level;\n}\n \nfunction Player(name, level, job) {\n  Character.call(this, name, level);\n  this.job = job;\n}\n \nvar me = {};\nPlayer.call(me, 'nana', 10, 'Magician');\n</code></pre>\n<ul>\n<li>apply()나 call()은 보통 유사배열 객체에게 배열 메서드를 쓰고자 할 때 사용</li>\n<li>ex) arguments 객체는 함수에 전달된 인수를 Array 형태로 보여주지만 배열 메서드를 쓸 수가 없어서 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">function func(a, b, c) {\n  console.log(arguments);\n  arguments.push('hi!'); //ERROR! (arguments.push is not a function);\n}\n\nfunction func(a, b, c) {\n  var args = Array.prototype.slice.apply(arguments);\n  args.push('hi!');\n  console.dir(args);\n}\n \nfunc(1, 2, 3); // [ 1, 2, 3, 'hi!' ]\nvar list = {\n  0: 'Kim',\n  1: 'Lee',\n  2: 'Park',\n  length: 3,\n};\n \nArray.prototype.push.call(list, 'Choi');\nconsole.log(list);\n</code></pre>\n<ul>\n<li>Array.from : Array인자를 얕게 복사해 새로운 배열 생성</li>\n<li>암시적 바인딩에 의해 혼란스러운 문제를 해결하기 위해서 call이나 apply 같은 내장 유틸리티를 사용하여 명시적으로 바인딩</li>\n<li>\n<p>this를 바인딩하기 위한 방법</p>\n<ul>\n<li>Call : this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 하나씩 넘기는 것</li>\n<li>Apply : this를 바인딩하면서 함수를 호출하는 것, 두번째 인자가 배열</li>\n<li>Bind : 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// call\nconst obj1 = { name: \"Call\" };\nconst say1 = function (city) {\n  console.log(Hello, my name is ${this.name}, I live in ${city});\n};\nsay1.call(obj1, \"callcity\");\n\n// apply\nconst obj2 = { name: \"Apply\" };\nconst say2 = function (city) {\n  console.log(Hello, my name is ${this.name}, I live in ${city});\n};\nsay2.apply(obj2, [\"applycity\"]);\n\n// bind\nconst obj3 = { name: \"Bind\" };\nconst say3 = function (city) {\n  console.log(Hello, my name is ${this.name}, I live in ${city});\n};\nconst boundSay = say3.bind(obj3);\nboundSay(\"bindcity\");\n</code></pre>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#this\">this</a></p>\n<ul>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#1-%EA%B0%9C%EC%9A%94\">1) 개요</a></li>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#2-this%EC%9D%98-%EC%83%81%ED%99%A9%EB%B3%84-%EC%9A%A9%EB%B2%95\">2) this의 상황별 용법</a></p>\n<ul>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#1-%EC%A0%84%EC%97%AD-%EA%B3%B5%EA%B0%84%EC%97%90%EC%84%9C%EC%9D%98-this\">(1) 전역 공간에서의 this</a></li>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#2-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C-%EC%8B%9C-this\">(2) 메서드 호출 시 this</a></p>\n<ul>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#1-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\">1) 메서드 내부에서의 this</a></p>\n<ul>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#2-%ED%95%A8%EC%88%98-%EC%95%88%EC%97%90%EC%84%9C-%EC%93%B4-this\">(2) 함수 안에서 쓴 this</a></li>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#3-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%95%88%EC%97%90%EC%84%9C-%EC%93%B4-this\">(3) 메서드 안에서 쓴 this</a></li>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%95%88%EC%97%90%EC%84%9C-%EC%93%B4-this\">(4) 이벤트 핸들러 안에서 쓴 this</a></li>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#5-new-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EC%93%B4-this\">(5) new 생성자 안에서 쓴 this</a></li>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#6-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EB%A1%9C-%EC%93%B4-this\">(6) 화살표 함수로 쓴 this</a></li>\n</ul>\n</li>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#1-%EC%9D%BC%EB%B0%98%ED%95%A8%EC%88%98%EC%9D%98-this%EC%99%80-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%9D%98-this\">(1) 일반함수의 this와 화살표 함수의 this</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#call-apply-bind\">Call, Apply, Bind</a></p>\n<ul>\n<li>\n<p><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#1-call\">1) call</a></p>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9A%94%EC%A0%90%20%EC%A0%95%EB%A6%AC%20-%20this/#6-%EB%AA%85%EC%8B%9C%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%84-%ED%95%9C-this\">(6) 명시적 바인딩을 한 this</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"자바스크립트 요점 정리 - this","path":"/자바스크립트 요점 정리 - this/","images":["images/js.png"],"category":"자바스크립트","tags":["자바스크립트"],"date":"2021-04-07T01:00:00.000Z","components":null,"tweets":null,"summary":"자바스크립트 요점 정리 - this 파트"}}},"pageContext":{"match":"/자바스크립트 요점 정리 - this/"}}}