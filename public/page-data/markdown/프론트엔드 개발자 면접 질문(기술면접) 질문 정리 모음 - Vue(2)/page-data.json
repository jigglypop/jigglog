{"componentChunkName":"component---src-templates-markdown-tsx","path":"/markdown/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)/","result":{"data":{"site":{"siteMetadata":{"title":"jigglog","author":"JIGGLYPOP","homepage":"https://jigglog.netlify.app"}},"post":{"id":"16ca8146-1ec7-5ed3-b129-279c0bd1df4a","html":"<blockquote>\n<p>프론트 엔드 면접 질문용(Vue) 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요</p>\n</blockquote>\n<h2>플러그인</h2>\n<hr>\n<h4>1) 개요</h4>\n<ul>\n<li>일반적으로 전역 수준 기능을 Vue 어플리케이션에 추가</li>\n<li>전역 메소드 또는 속성 추가(<code>&#x3C;vue-custom-element></code>)</li>\n<li>하나 이상의 글로벌 에셋 추가(지시자, 필터, 트랜지션)</li>\n<li>전역 믹스인으로 컴포넌트 옵션(vuex)</li>\n<li><code>Vue.prototype</code>를 이용해 Vue에 인스턴스 메소드를 추가</li>\n<li>위의 기능과 함께 자체 API를 제공하는 라이브러리(vue-router)</li>\n</ul>\n<h4>2) 플러그인을 만드는 방법</h4>\n<ul>\n<li><code>install</code> 메소드를 정의. 이 메소드는 첫 번째 인자로 Vue 생성자와 외부에서 설정 가능한 옵션을 파라미터로 전달받음</li>\n</ul>\n<pre><code class=\"language-javascript\">MyPlugin.install = function (Vue, options) {\n  Vue.myGlobalMethod = function () {\n  }\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n    }\n    ...\n  })\n  Vue.mixin({\n    created: function () {\n    }\n    ...\n  })\n  Vue.prototype.$myMethod = function (methodOptions) {\n    ...\n  }\n}\n</code></pre>\n<h4>3) 사용법</h4>\n<ul>\n<li><code>Vue.use()</code> 전역 메소드를 호출하여 플러그인을 사용</li>\n<li>이 함수는 생성자 <code>new Vue()</code>로 Vue 인스턴스를 생성하기 전에 호출</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.use(MyPlugin)\n\nnew Vue({\n  //... options\n})\n</code></pre>\n<h2>믹스인</h2>\n<hr>\n<h4>1) 개요</h4>\n<ul>\n<li>Vue 컴포넌트에 재사용 가능한 기능을 배포하는 유연한 방법</li>\n<li>믹스인에 존재하는 기능들은 호출된 컴포넌트의 기능들과 합쳐짐</li>\n<li>모든 구성 요소 옵션을 포함 가능</li>\n<li>배열 형태로 사용 가능</li>\n</ul>\n<pre><code class=\"language-javascript\">const myMixin = {\n  created(){\n    console.log(\"Welcome to Mixins!\")\n  }\n}\nvar app = new Vue({\n  el: '#root',\n  mixins: [myMixin]\n})\n</code></pre>\n<h4>2) 전역 믹스인</h4>\n<ul>\n<li>Vue 어플리케이션의 모든 컴포넌트에 동일한 옵션이나 기능을 확장해 사용할 필요가 있을 때 사용</li>\n<li>모든 단일 Vue 인스턴스에 영향을 주기 때문에 적게 이용하고 신중하게 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">// 다음 전역 믹스인은 해당 Vue 인스턴스에서 각 컴포넌트가 생성될 때마다 `created` 훅에서 로그를 발생\nVue.mixin({\n   created(){\n     console.log(\"Write global mixins\")\n   }\n})\n\nnew Vue({\n  el: '#app'\n})\n</code></pre>\n<h4>3) CLI 환경에서 믹스인을 사용하는 법</h4>\n<ul>\n<li>Vue CLI를 사용한다면, 믹스인은 일반적으로 <code>/src/mixins</code> 디렉토리에서 <code>.js</code>파일로 작성</li>\n<li><code>export</code> 키워드로 외부에 내보낸다는 것을 선언해야 하며 사용할 Vue 컴포넌트에서 <code>import</code> 키워드로 불러올 수 있음</li>\n</ul>\n<h4>4) 믹스인의 옵션과 컴포넌트의 옵션의 충돌</h4>\n<ul>\n<li>믹스인과 컴포넌트에서 충돌하는 옵션이 있다면, 옵션은 몇 가지 방법을 통해 충돌하는 옵션을 병합</li>\n<li>data : 재귀적으로 병합하되, 충돌되는 속성은 컴포넌트의 데이터가 우선적</li>\n</ul>\n<pre><code class=\"language-javascript\">var mixin = {\n  data: function () {\n    return {\n      message: 'Hello, this is a Mixin'\n    }\n  }\n }\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: 'Hello, this is a Component'\n    }\n  },\n  created: function () {\n    console.log(this.$data); // => { message: \"Hello, this is a Component'\" }\n  }\n})\n</code></pre>\n<ul>\n<li>라이프사이클 훅 : 믹스인 함수가 먼저 실행되고, 그 다음에 컴포넌트의 함수가 실행</li>\n</ul>\n<pre><code class=\"language-javascript\">const myMixin = {\n  created(){\n    console.log(\"Called from Mixin\")\n  }\n}\n\nnew Vue({\n  el: '#root',\n  mixins:[myMixin],\n  created(){\n    console.log(\"Called from Component\")\n  }\n})\n\n//Called from Mixin\n//Called from Component\n</code></pre>\n<ul>\n<li>methods, components, directives : 재귀적으로 병합하되, 이러한 객체에 충돌하는 키가 있을 경우 컴포넌트의 옵션이 우선순위</li>\n</ul>\n<pre><code class=\"language-javascript\">var mixin = {\n  methods: {\n    firstName: function () {\n      console.log('John')\n    },\n    contact: function () {\n      console.log('+65 99898987')\n    }\n  }\n}\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    lastName: function () {\n      console.log('Murray')\n    },\n    contact: function () {\n      console.log('+91 893839389')\n    }\n  }\n})\nvm.firstName() // \"John\"\nvm.lastName() // \"Murray\"\nvm.contact() // \"+91 893839389\"\n</code></pre>\n<h4>3) 믹스인의 병합 방법 사용자 정의</h4>\n<ul>\n<li>Vue에서는 사용자 지정 옵션을 병합할 때 기본적으로 기존 값을 덮어는 방법을 이용합니다. </li>\n<li>만약 사용자 정의의 로직을 사용해 커스텀 옵션을 병합하려면,<code>Vue.config.optionMergeStrategies</code>에 함수를 추가할 필요가 있습니다.</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}\n</code></pre>\n<p>더 고급 예제는 Vuex의 1.x 병합 전략에서 확인하실 수 있습니다.</p>\n<pre><code>const merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n</code></pre>\n<h2>사용자 정의 지시자(Custom directive)</h2>\n<h4>1) 개요</h4>\n<ul>\n<li>DOM 엘리먼트에 부착할 수 있는 명령어</li>\n<li><code>v-</code>로 시작하는 문법을 사용해 Vue가 이 명령어를 인식할 수 있도록 해야함</li>\n<li>하위 수준의 DOM을 제어하기 위해 직접 접근해야 할 필요가 있을 때</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\n\n//\n&#x3C;input v-focus>\n</code></pre>\n<h4>2) 지시자 지역 등록</h4>\n<ul>\n<li>directives 옵션 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">directives: {\n  focus: {\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n\n&#x3C;input v-focus>\n</code></pre>\n<h4>3) 지시자의 라이프 사이클 훅</h4>\n<ul>\n<li>지시자 객체가 등록될 때 몇 개의 라이프 사이클 훅을 제공</li>\n<li><code>bind</code>: 지시자가 처음 엘리먼트에 부착될 때 한 번 호출</li>\n<li><code>inserted</code>: 지시자가 부착된 엘리먼트가 DOM에 삽입되었을 때 호출</li>\n<li><code>update</code>: 해당 엘리먼트가 업데이트 될 때 호출됩니다. 하지만 아직 하위 엘리먼트는 업데이트 되지 않은 상태</li>\n<li><code>componentUpdated</code>: 하위 컴포넌트까지 업데이트 된 상태일 때 호출</li>\n<li><code>unbind</code>: 지시자가 엘리먼트에서부터 삭제될 때 호출</li>\n</ul>\n<p><strong>Note:</strong> 위의 훅에서는 특정한 전달인자(Argument)를 받는다.</p>\n<ol>\n<li>\n<h3>디렉티브 훅의 전달인자는?</h3>\n<p>모든 훅에서는 전달인자로 <code>el</code>, <code>binding</code>와 <code>vnode</code>를 갖고 있습니다. 그와 함께, <strong>update</strong>와 <strong>componentUpdated</strong>훅에서는 새 값과 이전 값을 비교하기 위해 <code>oldVnode</code>를 추가적으로 갖고 있습니다.</p>\n<ol>\n<li><code>el</code>: 해당 지시자가 부착된 엘리먼트로, 이를 이용해 DOM을 조작할 수 있습니다.</li>\n<li>\n<pre><code>binding\n</code></pre>\n</li>\n</ol>\n<p>  : 아래의 속성을 가진 객체입니다.</p>\n<ol>\n<li><code>name</code>: 지시자의 이름으로, <code>v-</code> 접두사가 제거된 이름입니다.</li>\n<li><code>value</code>: 지시자에서 전달 받은 값입니다. 만약 <code>v-my-directive=\"1 + 1\"</code>라면 <code>2</code>가 됩니다.</li>\n<li><code>oldValue</code>: 이전 값으로, <code>update</code>와 <code>componentUpdated</code>훅에서만 사용할 수 있습니다. 이를 통해 값이 변경되었는지 아닌지를 확인할 수 있습니다.</li>\n<li><code>expression</code>: 문자열로 바인딩된 표현식입니다. 만약 <code>v-my-directive=\"1 + 1\"</code>라면 <code>\"1 + 1\"</code>이 됩니다..</li>\n<li><code>arg</code>: 지시자의 전달인자입니다. 만약 <code>v-my-directive:foo</code>라면 <code>\"foo\"</code>가 됩니다..</li>\n<li><code>modifiers</code>: 수식어가 포함된 객체입니다. 만약 <code>v-my-directive.foo.bar</code>라면 <code>{ foo: true, bar: true }</code>가 됩니다.</li>\n<li><code>vnode</code>: Vue의 컴파일러에 의해 생성된 가상 노드입니다.</li>\n<li><code>oldVnode</code>: 이 전의 가상 노드로, <code>update</code>와 <code>componentUpdated</code>훅에서만 사용할 수 있습니다.</li>\n</ol>\n<p><a href=\"https://github.com/sudheerj/vuejs-interview-questions/blob/master/images/custom-directives.svg\"><img src=\"https://github.com/sudheerj/vuejs-interview-questions/raw/master/images/custom-directives.svg\" alt=\"custom-directives\"></a></p>\n</li>\n<li>\n<h3>지시자에 여러 값들을 전달하는 방법은?</h3>\n<p>지시자는 유효한 자바스크립트 표현식은 모두 수용할 수 있습니다. 따라서 지사자에 여러 값들을 전달하려면, 자바스크립트 객체 리터럴을 이용해 전달할 수 있습니다.</p>\n<pre><code>&#x3C;div v-avatar=\"{ width: 500, height: 400, url: 'path/logo', text: 'Iron Man' }\">&#x3C;/div>\n</code></pre>\n<p>이제 <code>v-avatar</code> 지시자를 전역으로 설정해봅시다.</p>\n<pre><code>Vue.directive('avatar', function (el, binding) {\n console.log(binding.value.width) // 500\n console.log(binding.value.height)  // 400\n console.log(binding.value.url) // path/logo\n console.log(binding.value.text)  // \"Iron Man\"\n})\n</code></pre>\n</li>\n<li>\n<h3>지시자 훅에서 함수 약어는?</h3>\n<p>드문 경우지만, 다른 훅과는 상관없이 <code>bind</code>나 <code>update</code> 훅에서 같은 동작을 하기 원할 수 있습니다. 이 경우에는 함수 약어를 사용할 수 있습니다.</p>\n<pre><code>Vue.directive('theme-switcher', function (el, binding) {\n el.style.backgroundColor = binding.value\n})\n</code></pre>\n</li>\n<li>\n<h3>render 함수를 사용하는 이유는?</h3>\n<p>일반적인 경우 Vue의 템플릿을 이용해 HTML을 작성하는 것을 권장합니다. 하지만 <code>input</code>이나 <code>slot</code>의 값을 이용해 동적인 컴포넌트를 생성하는 것처럼, 일부 특별한 경우에는 JavaScript가 필요한 경우가 있습니다. 이때 <code>render</code> 함수를 사용하며, <code>render</code>함수는 JavaScript로 작성하기 때문에 프로그래밍 환경을 온전히 이용할 수 있다는 장점이 있습니다.</p>\n</li>\n<li>\n<h3>render 함수란?</h3>\n<p><code>render</code> 함수는 <code>createElement</code>라는 함수를 첫 번째 인자로 받아 가상 노드를 생성하는 함수입니다. 내부적으로 Vue의 템플릿은 빌드 타임에서 <code>render</code> 함수를 이용해 컴파일하고 있습니다. 그러므로 템플릿은 <code>render</code> 함수를 문법적으로 보기 쉽게 만들어 놓은 것에 가깝습니다.</p>\n<pre><code>&#x3C;template>\n&#x3C;div :class=\"{'is-rounded': isRounded}\">\n  &#x3C;p>Welcome to Vue render functions&#x3C;/p>\n&#x3C;/div>\n&#x3C;/template>\n</code></pre>\n<p>위의 템플릿을 <code>render</code> 함수로 작성하면 아래와 같습니다.</p>\n<pre><code>render: function (createElement) {\n  return createElement('div', {\n    'class': {\n        'is-rounded': this.isRounded\n    }\n  }, [\n    createElement('p', 'Welcome to Vue render functions')\n  ]);\n },\n</code></pre>\n</li>\n<li>\n<h3>createElement 함수란?</h3>\n<p><code>createElement</code> 함수는 몇 가지의 약속된 전달인자를 받는데, 이를 이용해 템플릿에서 사용되는 기능을 JavaScript 코드로 작성할 수 있습니다.</p>\n<pre><code class=\"language-javascript\">createElement(\n 'div',\n {\n     attrs: {\n       id: 'someId'\n     },\n     props: {\n       myProp: 'somePropValue'\n     },\n     domProps: {\n       innerHTML: 'This is some text'\n     },\n     on: {\n         click: this.clickHandler\n       },\n      style: {\n         color: 'red',\n         fontSize: '14px'\n      },\n       class: {\n          classsName1: true,\n          classsName2: false\n       },\n },\n\n [\n   'Learn about createElement arguments.',\n   createElement('h1', 'Headline as a child virtual node'),\n   createElement(MyComponent, {\n     props: {\n       someProp: 'This is a prop value'\n     }\n   })\n ]\n)\n</code></pre>\n</li>\n</ol>\n<h3>가상 노드를 여러 번 사용할 수 있는 방법은?</h3>\n<p>컴포넌트 트리의 모든 가상 노드(VNodes)는 고유해야 합니다. 즉, 직접 가상 노드를 여러 번 사용할 수는 없습니다. 만약 같은 엘리먼트나 컴포넌트를 여러 번 반복해서 사용해야 한다면, 팩토리 패턴을 이용해 작성해야 합니다.</p>\n<p>아래의 <code>render</code> 함수는 <code>h1</code> 엘리먼트를 세 번 반복하려 했기 때문에 유효하지 않습니다.</p>\n<pre><code>render: function (createElement) {\n  var myHeadingVNode = createElement('h1', 'This is a Virtual Node')\n  return createElement('div', [\n    myHeadingVNode, myHeadingVNode, myHeadingVNode\n  ])\n}\n</code></pre>\n<p>팩토리 패턴을 이용하면 됩니다.</p>\n<pre><code>render: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 3 }).map(function () {\n      return createElement('h1', 'This is a Virtual Node')\n    })\n  )\n}\n</code></pre>\n<ol>\n<li>\n<h3>render 함수와 템플릿을 비교한다면?</h3>\n<p>Vue에서 HTML을 작성하는데 사용되는 템플릿과 render 함수를 비교해봅시다.</p>\n<table>\n<thead>\n<tr>\n<th>템플릿(Templates)</th>\n<th>렌더 함수(Render function)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>v-if</code>와 <code>v-for</code>를 이용해 조건문/반복문 실행</td>\n<td>JavaScript의 <code>if else</code>문과 <code>map</code> 메소드로 조건문/반복문 실행</td>\n</tr>\n<tr>\n<td><code>v-model</code>로 양방향 바인딩</td>\n<td>바인딩과 이벤트를 직접 설정</td>\n</tr>\n<tr>\n<td>Capture 이벤트 수식어는 <code>.passive</code>, <code>.capture</code>, <code>.once,</code> <code>.capture.once</code>, <code>.once.capture</code></td>\n<td>&#x26;, !, ~, ~!</td>\n</tr>\n<tr>\n<td>이벤트 수식어와 키 수식어: <code>.stop</code>, <code>.prevent</code>, <code>.self</code>, keys(<code>.enter</code>, <code>.13</code>) and Modifiers Keys(<code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code>)</td>\n<td>JavaScript로 해결, <code>event.stopPropagation()</code>, <code>event.preventDefault()</code>, <code>if (event.target !== event.currentTarget) return</code>, <code>if (event.keyCode !== 13) return</code>, <code>if (!event.ctrlKey) return</code></td>\n</tr>\n<tr>\n<td>슬롯 속성 활용</td>\n<td>렌더 함수의 <code>this.$slots</code>와 <code>this.$scopedSlots</code> 활용</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h2>컴포넌트(Functional component)</h2>\n<hr>\n<h4>1) 함수형 컴포넌트</h4>\n<ul>\n<li>context를 통해 전달받은 정보로만 생성되는 간단한 컴포넌트</li>\n<li>상태 없음(Stateless): data 가 없음</li>\n<li>인스턴스 없음(Instanceless):  this가 없음</li>\n<li>functional: true속성을 이용해 컴포넌트를 함수형으로 작성.</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.component('my-component', {\n  functional: true,\n  props: {\n    // ...\n  },\n  render: function (createElement, context) {\n    // ...\n  }\n})\n</code></pre>\n<h4>2) 동적 컴포넌트</h4>\n<ul>\n<li><component> 태그에서 v-bind:is로 바인딩된 컴포넌트를 동적으로 전환</li>\n</ul>\n<pre><code class=\"language-javascript\">new Vue({\n  el: '#app',\n  data: {\n    currentPage: 'home'\n  },\n  components: {\n    home: {\n      template: \"&#x3C;p>Home&#x3C;/p>\"\n    },\n    about: {\n      template: \"&#x3C;p>About&#x3C;/p>\"\n    },\n    contact: {\n      template: \"&#x3C;p>Contact&#x3C;/p>\"\n    }\n  }\n})\n</code></pre>\n<pre><code class=\"language-html\">&#x3C;div id=\"app\">\n   &#x3C;component v-bind:is=\"currentPage\">\n   &#x3C;/component>\n&#x3C;/div>\n</code></pre>\n<h4>3) keep-alive 태그</h4>\n<ul>\n<li>컴포넌트의 상태를 보존해서 재 렌더링을 막아주는 추상 컴포넌트입니다. </li>\n<li>만약 동적인 컴포넌트를 <code>&#x3C;keep-alive></code> 태그로 감싼다면, 컴포넌트 인스턴스를 없애지 않고 메모리에 유지해 보존합니다.</li>\n<li>DOM에 렌더링 되지 않음</li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;keep-alive>\n  &#x3C;component v-bind:is=\"currentTabComponent\">&#x3C;/component>\n&#x3C;/keep-alive>\n</code></pre>\n<p>만약 조건문이 있다면, 해당 조건의 하위 컴포넌트만 렌더링됩니다.</p>\n<pre><code class=\"language-html\">&#x3C;keep-alive>\n  &#x3C;comp-a v-if=\"a > 1\">&#x3C;/comp-a>\n  &#x3C;comp-b v-else>&#x3C;/comp-b>\n&#x3C;/keep-alive>\n</code></pre>\n<h4>4) 비동기 컴포넌트(Async component)</h4>\n<ul>\n<li>대규모 응용 프로그램에서는 응용 프로그램을 더 작은 덩어리로 나누고 실제로 필요할 때만 서버에서 컴포넌트를 로드해야 할 수도 있습니다. </li>\n<li>Vue를 사용하면 컴포넌트 정의를 비동기식으로 해결하는 팩토리 함수로 컴포넌트를 정의 할 수 있습니다.</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.component('async-webpack-example', function (resolve, reject) {\n  // Webpack automatically split your built code into bundles which are loaded over Ajax requests.\n  require(['./my-async-component'], resolve)\n})\n</code></pre>\n<p>Vue는 Vue는 컴포넌트가 렌더링되어야 할 때만 팩토리 함수를 실행시키고, 이후의 나중에 있을 리렌더링을 위해 결과를 캐시합니다.</p>\n<h4>5) 비동기 컴포넌트 팩토리 패턴</h4>\n<ul>\n<li>비동기 컴포넌트 팩토리는 다음 형태의 객체를 반환.</li>\n</ul>\n<pre><code class=\"language-javascript\">const AsyncComponent = () => ({\n  component: import('./MyComponent.vue'),\n  loading: LoadingComponent,\n  error: ErrorComponent,\n  delay: 200,\n  timeout: 3000\n})\n</code></pre>\n<h4>6) 인라인 템플릿(inline templates)</h4>\n<ul>\n<li>하위 컴포넌트에 <code>inline-template</code> 속성이 존재할 때, 컴포넌트는 내부 컨텐츠를 템플릿으로 사용</li>\n<li><code>inline-template</code>은 템플릿의 범위를 추론하기 어렵게 만듦</li>\n<li><code>template</code> 옵션을 사용하거나 <code>.vue</code> 파일의 <code>template</code> 엘리먼트를 사용하여 컴포넌트 내부에 템플릿을 정의</li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;my-component inline-template>\n   &#x3C;div>\n       &#x3C;h1>Inline templates&#x3C;/p>\n       &#x3C;p>Treated as component component owne content&#x3C;/p>\n   &#x3C;/div>\n&#x3C;/my-component>\n</code></pre>\n<h4>7) X-Templates이란?</h4>\n<ul>\n<li>템플릿를 정의하는 또 다른 방법은 <code>text/x-template</code> 유형의 스크립트 엘리먼트 내부의 ID로 템플릿을 참조하는 것</li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;script type=\"text/x-template\" id=\"script-template\">\n  &#x3C;p>Welcome to X-Template feature&#x3C;/p>\n&#x3C;/script>\n</code></pre>\n<pre><code class=\"language-javascript\">Vue.component('x-template-example', {\n  template: '#script-template'\n})\n</code></pre>\n<h4>8) 재귀 컴포넌트(recursive components)</h4>\n<ul>\n<li>컴포넌트는 자신의 템플릿에서 자기 자신을 재귀적으로 호출 가능</li>\n<li>재귀 컴포넌트는 블로그의 덧글이나 메뉴처럼 상위 컴포넌트와 하위 컴포넌트가 동등한 기능을 할 때 유용</li>\n</ul>\n<pre><code class=\"language-javascript\">Vue.component('recursive-component', {\n  template: `&#x3C;!--Invoking myself!-->\n             &#x3C;recursive-component>&#x3C;/recursive-component>`\n});\n</code></pre>\n<h4>9) 컴포넌트 사이의 순환 참조</h4>\n<ul>\n<li>복잡한 어플리케이션에서 Vue 컴포넌트가 서로가 서로를 호출하고 있는 상황이 발생할 수 있음</li>\n<li><code>beforeCreate</code> 라이프 사이클 훅 시점까지 기다렸다가 해당 컴포넌트를 등록하거나, 웹팩의 비동기 <code>import</code>를 활용</li>\n</ul>\n<pre><code class=\"language-html\">//ComponentA\n&#x3C;div>\n  &#x3C;component-b >\n&#x3C;/div>\n\n//ComponentB\n&#x3C;div>\n  &#x3C;component-b >\n&#x3C;/div>\n</code></pre>\n<ul>\n<li>해결법 1</li>\n</ul>\n<pre><code class=\"language-javascript\">beforeCreate: function () {\n this.$options.components.componentB = require('./component-b.vue').default\n}\n</code></pre>\n<ul>\n<li>해결법 2</li>\n</ul>\n<pre><code class=\"language-javascript\">components: {\n componentB: () => import('./component-b.vue')\n}\n</code></pre>\n<h3>하위 컴포넌트, 상위 컴포넌트</h3>\n<ul>\n<li>상위 컴포넌트에서는 하위 컴포넌트들을 <code>$children</code> 배열로 참조하며, </li>\n<li>하위 컴포넌트에서 상위 컴포넌트를 <code>$parent</code> 속성으로 참조합니다.</li>\n</ul>\n<h2>vue 의 장단점</h2>\n<h4>1) Vue와 React</h4>\n<h5>(1) 공통점</h5>\n<ul>\n<li>두 프레임워크 모두 가상 DOM모델을 사용</li>\n<li>반응적이고 조합 가능한 컴포넌트를 제공</li>\n<li>코어 라이브러리에만 집중하고 있고, 라우팅 및 상태 관리와 같은 라이브러리가 부가적으로 있음</li>\n</ul>\n<h5>(2) 차이점</h5>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>타입</td>\n<td>JavaScript MVC 프레임워크</td>\n<td>JavaScript 라이브러리</td>\n</tr>\n<tr>\n<td>플랫폼</td>\n<td>웹을 우선적으로</td>\n<td>웹과 네이티브 모두</td>\n</tr>\n<tr>\n<td>복잡도</td>\n<td>상대적으로 간단</td>\n<td>상대적으로 복잡</td>\n</tr>\n<tr>\n<td>빌드 어플리케이션</td>\n<td>Vue-cli</td>\n<td>CRA (<code>Create-React-App</code>)</td>\n</tr>\n</tbody>\n</table>\n<h5>(3) Vue가 React에 비해 나은 점</h5>\n<ul>\n<li>가볍고 빠름</li>\n<li>템플릿이 개발 과정을 쉽게 만들어줌</li>\n<li>JSX에 비해 가벼운 JavaScript 문법을 사용</li>\n</ul>\n<h5>(4) React가 Vue에 비해 나은 점</h5>\n<ul>\n<li>모바일 앱 제작에도 적합</li>\n<li>생태계가 크고 풍부</li>\n<li>큰 규모의 어플리케이션을 유연하게 만들 수 있음</li>\n<li>테스트가 쉬움</li>\n</ul>\n<h4>2) Vue와 Angular</h4>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>Vue</th>\n<th>Angular</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>복잡도</td>\n<td>배우기 쉬운 API와 디자인</td>\n<td>프레임워크가 꽤 크고 타입스크립트 등의 지식 필요</td>\n</tr>\n<tr>\n<td>데이터 바인딩</td>\n<td>양방향 바인딩</td>\n<td>단방향 바인딩</td>\n</tr>\n<tr>\n<td>초기 릴리즈</td>\n<td>2014</td>\n<td>2016</td>\n</tr>\n<tr>\n<td>모델</td>\n<td>가상 DOM 기반</td>\n<td>MVC</td>\n</tr>\n<tr>\n<td>작성된 언어</td>\n<td>JavaScript</td>\n<td>TypeScript</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<h3>CSP 환경에서 Vue 어플리케이션을 빌드하는 법은?</h3>\n<p>Google 크롬 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를 적용하여 표현식을 평가하는 데 <code>new Function()</code> 을 사용할 수 없습니다. 전체 빌드는 이 기능을 사용하여 템플릿을 컴파일하므로 이러한 환경에서는 사용할 수 없습니다.</p>\n<p>반면 런타임 전용 빌드는 CSP와 완벽하게 호환됩니다. Webpack + vue-loader 또는 Browserify + vueify로 런타임 전용 빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 <code>render</code> 함수로 미리 컴파일됩니다.</p>\n</li>\n<li>\n<h3>전체 빌드와 런타임 빌드의 차이점은?</h3>\n<p><strong>1. 전체 빌드(Full):</strong> 컴파일러와 런타임 빌드를 동시에 포함합니다. 템플릿을 작성한 경우 필요합니다.</p>\n<p><strong>2. 런타임 빌드(Runtime):</strong> Vue 인스턴스 생성과 <code>render</code> 함수, 가상 돔을 포함하고 있지만 컴파일러 빌드를 포함하고 있지 않습니다.</p>\n</li>\n<li>\n<h3>Vue의 빌드 종류는?</h3>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>UMD</th>\n<th>CommonJS</th>\n<th>ES Module (for bundlers)</th>\n<th>ES Module (for browsers)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>전체 빌드</td>\n<td>vue.js</td>\n<td>vue.common.js</td>\n<td>vue.esm.js</td>\n<td>vue.esm.browser.js</td>\n</tr>\n<tr>\n<td>런타임 빌드</td>\n<td>vue.runtime.js</td>\n<td>vue.runtime.common.js</td>\n<td>vue.runtime.esm.js</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>전체 빌드 (배포 모드)</td>\n<td>vue.min.js</td>\n<td>NA</td>\n<td>NA</td>\n<td>vue.esm.browser.min.js</td>\n</tr>\n<tr>\n<td>런타임 빌드 (배포 모드)</td>\n<td>vue.runtime.min.js</td>\n<td>NA</td>\n<td>NA</td>\n<td>NA</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<h3>웹팩에서 Vue 설정을 하는 방법은?</h3>\n<p><code>alias</code>를 이용해 Vue를 설정할 수 있습니다.</p>\n<pre><code class=\"language-javascript\">module.exports = {\n // ...\n resolve: {\n   alias: {\n     'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\n   }\n }\n}\n</code></pre>\n</li>\n<li>\n<h3>Vue 컴파일러의 목적은?</h3>\n<p>Vue는 컴파일러를 이용해 템플릿을 <code>render</code> 함수로 변환합니다.</p>\n<pre><code class=\"language-javascript\">// this requires the compiler\nnew Vue({\n template: '&#x3C;div>{{ message }}&#x3C;/div>'\n})\n\n// this does not\nnew Vue({\n render (h) {\n   return h('div', this.message)\n }\n})\n</code></pre>\n</li>\n<li>\n<h3>VueJS의 브라우저 지원은?</h3>\n<p>ECMAScript5를 지원하는 브라우저에서 동작 가능합니다. IE8 이하의 브라우저에서는 지원하지 않습니다.</p>\n</li>\n<li>\n<h3>CDN으로 Vue를 사용하는 방법은?</h3>\n<p>Vue는 jsdelivr, unpkg, cdnjs에서 제공하는 CDN을 이용해서도 사용이 가능합니다. 일반적으로 초기 기획, 학습용으로 적합합니다.</p>\n<pre><code>&#x3C;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.js\">&#x3C;/script>\n</code></pre>\n<pre><code>&#x3C;script type=\"module\">\n import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.esm.browser.js'\n&#x3C;/script>\n</code></pre>\n<p><strong>Note:</strong> 버전 정보를 지우면 항상 최신 버전을 가져옵니다.</p>\n</li>\n<li>\n<h3>강제로 업데이트를 발생시키는 방법은?</h3>\n<p>매우 드문 경우지만, 데이터가 변경되지 않았음에도 재 렌더링을 위해 강제로 업데이트를 발생시켜야 할 수도 있습니다. 이 경우 <code>vm.$forceUpdate()</code> API 메소드를 이용할 수 있습니다.</p>\n<p><strong>Note:</strong> 모든 하위 컴포넌트에는 영향이 미치지 않으며, 슬롯 그 자체가 삽입된 슬롯 자체 및 하위 컴포넌트에만 영향을 미칩니다.</p>\n</li>\n<li>\n<h3>템플릿에서 once 지시자를 쓰는 이유는?</h3>\n<p>많은 양의 정적 컨텐츠를 렌더링 할 때, 성능 향상을 위해 엘리먼트 및 컴포넌트를 한번만 렌더링하는 용도로 사용합니다.</p>\n<pre><code>Vue.component('legal-terms', {\n  template: `\n    &#x3C;div v-once>\n      &#x3C;h1>Legal Terms&#x3C;/h1>\n      ... a lot of static content goes here...\n    &#x3C;/div>\n  `\n})\n</code></pre>\n<p><strong>Note:</strong> 정적 컨텐츠가 많아서 느려지는 일이 발생하지 않는 한, 과다하게 사용하지 않는 것이 좋습니다.</p>\n</li>\n</ol>\n<h3>루트 Vue 인스턴스에 접근</h3>\n<ul>\n<li><code>$root</code> 속성을 이용해 접근</li>\n<li>상태 관리를 위한 용도라면 Vuex를 사용하는 것이 낫습니다.</li>\n<li>루트 인스턴스의 데이터와 메소드들을 하위 컴포넌트에서 아래와 같은 방법으로 접근</li>\n</ul>\n<pre><code class=\"language-javascript\">new Vue({\n  data: {\n    age: 26\n  },\n  computed: {\n    fullName: function () { /* ... */ }\n  },\n  methods: {\n    interest: function () { /* ... */ }\n  }\n})\n</code></pre>\n<pre><code class=\"language-javascript\">this.$root.age\nthis.$root.age = 29\nthis.$root.fullName\nthis.$root.interest()\n</code></pre>\n<h3>renderError 메소드</h3>\n<ul>\n<li>기본 <code>render</code> 함수가 렌더링 도중 에러가 발생하면, 대체되는 렌더링 결과를 제공</li>\n<li><code>renderError</code>의 두 번째 전달인자로 에러가 전달</li>\n</ul>\n<pre><code class=\"language-javascript\">new Vue({\n  render (h) {\n    throw new Error('An error')\n  },\n  renderError (h, err) {\n    return h('div', { style: { color: 'red' }}, err.stack)\n  }\n}).$mount('#app')\n</code></pre>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8\">플러그인</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-%EA%B0%9C%EC%9A%94\">1) 개요</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95\">2) 플러그인을 만드는 방법</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-%EC%82%AC%EC%9A%A9%EB%B2%95\">3) 사용법</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%EB%AF%B9%EC%8A%A4%EC%9D%B8\">믹스인</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-%EA%B0%9C%EC%9A%94-1\">1) 개요</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-%EC%A0%84%EC%97%AD-%EB%AF%B9%EC%8A%A4%EC%9D%B8\">2) 전역 믹스인</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-cli-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B2%95\">3) CLI 환경에서 믹스인을 사용하는 법</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#4-%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%98-%EC%98%B5%EC%85%98%EA%B3%BC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%98%B5%EC%85%98%EC%9D%98-%EC%B6%A9%EB%8F%8C\">4) 믹스인의 옵션과 컴포넌트의 옵션의 충돌</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%98-%EB%B3%91%ED%95%A9-%EB%B0%A9%EB%B2%95-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98\">3) 믹스인의 병합 방법 사용자 정의</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%A7%80%EC%8B%9C%EC%9E%90custom-directive\">사용자 정의 지시자(Custom directive)</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-%EA%B0%9C%EC%9A%94-2\">1) 개요</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-%EC%A7%80%EC%8B%9C%EC%9E%90-%EC%A7%80%EC%97%AD-%EB%93%B1%EB%A1%9D\">2) 지시자 지역 등록</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-%EC%A7%80%EC%8B%9C%EC%9E%90%EC%9D%98-%EB%9D%BC%EC%9D%B4%ED%94%84-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9B%85\">3) 지시자의 라이프 사이클 훅</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%EA%B0%80%EC%83%81-%EB%85%B8%EB%93%9C%EB%A5%BC-%EC%97%AC%EB%9F%AC-%EB%B2%88-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\">가상 노드를 여러 번 사용할 수 있는 방법은?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8functional-component\">컴포넌트(Functional component)</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">1) 함수형 컴포넌트</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-%EB%8F%99%EC%A0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">2) 동적 컴포넌트</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-keep-alive-%ED%83%9C%EA%B7%B8\">3) keep-alive 태그</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#4-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8async-component\">4) 비동기 컴포넌트(Async component)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#5-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4\">5) 비동기 컴포넌트 팩토리 패턴</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#6-%EC%9D%B8%EB%9D%BC%EC%9D%B8-%ED%85%9C%ED%94%8C%EB%A6%BFinline-templates\">6) 인라인 템플릿(inline templates)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#7-x-templates%EC%9D%B4%EB%9E%80\">7) X-Templates이란?</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#8-%EC%9E%AC%EA%B7%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8recursive-components\">8) 재귀 컴포넌트(recursive components)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0\">9) 컴포넌트 사이의 순환 참조</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%ED%95%98%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%81%EC%9C%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">하위 컴포넌트, 상위 컴포넌트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#vue-%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">vue 의 장단점</a></p>\n<ul>\n<li>\n<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-vue%EC%99%80-react\">1) Vue와 React</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#1-%EA%B3%B5%ED%86%B5%EC%A0%90\">(1) 공통점</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-%EC%B0%A8%EC%9D%B4%EC%A0%90\">(2) 차이점</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#3-vue%EA%B0%80-react%EC%97%90-%EB%B9%84%ED%95%B4-%EB%82%98%EC%9D%80-%EC%A0%90\">(3) Vue가 React에 비해 나은 점</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#4-react%EA%B0%80-vue%EC%97%90-%EB%B9%84%ED%95%B4-%EB%82%98%EC%9D%80-%EC%A0%90\">(4) React가 Vue에 비해 나은 점</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#2-vue%EC%99%80-angular\">2) Vue와 Angular</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#%EB%A3%A8%ED%8A%B8-vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC\">루트 Vue 인스턴스에 접근</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91)%20%EC%A7%88%EB%AC%B8%20%EC%A0%95%EB%A6%AC%20%EB%AA%A8%EC%9D%8C%20-%20Vue(2)/#rendererror-%EB%A9%94%EC%86%8C%EB%93%9C\">renderError 메소드</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)","path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)/","images":["images/2.jpg"],"category":"기술 면접","tags":["프론트엔드","개발자","면접","기술면접","Vue"],"date":"2021-05-06T01:00:00.000Z","components":null,"tweets":null,"summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)"}}},"pageContext":{"match":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)/"}}}