{"componentChunkName":"component---src-templates-post-tsx","path":"/프론트엔드 면접 질문 - React(2)/","result":{"data":{"site":{"siteMetadata":{"title":"jigglog","author":"JIGGLYPOP","homepage":"https://jigglog.netlify.app"}},"post":{"id":"7e1cde14-953f-54b4-be42-2fe98bea311b","html":"<blockquote>\n<p>프론트 엔드 면접 질문용 공부 후 정리 자료입니다. 정확하지 않을 수 있으니 꼭 다시 책이나 자료를 참고하여 공부하세요</p>\n</blockquote>\n<h1>react란</h1>\n<h2>1)React란 무엇인가요?)</h2>\n<p><a href=\"https://reactjs.org/docs/hello-world.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React</a>는 SPA (Single Page Application) 즉, 단일 페이지 응용 프로그램에서 사용자 인터페이스를 구성는데 사용되는 오픈 소스 프론트엔드 JS 라이브러리 입니다.\n웹 및 모바일 앱의 Layer 를 다루는데 사용됩니다. 리액트는 페이스북의 소프트웨어 엔지니어 <a href=\"https://twitter.com/jordwalke\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jordan Walke</a> 에 의해 만들어졌습니다.\n리액트는 2011 년 페이스북 뉴스피드에 발표되었고, 2012년 인스타그램에 처음 구축되었습니다.</p>\n<ol>\n<li>\n<h3>What are the major features of ReactJS?</h3>\n</li>\n</ol>\n<h4>(React의 특징은 무엇이 있을까요?)</h4>\n<p>React 의 주요 특징은 아래와 같습니다.</p>\n<ul>\n<li>RealDOM 을 조작하는데 많은 비용이 들어간다는 점을 고려하여 리액트는 RealDOM 대신 <a href=\"https://www.youtube.com/watch?v=BYbgopx44vo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">VirtualDOM</a>을 사용합니다.</li>\n<li><a href=\"https://subicura.com/2016/06/20/server-side-rendering-with-react.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">서버 사이드 렌더링</a>을 지원합니다.</li>\n<li>단방향 데이터 흐름 또는 데이터 바인딩을 따릅니다.</li>\n<li>UI 구성 요소를 재사용할 수 있도록 개발할 수 있습니다.</li>\n<li>\n<h3>What is JSX?</h3>\n</li>\n</ul>\n<h4>(JSX란 무엇인가요?)</h4>\n<p><a href=\"https://reactjs.org/docs/introducing-jsx.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JSX</a> 는 JS XML (ECMAScript로 XML 유사 구문 확장) 의 구문 표기법입니다. JSX 는 JS XML의 약자입니다.\n<a href=\"https://ko.wikipedia.org/wiki/HTML\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTML</a>과 같은 문법과 함께 JS를 표현할 수 있습니다. 예를 들면 아래의 h1 태그안에 text 는 render 함수에 의해 JS 함수로 반환됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">render() {\n  return (\n    &lt;div>\n      &lt;h1> Welcome to React world!!&lt;/h1>\n    &lt;/div>\n  );\n}</code></pre></div>\n<ol>\n<li>\n<h3>What is the difference between Element and Component?</h3>\n</li>\n</ol>\n<h4>(element와 component의 차이점은 무엇인가요?)</h4>\n<p><a href=\"https://ko.wikipedia.org/wiki/HTML_%EC%9A%94%EC%86%8C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">element</a>는 DOM 노드 또는 다른 <a href=\"https://reactjs.org/docs/react-component.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">component</a>들과 관련하여 화면에 표시 할 내용을 표현하는 일반 객체입니다. elements는 다른 elements 들을 포함할 수 있습니다. <a href=\"https://reactjs.org/docs/rendering-elements.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React element</a>를 만드는 비용은 저렴합니다. element 는 생성되면 변형되지 않습니다. 리액트 element 의 표현은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const element = React.createElement(\"div\", { id: \"login-btn\" }, \"Login\");</code></pre></div>\n<p>위에서 만들어진 element 는 아래와 같은 객체로 리턴됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  type: 'div',\n  props: {\n    children: 'Login',\n    id: 'login-btn'\n  }\n}</code></pre></div>\n<p>마지막으로 아래와 같이 <a href=\"https://reactjs.org/docs/react-dom.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>ReactDOM.render</strong></a> 를 이용하여 DOM 으로 렌더링합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div id=\"login-btn\">Login&lt;/div></code></pre></div>\n<p>반면 component 는 여러 방법으로 선언될 수 있습니다. render 메서드가 있는 class 일 수도 있습니다. 간단한 component 일 경우 function으로 정의 될 수 있습니다. 입력된 component 를 바탕으로 element 트리를 만듭니다. 마지막에 JSX 는 <a href=\"https://reactjs.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">createElement로 변환</a>됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Button({ onLogin }) {\n  return React.createElement(\n    \"div\",\n    { id: \"login-btn\", onClick: onLogin },\n    \"Login\"\n  );\n}</code></pre></div>\n<ol>\n<li>\n<h3>How to create components in ReactJS?</h3>\n</li>\n</ol>\n<h4>(React에서 컴포넌트를 어떻게 생성하나요?)</h4>\n<p>ReactJS 는 Components 생성하는 두 가지 방법이 있습니다.</p>\n<p><strong>Functional components</strong></p>\n<p>ReactJS 에서 component를 생성하는 가장 간단한 방법입니다. props 를 받을 수 있고 React elements 를 리턴할 수 있습니다. 이런 방법을 pure 한 JS의 function 이기 때문에 functional한 생성법이라고 부릅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Greeting(props) {\n  return &lt;h1> Hello, {props.message}&lt;/h1>;\n}</code></pre></div>\n<p><strong>Class components</strong></p>\n<p>ES6 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Class</a>를 사용하여 component 를 정의할 수 있습니다. 위에서 본 functional 선언법을 아래와 같이 적용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Greeting extends React.Component {\n  render() {\n    return &lt;h1>Hello, {this.props.message}&lt;/h1>;\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>When to use a Class Component over a Functional Component?</h3>\n</li>\n</ol>\n<h4>(언제 클래스 컴포넌트를 사용하고 언제 Functional 컴포넌트를 사용할까요?)</h4>\n<p>Component 에서 state 또는 <a href=\"https://reactjs.org/docs/react-component.html#the-component-lifecycle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">life cycle methods</a> 를 필요로 한다면 Class component를 사용하고 그렇지 않다면 Functional component를 사용할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What are Pure Components?</h3>\n</li>\n</ol>\n<h4>(순수 컴포넌트란 무엇인가요?)</h4>\n<p><a href=\"http://lucybain.com/blog/2018/react-js-pure-component\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PureComponent</a>는 동일한 상태에서는 동일한 결과를 반환합니다. <a href=\"https://reactjs.org/docs/react-component.html#shouldcomponentupdate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">shouldComponentUpdate</a> 메서드를 다룰 수 있다는 점을 제외하고는 component와 동일합니다.\nprops 또는 state 가 변경될 때 PureComponent 는 state 와 props 에 대해 <a href=\"https://reactjs.org/docs/shallow-compare.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shallow Compare</a>을 수행합니다.\n반면 component는 현재 props와 변형될 state를 비교하지 않습니다. 그렇기 때문에 component는 shouldComponentUpdate가 호출 될 때 마다 다시 render 됩니다. (shouldComponentUpdate의 기본값은 true 이기 때문에)</p>\n<ol>\n<li>\n<h3>What is state in ReactJS?</h3>\n</li>\n</ol>\n<h4>(state란 무엇인가요?)</h4>\n<p>Component <a href=\"https://reactjs.org/docs/faq-state.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">State</a> 는 component의 life cycle 동안 변경될 수 있는 정보를 담고 있는 객체입니다. 우리는 state를 가능한 단순하게 만들고 state 의 구성 요소의 수를 최소화하기 위해 노력해야 합니다.</p>\n<p>message state를 가진 user component 를 생성해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class User extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      message: &quot;Welcome to React world&quot;\n    };\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{this.state.message}&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre></div>\n<p><a href=\"https://github.com/appear/reactjs-interview-questions-ko/blob/master/public/state.jpg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/state.jpg\" alt=\"state\"></a></p>\n<ol>\n<li>\n<h3>What is props in ReactJS?</h3>\n</li>\n</ol>\n<h4>(props란 무엇인가요?)</h4>\n<p><a href=\"https://reactjs.org/docs/components-and-props.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Props</a> 는 HTML 태그 속성과 유사한 규칙을 사용하여 React component 에 전달되는 값을 포함하는 단일 값 또는 객체입니다. 부모 component 에서 자식 component 로 전달되는 데이터 입니다.</p>\n<p>React에서 props 의 목적은 아래와 같은 기능을 component에 제공하는 것 입니다.</p>\n<ol>\n<li>사용자 정의 데이터를 React component 로 전달할 수 있습니다.</li>\n<li>State 변경을 Trigger 할 수 있습니다.</li>\n<li>Component 의 render 메서드 안에서 this.props.reactProp 로 접근하여 사용할 수 있습니다.</li>\n</ol>\n<p>예를 들어, reactProp를 받는 element 를 만들고</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Element reactProp=\"1\" /></code></pre></div>\n<p>이 “reactProp” (또는 사용자가 찾은 정의한) props는 React를 사용하여 생성된 component에서 접근이 가능하고, React의 native props 영역에 포함된 속성이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">props.reactProp;</code></pre></div>\n<ol>\n<li>\n<h3>What is the difference between state and props?</h3>\n</li>\n</ol>\n<h4>(state와 props의 차이점은 무엇인가요?)</h4>\n<p>props와 state는 모두 JavaScript 객체입니다. 두가지 다 렌더링 결과에 영향을 주는 정보를 가지고 있지만, component 와 관련된 기능면에서 차이가 있습니다.\nprops는 함수 매개변수와 같이 component 요소로 전달됩니다. state 는 component 안에서 관리되고 사용할 변수 선언과 비슷합니다.</p>\n<ol>\n<li>\n<h3>Why should not we update the state directly?</h3>\n</li>\n</ol>\n<h4>(state를 직접 업데이트 하면 안되는 이유는 무엇인가요?)</h4>\n<p>state를 직접 업데이트 하려고 한다면 component 는 re-render 되지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">//Wrong\nthis.state.message =”Hello world”;</code></pre></div>\n<p>그 대신 setState 메서드를 사용해야합니다. setState는 component state 업데이트에 대한 예약을합니다. state 가 변경되면 component는 re-rendering 할 것 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">//Correct\nthis.setState({message: ‘Hello World’});</code></pre></div>\n<p>Note: 상태를 할당할 수 있는 곳은 constructor 가 유일합니다. (외부에서 다이렉트로 state를 할당하지 말라는 뜻 같습니다.)</p>\n<ol>\n<li>\n<h3>What is the purpose of callback function as an argument of setState?</h3>\n</li>\n</ol>\n<h4>(setState에서 callback의 역할은 무엇인가요?)</h4>\n<p>callback 함수는 setState가 끝난 후 그리고 component 가 re-rendering 된 후 호출됩니다. setState는 비동기적으로 동작합니다. callback 함수는 모든 작업이 마무리된 후 사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">setState({ name: \"sudheer\" }, () =>\n  console.log(\"The name has updated and component re-rendered\")\n);</code></pre></div>\n<h4>Note: callback 함수를 이용하는 것보단 lifecycle 메서드를 이용하는 것이 좋습니다.</h4>\n<ol>\n<li>\n<h3>What is the difference of event handling between HTML and React?</h3>\n</li>\n</ol>\n<h4>(HTML과 React의 이벤트 처리 차이점은 무엇인가요?)</h4>\n<p>아래는 HTML과 React 의 이벤트처리의 몇 가지 차이점입니다.</p>\n<p>HTML 에서는 이벤트 이름이 소문자여야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button onclick=\"activateLasers()\">&lt;/button></code></pre></div>\n<p>반면 React는 camelCase 를 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button onClick=\"{activateLasers}\">&lt;/button></code></pre></div>\n<p>HTML 에서는 기본 이벤트 동작을 막기위해 false 를 반환할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\" /></code></pre></div>\n<p>반면 React는 preventDefault 메서드를 호출해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function handleClick(e) {\n  e.preventDefault();\n  console.log(\"The link was clicked.\");\n}</code></pre></div>\n<ol>\n<li>\n<h3>How to bind methods or event handlers in JSX callbacks?</h3>\n</li>\n</ol>\n<h4>(This를 바인딩하는 방법은 어떤 것들이 있나요?)</h4>\n<p>3가지의 방법이 있습니다.</p>\n<ol>\n<li>생성자에서의 바인딩: JS 의 Class 에서 메서드는 기본적으로 바인딩 되지 않습니다. 클래스 메서드로 지정된 React의 event handlers 에서도 마찬가지 입니다.\n일반적으로 다음과같이 constructor 바인딩합니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props) {\n  super(props);\n  this.handleClick = this.handleClick.bind(this);\n}\n\nhandleClick() {\n  // Perform some logic\n}</code></pre></div>\n<ol>\n<li>공통 클래스 필드 구문: 생성자에서의 바인딩 방법을 원하지 않는다면, 공용 클래스 필드 구문을 이용하여 callback 을 올바르게 바인딩할 수 있습니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">handleClick = () => {\n  console.log(\"this is:\", this);\n};\n\n&lt;button onClick={this.handleClick}> Click me &lt;/button>;</code></pre></div>\n<ol>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">arrow function</a>을 이용한 바인딩 아래와 같이 바로 arrow function 을 이용하여 바인딩 해줄 수 있습니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button onClick={(e) => this.handleClick(e)}>\n  Click me\n&lt;/button></code></pre></div>\n<p>Note: 만약 callback 이 하위 component 에 props 로 전달되면 component는 re-rendering 될 수 있습니다. 이럴 경우 성능을 고려하였을때 1번 또는 2번의 방식을 사용하는 것이 좋습니다.</p>\n<ol>\n<li>\n<h3>How to pass a parameter to an event handler or callback?</h3>\n</li>\n</ol>\n<h4>(이벤트 핸들러 또는 콜백에 매개변수를 어떻게 전달하나요?)</h4>\n<p>arrow function 으로 감싸서 event handler 에게 매개변수를 전달할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button onClick={() => this.handleClick(id)} /></code></pre></div>\n<p>위의 방법은 아래와 같이 method 를 사용하는 것과 같습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button onClick=\"{this.handleClick.bind(this,\" id)} /></code></pre></div>\n<ol>\n<li>\n<h3>What are synthetic events in ReactJS?</h3>\n</li>\n</ol>\n<h4>(React에서의 합성 이벤트는 무엇인가요?)</h4>\n<p><a href=\"https://reactjs.org/docs/events.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">synthetic event</a> 는 브라우저의 기본 이벤트를 감싼 cross-browser wrapper 입니다. API는 모든 브라우저에서 동작한다는 점을 제외하면, stopPropagation () 및 preventDefault () 를 포함해 브라우저 네이티브 이벤트와 같은 인터페이스를 가지고 있습니다.</p>\n<ol>\n<li>\n<h3>What is inline conditional expressions?</h3>\n</li>\n</ol>\n<h4>(인라인 조건식은 무엇인가요?)</h4>\n<p>조건부 표현식을 표현하기 위해 if 문 또는 삼항 연산자를 사용할 수 있습니다. 이런 표현법 외에도 중괄호로 묶은 다음 JS의 논리 연산자 (&#x26;&#x26;) 를 붙여 JSX 표현식에 포함시킬 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;h1>Hello!&lt;/h1>\n{messages.length > 0 &amp;&amp;\n&lt;h2>\n  You have {messages.length} unread messages.\n&lt;/h2></code></pre></div>\n<ol>\n<li>\n<h3>What is Key and benefit of using it in lists?</h3>\n</li>\n</ol>\n<h4>(list 에서 key를 사용했을 때의 이점은 무엇인가요?)</h4>\n<p><a href=\"https://reactjs.org/docs/lists-and-keys.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“Key”</a>는 목록을 만들때 포함시켜야하는 특수한 속성입니다. “Key”는 목록의 변경사항, 추가 또는 제거된 항목을 분별할 수 있도록 도와줍니다.</p>\n<p>예를 들어, 데이터의 키를 자주 목록의 “Key”로 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todoItems = todos.map(todo => &lt;li key={todo.id}>{todo.text}&lt;/li>);</code></pre></div>\n<p>What is ReactJS? (React란 무엇인가요?) 렌더링 된 목록에 안정적인 ID가 없을 경우 마지막 수단으로 index 값을 이용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todoItems = todos.map((todo, index) => &lt;li key={index}>{todo.text}&lt;/li>);</code></pre></div>\n<p>Note:</p>\n<ol>\n<li>항목 순서가 변경 될 가능성이 있는 경우 index를 이용하는 것은 좋지 않습니다. 성능에 부정적인 영향을 미치고 component state에 문제가 발생할 수 있습니다.</li>\n<li>list를 별도의 component로 뽑아 사용하는 경우 li 태그 대신 list component 요소에 key를 적용하세요</li>\n</ol>\n<p>list 에 key 가 없으면 콘솔에 경고가 표시됩니다.</p>\n<ol>\n<li>\n<h3>What is the use of create refs?</h3>\n</li>\n</ol>\n<h4>(ref의 용도는 무엇인가요?)</h4>\n<p>두 가지의 접근법이 있습니다.</p>\n<p>최근에 추가된 접근 방식입니다. <a href=\"https://reactjs.org/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">create ref</a>는 element 요소에 대한 참조를 반환하는데 사용할 수 있습니다. DOM의 요소나 compoennt 에 직접 접근해야 될 경우 유용할 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to create refs?</h3>\n</li>\n</ol>\n<h4>(create refs를 어떻게 만드나요?)</h4>\n<p>Ref는 React.createRef() 메서드를 사용하여 생성합니다. ref attribute 을 통해 React elements 에 첨부됩니다. component 전체에서 사용하고 싶다면 constructor에서 instance property 로 ref를 할당하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return &lt;div ref={this.myRef} />;\n  }\n}</code></pre></div>\n<ol>\n<li>React의 버전과 관계없이 ref callback 을 사용할 수 있습니다. 예를들어 serach bar component의 input element는 다음과 같이 접근합니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class SearchBar extends Component {\n  constructor(props) {\n    super(props);\n    this.txtSearch = null;\n    this.state = { term: \"\" };\n    this.setInputSearchRef = e => {\n      this.txtSearch = e;\n    };\n  }\n  onInputChange(event) {\n    this.setState({ term: this.txtSearch.value });\n  }\n  render() {\n    return (\n      &lt;input\n        value={this.state.term}\n        onChange={this.onInputChange.bind(this)}\n        ref={this.setInputSearchRef}\n      />\n    );\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>What are forward refs?</h3>\n</li>\n</ol>\n<h4>(forward refs 란 무엇인가요?)</h4>\n<p>Ref Forwarding 은 ref를 받아 child component 에게 전달하는 기능을합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ButtonElement = React.forwardRef((props, ref) => (\n  &lt;button ref={ref} className=\"CustomButton\">\n    {props.children}\n  &lt;/button>\n));\n\n// Create ref to the DOM button:\nconst ref = React.createRef();\n&lt;ButtonElement ref={ref}>{\"Forward Ref\"}&lt;/ButtonElement>;</code></pre></div>\n<ol>\n<li>\n<h3>Which is preferred option with in callback refs and findDOMNode()?</h3>\n</li>\n</ol>\n<h4>(callback refs 와 findDOMNode 중에 어떤것을 더 선호하나요?)</h4>\n<p>findDOMNode API 보다 callback refs를 사용하는 것이 좋습니다. <a href=\"https://reactjs.org/docs/react-dom.html#finddomnode\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">findDOMNode</a>는 향후 개선사항에서 React의 특성을 막기 떄문입니다.</p>\n<p>findDOMNode 를 사용하는 legacy 한 방식입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends Component {\n  componentDidMount() {\n    findDOMNode(this).scrollIntoView();\n  }\n\n  render() {\n    return &lt;div />;\n  }\n}</code></pre></div>\n<p>권장하는 방법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends Component {\n  componentDidMount() {\n    this.node.scrollIntoView();\n  }\n\n  render() {\n    return &lt;div ref={node => (this.node = node)} />;\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>Why are String Refs legacy?</h3>\n</li>\n</ol>\n<h4>(왜 String Refs 는 legacy가 되었나요?)</h4>\n<p>만약 예전 React에서 ref 를 다뤄봤다면, ref={‘textInput’} 과 같은 ref 의 속성이 string 이고 DOM Node가 refs.textInput 으로 접근하는 API 방식에 익숙할 것 입니다.\nString refs 는 아래와 같은 문제들이 있기 떄문에 legacy 를 고려하였습니다. React v16 에서 String refs는 제거되었습니다.</p>\n<ol>\n<li>String refs 는 실행중인 component 요소를 추적하도록 강제화합니다. 또 react module 을 stateful 하게 만듭니다. bundle시 react module 들이 중복될 때 이상한 오류를 발생시킵니다.</li>\n<li>라이브러리를 추가하여 String Refs를 Child component 에 전달하면, 사용자는 다른 ref를 추가할 수 없게됩니다. Callback refs를 이용한다면 이런 문제를 해결할 수 있습니다.</li>\n<li>Flow 와 같은 static 분석에서는 동작하지 않습니다. Flow 는 string refs를 this.refs 같은 형태로 표시하도록 만드는 마법을 추측할 수 없습니다. callback ref는 String refs 보다 Flow 와 친밀합니다.</li>\n<li>대부분의 사람들이 “render callback” 패턴으로 동작하기를 기대하지만 그렇게 동작하지 않습니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class MyComponent extends Component {\n  renderRow = index =&gt; {\n    // 이것은 동작하지 않습니다. Ref는 MyComponent가 아닌 DataTable 에 연결될 것입니다.\n    return &lt;input ref={&quot;input-&quot; + index} /&gt;;\n\n    // 이것은 동작합니다. Callback refs는 굉장합니다.\n    return &lt;input ref={input =&gt; (this[&quot;input-&quot; + index] = input)} /&gt;;\n  };\n\n  render() {\n    return &lt;DataTable data={this.props.data} renderRow={this.renderRow} /&gt;;\n  }\n}</code></pre></div>\n<h3>Virtual DOM</h3>\n<h4>1) virtual dom</h4>\n<ul>\n<li>in-memory 즉 Real DOM의 메모리상에서의 표현</li>\n<li>UI의 표현은 메모리에 유지되고 Render함수와 화면을 표시하는 사이에 Real DOM 과 동기화 (reconciliation)</li>\n</ul>\n<h4>2) 동작 과정</h4>\n<ul>\n<li>데이터가 변경될 때 전체 UI 는 가상돔안에서 re-rendered </li>\n</ul>\n<p><a href=\"https://github.com/appear/reactjs-interview-questions-ko/blob/master/public/vdom1.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/vdom1.png\" alt=\"vdom\"></a></p>\n<ul>\n<li>변경되기전 DOM 과 새로운 변경된 DOM 의 변경점을 계산</li>\n</ul>\n<p><a href=\"https://github.com/appear/reactjs-interview-questions-ko/blob/master/public/vdom2.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/vdom2.png\" alt=\"vdom\"></a></p>\n<ul>\n<li>계산이 완료되면 실제 DOM 에서 계산된 변경점들만 업데이트</li>\n</ul>\n<p><a href=\"https://github.com/appear/reactjs-interview-questions-ko/blob/master/public/vdom3.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/vdom3.png\" alt=\"vdom\"></a></p>\n<h3></h3>\n<h4>(Shadow DOM과 Virtual DOM의 차이점)</h4>\n<p>Shadow DOM은 web component의 scope 및 CSS scope 지정을 위해 설계된 web browser 기술입니다. Virtual DOM 은 browser API를 기반으로 JS 라이브러리에서 구현되는 개념입니다.</p>\n<ol>\n<li>\n<h3>What is React Fiber?</h3>\n</li>\n</ol>\n<h4>(React Fiber란 무엇인가요?)</h4>\n<p>React Fiber란 React v16 에서 핵심 알고리즘을 재구현 한것입니다. React Fiber 의 목표는 애니메이션, 레이아웃, 제스처, 작업을 일시정지하고, 중단 또는 재사용, 여러 유형의 업데이트 우선순위 조절, 동시성등 여러 기본사항에 대한 성능을 높이는 것 입니다.</p>\n<ol>\n<li>\n<h3>What is the main goal of React Fiber?</h3>\n</li>\n</ol>\n<h4>(React Fiber의 주요 목표는 무엇인가요?)</h4>\n<p>React Fiber 의 목표는 애니메이션, 레이아웃, 제스처등의 성능을 높이는 것 입니다. 주요 목적은 incremental rendering 입니다.</p>\n<p><strong>incremental rendering:</strong> 렌더링 작업을 청크로 쪼개고 여러 프레임으로 분산 시키는 기능입니다.</p>\n<ol>\n<li>\n<h3>What are controlled components?</h3>\n</li>\n</ol>\n<h4>(controlled components 란 무엇인가요?)</h4>\n<p>입력 요소를 제어하는 component를 controlled components 라고 부릅니다. 모든 상태 변경에는 연관된 handler funciton 이 있습니다.</p>\n<p>예를 들어, 이름을 대문자로 쓰려면 아래 handleChange을 이용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">handleChange(event) {\n  this.setState({value: event.target.value.toUpperCase()})\n}</code></pre></div>\n<ol>\n<li>\n<h3>What are uncontrolled components?</h3>\n</li>\n</ol>\n<h4>(uncontrolled components 란 무엇인가요?)</h4>\n<p>uncontrolled components란 내부적으로 자기 자신의 state를 가지고 있는 component입니다. 현재 필요한 값을 찾기 위해 ref를 사용하여 DOM query를 할 수 있습니다. 이것은 전통적인 HTML 과 비슷합니다.</p>\n<p>아래의 UserProfile Component 에서의 이름 입력은 ref를 사용하여 접근합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class UserProfile extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.input = React.createRef();\n  }\n\n  handleSubmit(event) {\n    alert(&quot;A name was submitted: &quot; + this.input.current.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          {&quot;Name:&quot;}\n          &lt;input type=&quot;text&quot; ref={this.input} /&gt;\n        &lt;/label&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code></pre></div>\n<p>대부분의 경우 forms 을 제어할 때는 controlled component 를 사용하는 것을 추천합니다.</p>\n<ol>\n<li>\n<h3>What is the difference between createElement and cloneElement?</h3>\n</li>\n</ol>\n<h4>(createElement와 cloneElement의 차이점은 무엇인가요?)</h4>\n<p>UI 의 object representation으로 사용될 react element를 만들기 위해 JSX element 는 React.createElement() 함수로 변환됩니다. cloneElement는 element 를 복사하고 새로운 props 를 전달하는데 사용됩니다.</p>\n<ol>\n<li>\n<h3>What is Lifting State Up in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 Lifting State Up 은 무엇인가요?)</h4>\n<p>여러 component 들이 동일한 변경 데이터를 공유해야하는 경우 가까운 부모 component 로 state를 올리는 것이 좋습니다. 즉, 두개의 자식 component가 부모에 있는 동일한 데이터를 공유할 때 두개의 자식 component 들은 local state를 유지하는 대신, 부모로 state를 올려야 합니다.</p>\n<ol>\n<li>\n<h3>What are the different phases of component lifecycle?</h3>\n</li>\n</ol>\n<h4>(component 라이프사이클 단계는 무엇이 다른가요?)</h4>\n<p>라이프 사이클에는 4가지 단계가 있습니다.</p>\n<ol>\n<li>Initialization: component 는 초기 state 및 props 를 세팅을 준비합니다.</li>\n<li>Mounting: component 가 브라우저 DOM에 mount 될 준비가 되었습니다. 이 단계에서는 componentWillMount, componentDidMount 를 사용할 수 있습니다.</li>\n<li>Updating: 새로운 props를 보내거나 state를 업데이트하여 component 를 두가지 방법으로 update 할 수 있습니다. 이 단계에서는 shouldComponentUpdate (), componentWillUpdate () 및 componentDidUpdate 를 사용할 수 있습니다.</li>\n<li>Unmounting: 브라우저 DOM에서 component 가 필요하지 않을때 mount를 해제시킵니다. 이 단계에서는 componentWillUnmount 를 사용할 수 있습니다.</li>\n</ol>\n<p><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/phases.png\" alt=\"lifecycle\"></p>\n<ol>\n<li>\n<h3>What are the lifecycle methods of React?</h3>\n</li>\n</ol>\n<h4>(React의 lifecycle methods는 무엇인가요?)</h4>\n<ul>\n<li>componentWillMount: rendering 전에 실행됩니다.</li>\n<li>componentDidMount: 첫 rendering 후에 실행됩니다. 이 단계에서 모든 AJAX 요청, DOM 또는 State의 update, event listener 가 설정되어야합니다.</li>\n<li>componentWillReceiveProps: 특정 props update가 state 변화를 트리거할 때 실행됩니다.</li>\n<li>shouldComponentUpdate: 컴포넌트의 업데이트 여부를 결정합니다. 기본적으로 return 값은 true 입니다. state 또는 props 가 업데이트 된 후 component 를 render 할 필요가 없을 경우 false를 return 할 수 있습니다. component가 새로운 props를 받으면서 생기는 rerender 을 막을 수 있습니다. 성능을 향상시키는데 좋습니다.</li>\n<li>componentWillUpdate: shouldComponentUpdate에서 true가 반환되었을 때 state &#x26; props 의 변화를 확인하고 re-rendering 되기전에 실행합니다.</li>\n<li>componentDidUpdate: 주로 props 나 state 변경에 대한 response 로 DOM을 업데이트할 때 사용됩니다.</li>\n<li>componentWillUnmount: 네트워크 요청을 취소하거나, component와 관련된 모든 event listeners 를 제거하는데 사용됩니다.</li>\n<li>\n<h3>What are Higher-Order components?</h3>\n</li>\n</ul>\n<h4>(Higher-Order components 는 무엇인가요?)</h4>\n<p>Higher-Order component(HOC)는 component를 받아서 새로운 component를 return 하는 함수입니다. HOC는 React의 특성에서 파생된 패턴입니다. 동적으로 제공되는 하위 component들을 그대로 사용하지만 입력받은 component를 수정하거나 복사하지 않기 때문에 “순수 components” 라고 부릅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></pre></div>\n<p>HOC는 아래와 같은 많은 use cases 에 사용할 수 있습니다.</p>\n<ul>\n<li>Code reuse, logic and bootstrap abstraction</li>\n<li>Render High jacking</li>\n<li>State abstraction and manipulation</li>\n<li>Props manipulation</li>\n<li>\n<h3>How to create props proxy for HOC component?</h3>\n</li>\n</ul>\n<h4>(HOC component 위한 props proxy 만드는법?)</h4>\n<p>다음과 같이 component에 전달된 props를 props proxy로 추가 / 편집 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function HOC(WrappedComponent) {\n  return class Test extends Component {\n    render() {\n      const newProps = {\n        title: \"New Header\",\n        footer: false,\n        showFeatureX: false,\n        showFeatureY: true\n      };\n\n      return &lt;WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}</code></pre></div>\n<ol>\n<li>\n<h3>What is context?</h3>\n</li>\n</ol>\n<h4>(context가 뭔가요?)</h4>\n<p>Context 는 모든 레벨에 수동으로 props를 전달하지 않고 component tree를 통해 데이터를 전달할 수 있도록 제공해줍니다. 예를 들어, 인증된 유저, locale 설정, UI 테마는 많은 application 들에서 접근해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { Provider, Consumer } = React.createContext(defaultValue);</code></pre></div>\n<ol>\n<li>\n<h3>What is children prop?</h3>\n</li>\n</ol>\n<h4>(children prop란 무엇인가요?)</h4>\n<p>Children prop는 component를 data로 다른 component로 전달할 수 있도록 해주는 prop(this.prop.children)입니다.\n당신이 사용하는 prop 처럼 사용할 수 있습니다. React API에는 이 props와 함께 사용할 수 있는 React.Children.map, React.Children.forEach, React.Children.count, React.Children.only, React.Children.toArray등 여러가지 방법이 있습니다.</p>\n<p>children prop의 간단한 사용법은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var MyDiv = React.createClass({\n  render: function() {\n    return &lt;div>{this.props.children}&lt;/div>;\n  }\n});\n\nReactDOM.render(\n  &lt;MyDiv>\n    &lt;span>Hello&lt;/span>\n    &lt;span>World&lt;/span>\n  &lt;/MyDiv>,\n  node\n);</code></pre></div>\n<ol>\n<li>\n<h3>How to write comments in ReactJS?</h3>\n</li>\n</ol>\n<h4>(React에서 주석은 어떻게 쓰나요?)</h4>\n<p>ReactJS / JSX 에서의 주석은 JavaScript와 유사합니다. 한 줄 및 여러 줄 주석들은 모두 중괄호로 감쌉니다.</p>\n<p><strong>Single-line comments:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div>\n  {/* Single-line comments */} // In vanilla JavaScript, the single-line\n  comments are represented by double slash(//) Welcome {user}, Let's play React\n&lt;/div></code></pre></div>\n<p><strong>Multi-line comments:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div>\n  {/* Multi-line comments for more than\n   one line */}\n  Welcome {user}, Let's play React\n&lt;/div></code></pre></div>\n<ol>\n<li>\n<h3>What is the purpose of using super constructor with props argument?</h3>\n</li>\n</ol>\n<h4>(props argument와 함께 super constructor를 사용하는 목적은 무엇인가요?)</h4>\n<p>자식 클래스의 constructor 는 super() 메서드가 호출되기 전까지 this 참조 사용할 수 없습니다. es6 의 sub-classes 에서도 동일하게 적용됩니다. super()에 props를 파라미터로 전달하는 이유는 child constructors에서 this.props로 접근하기 위해서입니다.</p>\n<p><strong>Passing props</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    console.log(this.props); // Prints { name: 'sudheer',age: 30 }\n  }\n}</code></pre></div>\n<p><strong>Not passing props:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super();\n\n    console.log(this.props); // Prints undefined\n\n    // But Props parameter is still available\n    console.log(props); // Prints { name: 'sudheer',age: 30 }\n  }\n\n  render() {\n    // No difference outside constructor\n    console.log(this.props); // Prints { name: 'sudheer',age: 30 }\n  }\n}</code></pre></div>\n<p>위의 code snippets은 this.props의 동작이 constructor 만 다른 것을 보여줍니다. 생성자 밖에서의 동작은 동일합니다.</p>\n<ol>\n<li>\n<h3>What is reconciliation?</h3>\n</li>\n</ol>\n<h4>(<a href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reconciliation</a>란 무엇인가요?)</h4>\n<p>Component 의 props 또는 state가 변경될 때 React는 새로 반환된 component를 이전에 rendered 된 component와 비교하여 DOM update가 필요한지 결정합니다. 두개의 component가 같지 않을때 React는 DOM을 update합니다. 이를 프로세스 reconciliation 라고합니다.</p>\n<ol>\n<li>\n<h3>How to set state with a dynamic key name?</h3>\n</li>\n</ol>\n<h4>(동적 key name 으로 어떻게 set State를 하나요?)</h4>\n<p>만약 ES6 나 babel transpiler 사용하여 JSX 코드를 변환하는 경우 computed property names 으로 작업을 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">handleInputChange(event) {\n  this.setState({ [event.target.id]: event.target.value })\n}</code></pre></div>\n<h4>render에서 함수 사용 시 주의사항</h4>\n<ul>\n<li>function을 parameter로 전달하는 동안 function 이 호출되지 않았는지 확인(괄호 없이 전달)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">// 틀림\nrender() {\n  // Wrong: handleClick이 호출되었습니다. \n  return &lt;button onClick={this.handleClick()}&gt;{&#39;Click Me&#39;}&lt;/button&gt;\n}\n\n// 맞음\nrender() {\n  // Correct: handleClick가 참조로 사용되었습니다.\n  return &lt;button onClick={this.handleClick}&gt;{&#39;Click Me&#39;}&lt;/button&gt;\n}</code></pre></div>\n<ol>\n<li>\n<h3>Why is it necessary to capitalize component names?</h3>\n</li>\n</ol>\n<h4>(왜 Component 의 이름은 대문자로 표기해야하나요?)</h4>\n<p>Component 들은 DOM element가 아니기 때문에 대문자 표기가 필요합니다. component들은 constructors입니다. 또한 JSX 에서의 소문자 태그 이름은 component가 아닌 HTML 요소를 나타내기 때문입니다.</p>\n<ol>\n<li>\n<h3>Why React uses className over class attribute?</h3>\n</li>\n</ol>\n<h4>(왜 React 는 class를 사용하지 않고 className 속성을 사용하나요?)</h4>\n<ul>\n<li>class는 Javascript 의 키워드. JSX는 Javascript 의 확장</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">render() {\n  return &lt;span className={&#39;menu navigation-menu&#39;}&gt;{&#39;Menu&#39;}&lt;/span&gt;\n}</code></pre></div>\n<h3></h3>\n<h3>Fragment</h3>\n<ul>\n<li>여러 Component 들을 반환하는데 사용되는 React의 일반적인 패턴</li>\n<li>fragments를 사용하면 DOM에 node 들을 추가하지 않고 하위 목록을 그룹화 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">render() {\n  return (\n    &lt;React.Fragment&gt;\n      &lt;ChildA /&gt;\n      &lt;ChildB /&gt;\n      &lt;ChildC /&gt;\n    &lt;/React.Fragment&gt;\n  )\n}</code></pre></div>\n<p>더 짧은 구문도 있지만, 많은 tool 들에서 지원되지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">render() {\n  return (\n    &lt;&gt;\n      &lt;ChildA /&gt;\n      &lt;ChildB /&gt;\n      &lt;ChildC /&gt;\n    &lt;/&gt;\n  )\n}</code></pre></div>\n<h3>(왜 fragments 가 div 보다 좋나요 ?)</h3>\n<ol>\n<li>Fragments 는 빠르고 DOM node를 만들지 않기 때문에 메모리를 적게 사용합니다. 이것은 매우 크고 깊은 트리에서 이익을 가집니다.</li>\n<li>Flexbox 나 CSS Grid과 같은 CSS 메커니즘에는 특별한 부모 - 자식 관계를 가지고 있습니다. 중간에 div 들을 추가하게 된다면 layout을 유지하기 어려워집니다.</li>\n<li>DOM Inspector은 덜 복잡합니다.</li>\n<li>\n<h3>What are portals in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 portals은 무엇입니까 ?)</h4>\n<p>portals 은 상위 Component 의 DOM 계층 구조 외부에 존재하는 DOM 노드로 자식을 render 하는데 권장되는 방법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ReactDOM.createPortal(child, container);</code></pre></div>\n<p>첫 번째 인자는 렌더링 가능한 React 하위요소 (element, string, fragment) 입니다. 두 번째 인자는 DOM element 입니다.</p>\n<ol>\n<li>\n<h3>What are stateless components?</h3>\n</li>\n</ol>\n<h4>(stateless 컴포넌트는 무엇인가요?)</h4>\n<p>Component의 동작과 상태가 독립적이라면 stateless component 를 구성할 수 있습니다. stateless component 는 class나 function 을 이용하여 만들 수 있습니다. lifecycle hook을 사용해야하는 경우가 아니라면 function component를 사용할 수 있습니다. function component를 사용한다면 많은 이점이 있습니다. 쓰기, 이해 그리고 테스트가 빠르고 쉽습니다.</p>\n<ol>\n<li>\n<h3>What are stateful components?</h3>\n</li>\n</ol>\n<h4>(stateful components 는 무엇인가요?)</h4>\n<p>Component 의 동작이 component의 state에 의존한다면 stateful component라고 부를 수 있습니다. stateful component 는 항상 class components 이고, constructor에서 초기화합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  render() {\n    // ...\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>How to apply validation on props in React?</h3>\n</li>\n</ol>\n<h4>(React에서 Props의 유효성검사를 적용하나요 ?)</h4>\n<p>Application 이 개발 모드에서 실행될 때 React는 자동으로 component에 설정된 모든 props 들의 유효성을 체크합니다. 타입이 올바르지 않다면 React는 console에 경고 메세지를 생성할 것 입니다. 성능에 영향이 가기 때문에 production 모드에서는 사용하지 않습니다. 필수 props는 isRequired로 정의됩니다.</p>\n<p>정의 된 props 타입</p>\n<ul>\n<li>PropTypes.number</li>\n<li>PropTypes.string</li>\n<li>PropTypes.array</li>\n<li>PropTypes.object</li>\n<li>PropTypes.func</li>\n<li>PropTypes.node</li>\n<li>PropTypes.element</li>\n<li>PropTypes.bool</li>\n<li>PropTypes.symbol</li>\n<li>PropTypes.any</li>\n</ul>\n<p>User component 에 대한 PropTypes 를 아래와 같이 정의할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nclass User extends React.Component {\n  static propTypes = {\n    name: PropTypes.string.isRequired,\n    age: PropTypes.number.isRequired\n  };\n\n  render() {\n    return (\n      &lt;>\n        &lt;h1>{`Welcome, ${this.props.name}`}&lt;/h1>\n        &lt;h2>{`Age, ${this.props.age}`}&lt;/h2>\n      &lt;/>\n    );\n  }\n}</code></pre></div>\n<p>Note: React v15.5 에서 PropType은 React.PropTypes 에서 prop-types 라이브러리로 옮겨졌습니다.</p>\n<ol>\n<li>\n<h3>What are the advantages of React?</h3>\n</li>\n</ol>\n<h4>(React의 장점은 무엇인가요?)</h4>\n<ol>\n<li>가상 DOM을 이용하여 application 의 성능을 향상시킵니다.</li>\n<li>JSX는 코드를 읽고 쓰는 것을 쉽게 만들어줍니다.</li>\n<li>클라이언트와 서버측 (SSR) 모두 render 됩니다.</li>\n<li>오직 view library 이기 때문에 다른 프레임워크들 (Angular, Backbone)과 손쉽게 통합 할 수 있습니다.</li>\n<li>Jest 와 같은 도구를 사용하여 단위 및 통합테스트를 쉽게 작성할 수 있습니다.</li>\n</ol>\n<h3></h3>\n<h4>(React의 한계는 무엇인가요?)</h4>\n<ol>\n<li>React 전체 framework 가 아닌 view를 위한 library 일 뿐입니다.</li>\n<li>웹 개발을 처음 접하는 초심자들에게는 학습 곡선이 있습니다.</li>\n<li>기존의 MVC framework 에 React 를 합치기 위해서는 몇 가지 추가 구성이 필요합니다.</li>\n<li>인라인 템플릿 및 JSX를 사용하면 코드가 복잡해집니다.</li>\n<li>과도한 엔지니어링 또는 boilerplate 로 이어지는 작은 components 들이 너무 많습니다.</li>\n</ol>\n<h3></h3>\n<h4>(React v16 에서 error boundaries는 무엇인가요?)</h4>\n<p>Error boundaries 는 하위 component tree 에서 Javascript error 를 catch 하고, 에러를 기록하고, 오류가 발생한 component tree가 아닌 대체 UI를 표현해 주는 component 입니다.</p>\n<p>class component 는 componentDidCatch 라는 새로운 lifecycle 메서드를 정의하면 Error boundaries 됩니다</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error, info) {\n    // Display fallback UI\n    this.setState({ hasError: true });\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return &lt;h1&gt;{&quot;Something went wrong.&quot;}&lt;/h1&gt;;\n    }\n    return this.props.children;\n  }\n}</code></pre></div>\n<p>그 다음 일반 component 로 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;ErrorBoundary>\n  &lt;MyWidget />\n&lt;/ErrorBoundary></code></pre></div>\n<ol>\n<li>\n<h3>How error boundaries handled in React v15?</h3>\n</li>\n</ol>\n<h4>(React v15 에서는 어떻게 error boundaries 처리하나요?)</h4>\n<p>React v15 에서는 unstable_handleError 메서드를 사용하여 error boundaries 에 대한 기본적인 지원을 했습니다. React v16에서 componentDidCatch로 이름이 변경되었습니다.</p>\n<h3></h3>\n<h4>(권장되는 static 한 타입 체크방법은 무엇인가요?)</h4>\n<p>일반적으로 우리는 React application 에서 타입 검사를 하기 위해 PropTypes library (React.PropTypes를 React v15.5 부터는 prop-types package 로 옮겼습니다)를 사용합니다. 대규모의 코드 베이스에서는 compile time 에서 타입 체크를 하고 자동 완성 기능을 제공해주는 Flow 나 TypeScript 와 같은 static type checkers 를 이용하는 것이 좋습니다.</p>\n<ol>\n<li>\n<h3>What is the use of react-dom package?</h3>\n</li>\n</ol>\n<h4>(react-dom 패키지의 사용법은 무엇인가요?)</h4>\n<p>React-dom 패키지는 App의 최상위 레벨에서 사용할 수 있는 DOM-specific 메서드를 제공합니다. 대부분의 Component 들은 이 모듈을 사용할 필요가 없습니다. 패키지의 일부 메서드는 다음과 같습니다.</p>\n<ul>\n<li>render()</li>\n<li>hydrate()</li>\n<li>unmountComponentAtNode()</li>\n<li>findDOMNode()</li>\n<li>createPortal()</li>\n</ul>\n<h3></h3>\n<h4>(React dom의 render 메서드의 목적은 무엇인가요?)</h4>\n<p>render 메서드는 제공된 컨테이너의 DOM에 React element를 render 하고 Component에 대한 참조를 반환하는데 사용됩니다. React element가 이전에 렌더링 되었다면 update 를 수행하고 최근의 변경사항을 반영하기 위해 필요에 따라 DOM을 변경합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ReactDOM.render(element, container[, callback])</code></pre></div>\n<p>만약 optional callback 이 제공된다면, callback은 component 가 렌더링되거나 업데이트 된 후에 실행됩니다.</p>\n<h3>(ReactDOMServer 란 무엇인가요?)</h3>\n<p>ReactDOMServer 객체를 사용하면 component를 static markup(일반적으로 노드 서버에서 사용됩니다.) 으로 렌더링 할 수 있습니다. 이 객체는 주로 서버사이드 렌더링(SSR) 에서 사용됩니다. 다음의 메서드는 서버 및 브라우저 환경 모두 사용할 수 있습니다.</p>\n<ul>\n<li>renderToString()</li>\n<li>renderToStaticMarkup()</li>\n</ul>\n<p>예를들어 Express, Hapi, Koa 같은 노드 기반의 웹서버를 실행할때 renderToString을 호출하여 root component 를 문자열로 렌더링 한 다음 response를 보낼 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">// using Express\nimport { renderToString } from &quot;react-dom/server&quot;;\nimport MyPage from &quot;./MyPage&quot;;\n\napp.get(&quot;/&quot;, (req, res) =&gt; {\n  res.write(&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);\n  res.write(&#39;&lt;div id=&quot;content&quot;&gt;&#39;);\n  res.write(renderToString(&lt;MyPage /&gt;));\n  res.write(&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);\n  res.end();\n});</code></pre></div>\n<h3></h3>\n<h4>(React에서 innerHTML을 어떻게 사용하나요?)</h4>\n<ul>\n<li>dangerouslySetInnerHTML : 브라우저 DOM 에서 innerHTML 을 사용하기 위한 React 의 대체 속성</li>\n<li>innerHTML과 마찬가지로 XXS (Cross-Site Scripting) 공격을 고려했을때 브라우저 DOM 에서 이 속성을 사용하는 것은 위험</li>\n<li>__html 객체를 키로 HTML 텍스트를 값으로 전달</li>\n</ul>\n<p>예제에서 MyComponent는 HTML 마크업을 설정하기 위해 dangerouslySetInnerHTML 속성을 사용하고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createMarkup() {\n  return { __html: \"First &amp;middot; Second\" };\n}\n\nfunction MyComponent() {\n  return &lt;div dangerouslySetInnerHTML={createMarkup()} />;\n}</code></pre></div>\n<ol>\n<li>\n<h3>How to use styles in React?</h3>\n</li>\n</ol>\n<h4>(React 스타일을 어떻게 사용하나요?)</h4>\n<p>style 속성은 CSS 문자열 대신 camelCased 속성의 Javascript 객체를 허용합니다. 이것은 DOM Style Javascript 속성과 일치하며 효율적이고, XSS 보안의 허점을 방지할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const divStyle = {\n  color: \"blue\",\n  backgroundImage: \"url(\" + imgUrl + \")\"\n};\n\nfunction HelloWorldComponent() {\n  return &lt;div style={divStyle}>Hello World!&lt;/div>;\n}</code></pre></div>\n<p>Style의 key는 Javascript DOM Node (예 : node.style.backgroundImage)의 속성에 접근하는 것과 일관되게 하기 위해 camelCased 를 사용합니다.</p>\n<ol>\n<li>\n<h3>How events are different in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 이벤트는 어떻게 다른가요?)</h4>\n<p>React element 에서의 이벤트 처리는 몇가지 문법상 차이점이 있습니다.</p>\n<ul>\n<li>React 이벤트 핸들러는 소문자보다는 camelCase 를 사용합니다.</li>\n<li>JSX 에서는 문자열이 아닌 이벤트 핸들러를 통해 function 을 전달합니다.</li>\n<li>\n<h3>What will happen if you use setState() in constructor?</h3>\n</li>\n</ul>\n<h4>(constructor 에서 setState를 사용하면 무슨일이 생기나요? )</h4>\n<p>setState() 를 사용할 때 객체 상태가 할당되고 또한 component 와 모든 자식들을 재렌더링 합니다. 이런 에러를 봤을겁니다. <code class=\"language-text\">Can only update a mounted or mounting component</code>. 그래서 우리는 this.state 를 사용하여 constructor 내부의 변수를 초기화 해야합니다.</p>\n<ol>\n<li>\n<h3>What is the impact of indexes as keys?</h3>\n</li>\n</ol>\n<h4>(index 가 key 로 미치는 영향은 무엇인가요?)</h4>\n<p>React element 가 추적할 수 있도록 key 는 안정적, 예측가능, 고유 하여야합니다. 아래 코드 조각에서의 각 element 의 key 는 데이터를 따르지 않고 순서에 따라 결정됩니다. 이것은 React 가 할 수 있는 최적화를 제한합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">{\n  todos.map((todo, index) =&gt; &lt;Todo {...todo} key={index} /&gt;);\n}</code></pre></div>\n<p>만약 element 에 data 의 고유한 키값을 사용한다면, todo.id 가 목록에서 고유하고, 안정적이라고 가정한다면 React 는 elements 를 재평가 할 필요없이 element 를 재정렬 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">{\n  todos.map(todo =&gt; &lt;Todo {...todo} key={todo.id} /&gt;);\n}</code></pre></div>\n<ol>\n<li>\n<h3>Is it good to use setState() in componentWillMount() method?</h3>\n</li>\n</ol>\n<h4>(componentWillMount 에서 setState를 사용하는게 좋나요 ?)</h4>\n<p><code class=\"language-text\">componentWillMount</code> 안에서는 비동기적인 초기화는 피하는 것이 좋습니다.</p>\n<p><code class=\"language-text\">componentWillMount</code> 는 마운트가 실행되기 직전에 호출됩니다.</p>\n<p>render () 전에 호출되기 때문에 상태를 설정하더라도 re-render 되지 않습니다.</p>\n<p><code class=\"language-text\">componentWillMount</code> 에서는 side-effects or subscriptions 을 피해야합니다.</p>\n<p>우리는 <code class=\"language-text\">componentWillMount</code> 대신 <code class=\"language-text\">componentDidMount</code> 에서 component 초기화를 위한 비동기 호출을 실행해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentDidMount() {\n  axios.get(`api/todos`)\n    .then((result) => {\n      this.setState({\n        messages: [...result.data]\n      })\n    })\n}</code></pre></div>\n<ol>\n<li>\n<h3>What will happen if you use props in initial state?</h3>\n</li>\n</ol>\n<h4>(state 의 초기상태에서 props 를 사용하면 어떻게되나요?)</h4>\n<p>만약 component 를 새로 고치지 않고 component 의 props 를 변경한다면 생성자 함수가 component 의 현재 상태를 업데이트 하지 않습니다. 새로운 props 의 값이 표시되지 않습니다. state 의 초기화는 component 를 처음 만들 때만 실행됩니다.</p>\n<p>아래의 component 는 업데이트 된 input 의 값을 표시하지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      records: [],\n      inputValue: this.props.inputValue\n    };\n  }\n\n  render() {\n    return &lt;div&gt;{this.state.inputValue}&lt;/div&gt;;\n  }\n}</code></pre></div>\n<p>render 메소드 안에서 props 를 사용하면 값이 업데이트 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      record: []\n    };\n  }\n\n  render() {\n    return &lt;div&gt;{this.props.inputValue}&lt;/div&gt;;\n  }\n}</code></pre></div>\n<h3></h3>\n<h4>(조건에 따른 component 렌더링은 어떻게 하나요 ?)</h4>\n<p>경우에 따라서 state 에 의존하여 다르게 component 를 렌더링 하기를 원할것이다. JSX 는 false 또는 undefined 때는 렌더링하지 않으므로 조건을 사용하여 특정 조건이 true 인 경우에만 component의 특정 부분을 렌더링 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">const MyComponent = ({ name, address }) =&gt; (\n  &lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    {address &amp;&amp; &lt;p&gt;{address}&lt;/p&gt;}\n  &lt;/div&gt;\n);</code></pre></div>\n<p>만약 if-else 를 사용하기를 원한다면 삼항연산자를 쓰세요</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">const MyComponent = ({ name, address }) =&gt; (\n  &lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    {address ? &lt;p&gt;{address}&lt;/p&gt; : &lt;p&gt;{&quot;Address is not available&quot;}&lt;/p&gt;}\n  &lt;/div&gt;\n);</code></pre></div>\n<h3></h3>\n<h4>(DOM element 에 props 를 spreading 할때 왜 조심해야 하나요?)</h4>\n<p>props 를 spreading 할 때 알려지지않은 HTML 속성을 추가 할 위험이 있습니다. 그것은 좋지않습니다. 대신 …rest 연산자를 사용하여 prop destructuring 을 할 수 있으므로 필요한 props 만 추가할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ComponentA = () => (\n  &lt;ComponentB isDisplay={true} className={\"componentStyle\"} />\n);\n\nconst ComponentB = ({ isDisplay, ...domProps }) => (\n  &lt;div {...domProps}>{\"ComponentB\"}&lt;/div>\n);</code></pre></div>\n<h3></h3>\n<h3>Decorator</h3>\n<p>Class component 를 하나의 function 으로 변환하는 방식으로 decorate 할 수 있습니다. Decorators 는 component 의 기능을 수정하기 위한 유연하고 읽기 쉬운 방법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">@setTitle(&quot;Profile&quot;)\nclass Profile extends React.Component {\n  //....\n}\n\nconst setTitle = title =&gt; WrappedComponent =&gt; {\n  return class extends React.Component {\n    componentDidMount() {\n      document.title = title;\n    }\n\n    render() {\n      return &lt;WrappedComponent {...this.props} /&gt;;\n    }\n  };\n};</code></pre></div>\n<p>NOTE: Decorators 는 ES7 에 포함되지 않았습니다. 현재 stage 2 에 제안되어 있습니다.</p>\n<h3></h3>\n<h4>memoize component</h4>\n<p>function component 에 사용할 수 있는 memoize 라이브러리가 있습니다. 예를 들면 <code class=\"language-text\">moize</code> 라이브러리는 다른 component 에 component 를 memoize 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">import moize from &quot;moize&quot;;\nimport Component from &quot;./components/Component&quot;; // this module exports a non-memoized component\n\nconst MemoizedFoo = moize.react(Component);\n\nconst Consumer = () =&gt; {\n  &lt;div&gt;\n    {&quot;I will memoize the following entry:&quot;}\n    &lt;MemoizedFoo /&gt;\n  &lt;/div&gt;;\n};</code></pre></div>\n<h4>Server Side Rendering(SSR)</h4>\n<p>React 는 이미 Node 서버에서 렌더링을 처리할 수 있도록 준비되어 있습니다. 특수한 버전의 DOM renderer 를 사용할 수 있으며, client side 와 동일한 패턴을 따릅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">import ReactDOMServer from &quot;react-dom/server&quot;;\nimport App from &quot;./App&quot;;\n\nReactDOMServer.renderToString(&lt;App /&gt;);</code></pre></div>\n<p>이 method 는 HTML 을 문자열로 내보내고, 문자열은 서버 응답의 일부로 페이지 본문 내부에 배치 할 수 있습니다. client side 에서 React 는 이미 렌더링된 content 를 감지하여 중단된 부분을 원활히 처리합니다.</p>\n<h4>production 모드</h4>\n<p>Webpack 의 DefinePlugin 메서드를 사용하여 NODE_ENV 를 production 으로 설정해야 propType 의 유효성 검사 및 추가적인 경고 같은 것들을 제거할 수 있습니다.</p>\n<p>production 모드와는 별도로 코드를 minify 하면 Uglify 의 dead-code 의 제거와 주석을 제거하여 bundle 크기를 줄일 수 있습니다.</p>\n<h4>(CRA는 무엇이고 CRA의 이점은 무엇인가요?)</h4>\n<p>Create-Reaction-App CLI 사용하면 설정 단계 없이 React applications 생성하고 실행할 수 있습니다.</p>\n<p>CRA 를 사용하여 Todo App 을 만듭니다</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Installation</span>\n$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> -g create-react-app\n\n<span class=\"token comment\"># Create new project</span>\n$ create-react-app todo-app\n$ <span class=\"token builtin class-name\">cd</span> todo-app\n\n<span class=\"token comment\"># Build, test and run</span>\n$ <span class=\"token function\">npm</span> run build\n$ <span class=\"token function\">npm</span> run <span class=\"token builtin class-name\">test</span>\n$ <span class=\"token function\">npm</span> start</code></pre></div>\n<ol>\n<li>\n<h3>What is the lifecycle methods order in mounting?</h3>\n</li>\n</ol>\n<h4>(마운팅에서 lifecycle 메서드의 순서는 무엇인가요?)</h4>\n<p>lifecycle 메서드는 component 의 instance 가 생성되어 DOM에 삽입 될 때 호출됩니다.</p>\n<ul>\n<li>constructor()</li>\n<li>static getDerivedStateFromProps()</li>\n<li>render()</li>\n<li>componentDidMount()</li>\n</ul>\n<h3></h3>\n<h4>React v16 에서 사용되지 않을 lifecycle 메서드</h4>\n<p>안전하지 않은 코딩 방법이 될 수 있는 lifecycle 메서드는 비동기적으로 렌더링시 문제가 될 것 입니다.</p>\n<ul>\n<li>componentWillMount()</li>\n<li>componentWillReceiveProps()</li>\n<li>componentWillUpdate()</li>\n</ul>\n<p>React v16.3 부터는 UNSAFE_가 prefix 붙고, prefix 가 없는 버전은 React v17 에서 제거됩니다.</p>\n<h3></h3>\n<h4>getDerivedStateFromProps() lifecycle 메서드의 목적</h4>\n<p>새로운 정적 getDerivedStateFromProps() lifecycle 메서드는 component 가 인스턴스화 된 후, 다시 렌더링 되기 전에 호출됩니다.\nobject 를 반환하여 state 를 update 하거나, null 을 반환하여 새로운 props 에서 state update 가 필요하지 않음을 나타낼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">class MyComponent extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    // ...\n  }\n}</code></pre></div>\n<p>이 lifecycle 메서드는 componentDidUpdate() 와 함께 componentWillReceiveProps() 의 사용 사례에 적용할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What is the purpose of getSnapshotBeforeUpdate() lifecycle method?</h3>\n</li>\n</ol>\n<h4>(getSnapshotBeforeUpdate() lifecycle 메서드의 목적은 무엇인가요?)</h4>\n<p>새로운 <a href=\"https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">getSnapshotBeforeUpdate()</a> lifecycle 메서드는 DOM update 직전에 호출됩니다. 이 메서드의 반환값은 componentDidUpdate() 의 세번째 파라미터로 전달됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // ...\n  }\n}</code></pre></div>\n<p>이 lifecycle 메서드는 componentDidUpdate()와 함께 componentWillUpdate () 의 사용 사례에 적용할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What is the difference between createElement() and cloneElement() methods</h3>\n</li>\n</ol>\n<h4>(createElement() 와 cloneElement() 의 차이점은 무엇인가요?)</h4>\n<p>JSX 에서 React element 는 UI element 를 타내는 React.createElement() 변환됩니다.\nReact.cloneElement ()는 element 를 복제하고 새로운 props를 전달하는데 사용됩니다.</p>\n<ol>\n<li>\n<h3>What is the recommended way for naming components?</h3>\n</li>\n</ol>\n<h4>(component 의 이름을 지정하는 권장방법은 무엇인가요?)</h4>\n<p>displayName 대신 reference 를 이용하여 component 의 이름을 정하는 것을 추천한다.</p>\n<p>displayName 사용</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export default React.createClass({\n  displayName: \"TodoApp\"\n  // ...\n});</code></pre></div>\n<p>추천 방법:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export default class TodoApp extends React.Component {\n  // ...\n}</code></pre></div>\n<ol>\n<li>\n<h3>What is the recommended ordering of methods in component class?</h3>\n</li>\n</ol>\n<h4>(component class 안에서 메서드의 추천 순서는 무엇인가요?)</h4>\n<p>마운트에서 부터 렌더링 단계까지의 권장 메서드 지정 순서</p>\n<ul>\n<li>static methods</li>\n<li>constructor()</li>\n<li>getChildContext()</li>\n<li>componentWillMount()</li>\n<li>componentDidMount()</li>\n<li>componentWillReceiveProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>componentWillUpdate()</li>\n<li>componentDidUpdate()</li>\n<li>componentWillUnmount()</li>\n<li>click handlers or event handlers like onClickSubmit() or onChangeDescription()</li>\n<li>getter methods for render like getSelectReason() or getFooterContent()</li>\n<li>optional render methods like renderNavigation() or renderProfilePicture()</li>\n<li>render()</li>\n</ul>\n<h3></h3>\n<h4>(switching component 란 무엇인가요?)</h4>\n<p>switching component는 여러 component 중 하나의를 렌더링 하는 component 입니다. 우리는 props 값을 매핑하기 위해 object 를 사용해야합니다.</p>\n<p>예를 들어, switching component 는 페이지의 props 를 기반으로 다른 component 를 보여줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">import HomePage from &quot;./HomePage&quot;;\nimport AboutPage from &quot;./AboutPage&quot;;\nimport ServicesPage from &quot;./ServicesPage&quot;;\nimport ContactPage from &quot;./ContactPage&quot;;\n\nconst PAGES = {\n  home: HomePage,\n  about: AboutPage,\n  services: ServicesPage,\n  contact: ContactPage\n};\n\nconst Page = props =&gt; {\n  const Handler = PAGES[props.page] || ContactPage;\n  return &lt;Handler {...props} /&gt;;\n};\n\n// The keys of the PAGES object can be used in the prop types to catch dev-time errors.\nPage.propTypes = {\n  page: PropTypes.oneOf(Object.keys(PAGES)).isRequired\n};</code></pre></div>\n<ol>\n<li>\n<h3>Why we need to pass a function to setState()?</h3>\n</li>\n</ol>\n<h4>(왜 setState 에 함수를 전달해야하나요?)</h4>\n<p>이유는 setState 가 비동기적인 작업이기 때문입니다. 성능상의 이유로 state 의 변경은 일괄적으로 일어납니다, 그래서 setState() 의 호출 직후에 state가 변경되지 않을 수 있습니다.\nstate 를 확실할 수 없기 때문에 setState()를 호출 할 때 현재의 state에 의존하면 안됩니다.\n해결책은 이전 state를 인자로 사용하는 setState()에 함수를 전달하는 것입니다.\n그렇게 하면 setState()가 가진 비동기성으로 인해 사용자가 접근할때 이전 state의 값을 가져오는 문제를 피할 수 있습니다.</p>\n<p>초기의 count 값이 0 이라고 가정하겠습니다. 세번의 증가연산 후의 값은 오직 1만 증가합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// assuming this.state.count === 0\nthis.setState({ count: this.state.count + 1 });\nthis.setState({ count: this.state.count + 1 });\nthis.setState({ count: this.state.count + 1 });\n// this.state.count === 1, not 3</code></pre></div>\n<p>setState() 에 함수를 전달하면 올바르게 증가합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.setState((prevState, props) => ({\n  count: prevState.count + props.increment\n}));\n// this.state.count === 3 as expected</code></pre></div>\n<ol>\n<li>\n<h3>What is strict mode in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 strict mode 는 무엇인가요?)</h4>\n<p>React.StrictMode 는 application 의 잠재적인 문제를 강조 표시하는데 유용한 component 입니다. <code class=\"language-text\">&lt;Fragment></code>처럼, <code class=\"language-text\">&lt;StrictMode></code> 도 추가적으로 DOM을 렌더링하지 않습니다. 자식에 대한 추가적인 확인과 경고를 활성화합니다. 검사는 개발 모드에만 적용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\n\nfunction ExampleApplication() {\n  return (\n    &lt;div>\n      &lt;Header />\n      &lt;React.StrictMode>\n        &lt;div>\n          &lt;ComponentOne />\n          &lt;ComponentTwo />\n        &lt;/div>\n      &lt;/React.StrictMode>\n      &lt;Footer />\n    &lt;/div>\n  );\n}</code></pre></div>\n<p>위의 예제에서 strict mode 는 와 에만 적용됩니다.\n<code class=\"language-text\">&lt;StrictMode></code> 는 다음과 같은 도움을 줍니다.</p>\n<ul>\n<li>안전하지 않은 lifecycle 메서드를 식별합니다.</li>\n<li>레거시 string ref API 에 대한 경고</li>\n<li>예상치 못한 사이드 이펙트 감지</li>\n<li>legacy context API 감지</li>\n</ul>\n<h3></h3>\n<h4>(React Mixins은 무엇인가요?)</h4>\n<p>Mixins은 공통적인 기능을 가질 수 있도록 component를 분리하는 방법입니다. Mixins은 사용하지 말아야합니다. higher-order components 또는 decorators 로 대체할 수 있습니다.\nprops와 state가 이전의 props 와 state 가 얕게 같을때 불필요한 재 렌더링을 방지하기 위해 component 에서 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const PureRenderMixin = require(\"react-addons-pure-render-mixin\");\n\nconst Button = React.createClass({\n  mixins: [PureRenderMixin]\n  // ...\n});</code></pre></div>\n<h3></h3>\n<h4>(왜 isMounted() 가 안티패턴이고 해결책은 무엇인가요?)</h4>\n<p>isMounted() 의 사용 사례는 component의 마운트가 해제 된 후에 setState()를 호출하지 않도록 하는 것입니다. component 마운트가 해제된 후 경고가 발생되기 때문입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (this.isMounted()) {\n  this.setState({...})\n}</code></pre></div>\n<p>setState() 를 호출하기 전에 isMounted() 를 검사한다면 경고를 제거할 수 있지만, 경고의 목적을 잃어버릴 수 있습니다. component의 마운트가 해제된 후에 reference 를 가지고 있다고 생각하기 때문에 isMounted()를 사용하는 것은 <a href=\"https://ko.wikipedia.org/wiki/%EC%BD%94%EB%93%9C_%EC%8A%A4%EB%A9%9C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">code smell</a> 입니다.</p>\n<p>최적의 해결법은 component의 마운트가 해제된 후 setState() 가 호출될 수 있는 위치를 찾아 수정하는 것입니다. 이러한 상황은 component가 데이터를 기다리고 데이터가 도착하기전 마운트가 해제될 때, 콜백으로 인해 많이 발생됩니다. 콜백은 마운트가 해제되기전에 componentWillUnmount 단계에서 취소되어야합니다.</p>\n<h3></h3>\n<h4>(React 에서 지원하는 Pointer Events 는 무엇인가요?)</h4>\n<p>Pointer Events 는 모든 입력 이벤트를 다루는 통일된 방법을 제공합니다. 옛날에는 마우스와 각각 event listeners 를 다뤘지만, 요즘에는 터치스크린, 펜이 있는 휴대전화와 같이 마우스와 상관이 없는 많이 장치가 있습니다. 이런 이벤트들은 Pointer Events 를 지원하는 브라우저에서만 동작하는 것을 기억해야합니다.</p>\n<p>React DOM 에서는 다음과 같은 event 를 사용할 수 있습니다.</p>\n<ul>\n<li>onPointerDown</li>\n<li>onPointerMove</li>\n<li>onPointerUp</li>\n<li>onPointerCancel</li>\n<li>onGotPointerCapture</li>\n<li>onLostPointerCaptur</li>\n<li>onPointerEnter</li>\n<li>onPointerLeave</li>\n<li>onPointerOver</li>\n<li>onPointerOut</li>\n<li>\n<h3>Why should component names start with capital letter?</h3>\n</li>\n</ul>\n<h4>(왜 Component 의 이름은 대문자로 시작해야하나요?)</h4>\n<p>만약 JSX 를 사용하여 component 를 렌더링하는 경우 component 의 이름은 대문자로 시작하여야 합니다. 그렇지 않으면 React 는 알 수 없는 태그로 인식하여 오류가 발생될 것 입니다. 이 규칙은 HTML 과 SVG 태그만 소문자로 시작할 수 있기 때문에 사용됩니다.</p>\n<p>이름이 소문자로 시작하는 component class 를 정의할 수 있지만 가져올떄는 대문자여야 합니다.</p>\n<p>여기 소문자는 괜찮습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class myComponent extends Component {\n  render() {\n    return &lt;div />;\n  }\n}\n\nexport default myComponent;</code></pre></div>\n<p>다른 파일에서 가져올때는 대문자로 시작해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import MyComponent from \"./MyComponent\";</code></pre></div>\n<h3></h3>\n<h4>(React v16 에서 사용자 정의 DOM 속성이 지원되나요?)</h4>\n<p>네 지원됩니다. 과거 React 는 알려지지 않은 DOM 속성은 무시되었었습니다. React 가 인식하지 못하는 속성을 가진 JSX 를 작성한다면 React 는 건너뛸 것 입니다.</p>\n<p>예를 들면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div mycustomattribute={\"something\"} /></code></pre></div>\n<p>React v15 에서 빈 div 를 DOM 에 렌더링합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div /></code></pre></div>\n<p>React v16 에서 알 수 없는 속성은 DOM 에 포함됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div mycustomattribute=\"something\" /></code></pre></div>\n<p>이 기능은 브라우저 별로 비표준 속성을 제공하고, 새로운 DOM API 를 시도, 다른 라이브러리와 같이 사용할 때 유용합니다.</p>\n<h3>(constructor 와 getInitialState의 차이점은 무엇인가요?)</h3>\n<p>ES6 클래스를 사용할 떄는 constructor에서 state를 초기화할 수 있고, React.createClass 를 사용할 때는 getInitialState() 에서 상태를 초기화해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">// ES6 클래스 사용\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      /* initial state */\n    };\n  }\n}\n\n// React.createClass() 사용\nconst MyComponent = React.createClass({\n  getInitialState() {\n    return {\n      /* initial state */\n    };\n  }\n});</code></pre></div>\n<p><strong>Note</strong>: React.createClass() 는 이제 사용되지 않고, React v16 에서 제거됩니다. 대신 JS class 를 사용하세요</p>\n<h3></h3>\n<h4>(setState 를 호출하지 않고 component 를 강제로 재 렌더링 시킬 수 있나요?)</h4>\n<p>기본적으로, component 의 state 또는 props 가 변경되면 component 는 다시 렌더링됩니다. render() 메소드가 다른 data 에 의존성이 있는 경우, forceUpdate() 를 호출하여 component에게 다시 렌더링이 필요하다고 알려줄 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">component.forceUpdate(callback);</code></pre></div>\n<p>forceUpdate() 의 사용은 피하고 render() 안의 this.props 와 this.state 는 읽는 용도로 사용하는 것이 좋습니다.</p>\n<h3></h3>\n<h4>ES6 class 를 사용하는 React 에서 super() 와 super(props) 의 차이점은 무엇인가요?</h4>\n<p>constructor() 에서 this.props 에 접근하고 싶을때 super() 메서드에 props 를 전달해야합니다.</p>\n<p><strong>super(props)를 사용:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log(this.props); // { name: 'John', ... }\n  }\n}</code></pre></div>\n<p><strong>super() 를 사용:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super();\n    console.log(this.props); // undefined\n  }\n}</code></pre></div>\n<p>constructor() 의 밖에서의 this.props 에는 같은 값이 표시됩니다.</p>\n<h3></h3>\n<h4>어떻게 JSX 안에서 loop 를 하나요?</h4>\n<p>ES6 arrow function 과 함께 Array.prototype.map 를 사용할 수 있습니다. 예를 들어, 객체의 items 배열은 component 의 배열로 맵핑됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;tbody>\n  {items.map(item => (\n    &lt;SomeComponent key={item.id} name={item.name} />\n  ))}\n&lt;/tbody></code></pre></div>\n<p>for loop 를 사용하여 반복할 수 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;tbody>\n  for (let i = 0; i &lt; items.length; i++) {\n    &lt;SomeComponent key={items[i].id} name={items[i].name} />\n  }\n&lt;/tbody></code></pre></div>\n<p>JSX 태그는 함수 호출로 변환되어지기 떄문에 표현식 안에서 JS 표현법을 사용할 수 없습니다. 이것은 stage 1 에 제안되어 변경되어질 수 있습니다.</p>\n<h3>(attribute 따옴표에서 props 에 어떻게 접근하나요?)</h3>\n<p>React (또는 JSX) 는 속성 값 안에 써넣은 값은 지원되지 않습니다. 아래의 표현식은 동작하지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;img className=\"image\" src=\"images/{this.props.image}\" /></code></pre></div>\n<p>그러나 중괄호 안에 JS 표현식을 감싸 속성 값으로 넣을 수 있습니다. 아래의 표현식은 동작합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;img className=\"image\" src={\"images/\" + this.props.image} /></code></pre></div>\n<p>템플릿 문자열을 사용해도 동작합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;img className=\"image\" src={`images/${this.props.image}`} /></code></pre></div>\n<ol>\n<li>\n<h3>What is React proptype array with shape?</h3>\n</li>\n</ol>\n<p>특정 모양을 가진 component 에 객체 배열을 전달하고 싶다면 React.PropTypes.arrayOf()의 인자로 React.PropTypes.shape() 를 사용하세요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ReactComponent.propTypes = {\n  arrayWithShape: React.PropTypes.arrayOf(\n    React.PropTypes.shape({\n      color: React.PropTypes.string.isRequired,\n      fontSize: React.PropTypes.number.isRequired\n    })\n  ).isRequired\n};</code></pre></div>\n<ol>\n<li>\n<h3>How conditionally apply class attributes?</h3>\n</li>\n</ol>\n<h4>(어떻게 조건에 따라 class 속성을 적용하나요?)</h4>\n<p>따옴표안에 중괄호를 사용하면 string 으로 인식되기 때문에 중괄호를 사용하면 안됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div className=\"btn-panel {this.props.visible ? 'show' : 'hidden'}\"></code></pre></div>\n<p>중괄호 밖으로 옮겨야 합니다. (class 의 이름 사이에 공백을 포함하는 것을 잊으면 안됩니다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div className={'btn-panel ' + (this.props.visible ? 'show' : 'hidden')}></code></pre></div>\n<p>템플릿 문자열을 사용해도 동작합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div className={`btn-panel ${this.props.visible ? 'show' : 'hidden'}`}></code></pre></div>\n<ol>\n<li>\n<h3>What is the difference between React and ReactDOM?</h3>\n</li>\n</ol>\n<h4>(React와 ReactDOM은 무엇이 다른가요?)</h4>\n<p>React package 에는 React.createElement (), React.Component, React.Children 및 element 와 component class 관련된 helper 들이 포함되어 있습니다. 이런 기능들은 component 를 구축하는데 필요한 helpers 로 생각할 수 있습니다. react-dom package 에는 ReactDOM.render () 가 포함되어있고, react-dom/server 에는 ReactDOMServer.renderToString() 과 ReactDOMServer.renderToStaticMarkup() 포함되어있어 서버사이드 렌더링을 지원합니다.</p>\n<ol>\n<li>\n<h3>Why ReactDOM is separated from React?</h3>\n</li>\n</ol>\n<h4>(왜 React 와 ReactDOM은 분리되어있나요?)</h4>\n<p>React 팀은 모든 DOM 과 관련된 기능들을 ReactDOM 이라는 라이브러리로 분리하였습니다. React v0.14 는 ReactDOM 이 분리된 첫번째 릴리즈입니다. React-native, Reaction-Art, Reaction-Canvas, React-3 등 패키지의 일부를 보면 React 의 아름다움과 본질적인 부분이 브라우저나 DOM 과 아무런 관계가 없다는 것을 알 수 있습니다. React 가 렌더링할 수 있는 많은 환경들을 만들기 위해, React 팀은 React 와 React-dom 을 분리할 계획을 세웠습니다. 이것은 웹 버전의 React 와 React native 사이의 공유할 수 있는 component 를 작성하는 방법을 개척합니다.</p>\n<ol>\n<li>\n<h3>How to use React label element?</h3>\n</li>\n</ol>\n<h4>(React 에서 label element 를 어떻게 사용하나요?)</h4>\n<p>표준 <code class=\"language-text\">for</code> 속성을 사용하는 text input 에 바인드된 label element 를 렌더링하려고하면 속성이없는 HTML이 생성되고 console 에 경고가 출력됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;label for={'user'}>{'User'}&lt;/label>\n&lt;input type={'text'} id={'user'} /></code></pre></div>\n<p>for 는 JS 의 예약된 키워드입니다, 대신 htmlFor 를 사용하세요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;label htmlFor={'user'}>{'User'}&lt;/label>\n&lt;input type={'text'} id={'user'} /></code></pre></div>\n<ol>\n<li>\n<h3>How to combine multiple inline style objects?</h3>\n</li>\n</ol>\n<h4>(어떻게 여러개의 inline style object 를 합치나요?)</h4>\n<p>React 에서 spread operator 를 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button style={{ ...styles.panel.button, ...styles.panel.submitButton }}>\n  {\"Submit\"}\n&lt;/button></code></pre></div>\n<p>React Native 를 사용하고 있다면 배열 표기법을 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button style={[styles.panel.button, styles.panel.submitButton]}>\n  {\"Submit\"}\n&lt;/button></code></pre></div>\n<ol>\n<li>\n<h3>How to re-render the view when the browser is resized?</h3>\n</li>\n</ol>\n<h4>(어떻게 브라우저가 resize 될 때 재 렌더링 시키나요?)</h4>\n<p>componentDidMount() 에서 resize 이벤트를 listen 할 수 있고, 크기(width, height)를 update 할 수 있습니다. componentWillUnmount() 에서 listener 를 제거해줘야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class WindowDimensions extends React.Component {\n  componentWillMount() {\n    this.updateDimensions();\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.updateDimensions);\n  }\n\n  updateDimensions() {\n    this.setState({ width: $(window).width(), height: $(window).height() });\n  }\n\n  render() {\n    return (\n      &lt;span>\n        {this.state.width} x {this.state.height}\n      &lt;/span>\n    );\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>What is the difference between setState() and replaceState() methods?</h3>\n</li>\n</ol>\n<h4>(setState() 와 replaceState() 의 차이점은 무엇인가요?)</h4>\n<p>setState() 를 사용하면 이전 state 와 다음 state 가 병합됩니다. replaceState()는 현재 state 를 버리고 당신이 제공한 state 로 바꿉니다. 이전의 key 들을 모두 제거해야되는 경우가 아니라면 보통 setState() 가 사용됩니다. replaceState()를 사용하는 대신 setState()에서 state 를 flase/null 로 설정할 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to listen to state changes?</h3>\n</li>\n</ol>\n<h4>(어떻게 state 의 변경을 listen 하나요?)</h4>\n<p>state 가 변경될때 다음의 lifecycle 메서드들이 호출됩니다. 이전에 제공된 state 와 props 의 값을 현재의 state와 props와 비교하여 의미있는 변화가 있는지 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentWillUpdate(object nextProps, object nextState)\ncomponentDidUpdate(object prevProps, object prevState)</code></pre></div>\n<ol>\n<li>\n<h3>What is the recommended approach of removing an array element in React state?</h3>\n</li>\n</ol>\n<h4>(React state 에서 배열요소를 제거하는 추천방법은 무엇인가요?)</h4>\n<p>좋은 방법은 Array.prototype.filter() 메서드를 사용하는 것입니다.</p>\n<p>예를 들어, state update를 위한 removeItem () 메서드를 만들겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">removeItem(index) {\n  this.setState({\n    data: this.state.data.filter((item, i) => i !== index)\n  })\n}</code></pre></div>\n<h3></h3>\n<h4>HTML 렌더링 없이 React 사용하기</h4>\n<ul>\n<li>16.2부터 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">render() {\n  return false\n}\nrender() {\n  return null\n}\nrender() {\n  return []\n}\nrender() {\n  return &lt;React.Fragment&gt;&lt;/React.Fragment&gt;\n}\nrender() {\n  return &lt;&gt;&lt;/&gt;\n}</code></pre></div>\n<h3></h3>\n<h4>(React와 함께 어떻게 이쁘게 JSON 을 print 하나요?)</h4>\n<pre> 태그를 사용하여 JSON.stringify() 형식이 유지되도록 할 수 있습니다.\n\n```react\nconst data = { name: \"John\", age: 42 };\n\nclass User extends React.Component {\n  render() {\n    return <pre>{JSON.stringify(data, null, 2)}</pre>;\n<p>}\n}</p>\n<p>React.render(<User />, document.getElementById(“container”));</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">### \n\n#### React에서 props 를 update\n\nReact 의 철학은 props 는 immutable(불변) 이어야하고 top-down (부모 -> 자식) 방식입니다. 부모는 모든 props 값을 자식에게 보낼 수 있지만, 자식은 받은 props 를 변경할 수 없습니다.\n\n\n\n### 페이지 로드시에 input element 에 focus\n\ninput element 를 위한 ref 를 생성하여 componentDidMount() 에서 사용하면 됩니다.</code></pre></div>\n<p>class App extends React.Component {\ncomponentDidMount() {\nthis.nameInput.focus();\n}</p>\n<p>render() {\nreturn (</p>\n<div>\n<input defaultValue={\"Won't focus\"} />\n<input\nref={input => (this.nameInput = input)}\ndefaultValue={\"Will focus\"}\n/>\n</div>\n);\n}\n}\n<p>ReactDOM.render(<App />, document.getElementById(“app”));</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. ### What are the possible ways of updating objects in state?\n\n#### (state 의 object 를 update 할 수 있는 방법은 무엇인가요?)\n\n1. state 와 합쳐질 object 를 사용하여 setState() 호출\n\n- Object.assign() 을 사용하여 object 의 복사본을 만듭니다.</code></pre></div>\n<p>const user = Object.assign({}, this.state.user, { age: 42 });\nthis.setState({ user });</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">**spread operator 를 사용:**</code></pre></div>\n<p>const user = { …this.state.user, age: 42 };\nthis.setState({ user });</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">**function 을 이용하여 setState() 호출:**</code></pre></div>\n<p>this.setState(prevState => ({\nuser: {\n…prevState.user,\nage: 42\n}\n}));</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. ### Why function is preferred over object for setState()?\n\n#### (왜 setState()를 위한 function 이 object 보다 선호되나요?)\n\nReact 는 성능을 위해 여러 setState() 호출들을 일괄 처리 합니다. 이유는 this.props 와 this.state는 비동기로 update 될 수 있습니다. 다음 state 를 계산할 때 계산된 값을 신뢰하면 안됩니다.\n\n카운터 예제는 기대한대로 update 되지 않습니다.</code></pre></div>\n<p>// Wrong\nthis.setState({\ncounter: this.state.counter + this.props.increment\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">추천되는 접근방법은 object 가 아닌 function 으로 setState() 를 호출하는 것입니다. function 은 첫번째 인자로 이전 state를 받고 두 번째 인자로 update가 적용될 때의 props 를 받습니다.</code></pre></div>\n<p>// Correct\nthis.setState((prevState, props) => ({\ncounter: prevState.counter + props.increment\n}));</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. ### How can we find the version of React at runtime in the browser?\n\n#### (브라우저에서 React의 버전을 runtime 시 어떻게 찾을 수 있나요?)\n\nReact.version 을 사용하면 버전을 가져올 수 있습니다.</code></pre></div>\n<p>const REACT_VERSION = React.version;</p>\n<p>ReactDOM.render(</p>\n  <div>{`React version: ${REACT_VERSION}`}</div>,\n  document.getElementById(\"app\")\n);\n```\n<ol>\n<li>\n<h3>What are the approaches to include polyfills in your create-react-app?</h3>\n</li>\n</ol>\n<h4>(create-react-app 에 polyfills를 포함시키는 방법은 무엇인가요?)</h4>\n<p><strong>core-js 에서 수동 import:</strong></p>\n<ul>\n<li>polyfills.js 파일을 만들어 root index.js 에서 import 합니다. <code class=\"language-text\">npm install core-js</code> 또는 <code class=\"language-text\">yarn add core-js</code> 를 추가하고 필요한 기능을 import 합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import \"core-js/fn/array/find\";\nimport \"core-js/fn/array/includes\";\nimport \"core-js/fn/number/is-nan\";</code></pre></div>\n<p><strong>Polyfill 서비스 사용:</strong></p>\n<ul>\n<li>polyfill.io CDN 을 사용하여 다음의 줄을 index.html 에 추가하고, 사용자 지정 브라우저별 Polyfill을 검색합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;script src=\"https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes\">&lt;/script></code></pre></div>\n<p>위의 스크립트에서 Array.prototype.includes 는 기본 스펙에 포함되지 않았기 때문에 기능을 요청했습니다.</p>\n<ol>\n<li>\n<h3>How to use https instead of http in create-react-app?</h3>\n</li>\n</ol>\n<h4>(create-react-app 에서 http 대신 https 를 어떻게 사용하나요?)</h4>\n<p><code class=\"language-text\">HTTPS = true</code> 설정이 필요합니다. package.json 에 scripts 부분을 편집할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"scripts\": {\n  \"start\": \"set HTTPS=true &amp;&amp; react-scripts start\"\n}</code></pre></div>\n<p>또는 <code class=\"language-text\">set HTTPS=true &amp;&amp; npm start</code> 을 실행하세요</p>\n<ol>\n<li>\n<h3>How to avoid using relative path imports in create-react-app?</h3>\n</li>\n</ol>\n<h4>(create-react-app 에서 상대경로 import 를 어떻게 피하나요?)</h4>\n<p>프로젝트의 root 에 <code class=\"language-text\">env</code> 파일을 만들고 import path 를 작성해주세요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">NODE_PATH = src / app;</code></pre></div>\n<p>설정후 개발서버를 재시작 해주세요. 상대 경로없이 src/app 안에 있는 모든것을 import 할 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to add Google Analytics for React Router?</h3>\n</li>\n</ol>\n<h4>(어떻게 React Router 에 Google Analytics 를 추가하나요?)</h4>\n<p>history 객체에 listener 를 추가하여 각 페이지 뷰를 기록하세요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">history.listen(function(location) {\n  window.ga(\"set\", \"page\", location.pathname + location.search);\n  window.ga(\"send\", \"pageview\", location.pathname + location.search);\n});</code></pre></div>\n<ol>\n<li>\n<h3>How to update a component every second?</h3>\n</li>\n</ol>\n<h4>(어떻게 매 초 마다 component 를 업데이트 하나요?)</h4>\n<p>setInterval() 를 사용하여 변경을 트리거해야합니다. 오류 및 메모리 누수를 방지하려면 component unmount 시 타이머를 제거해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentDidMount() {\n  this.interval = setInterval(() => this.setState({ time: Date.now() }), 1000)\n}\n\ncomponentWillUnmount() {\n  clearInterval(this.interval)\n}</code></pre></div>\n<ol>\n<li>\n<h3>How do you apply vendor prefixes to inline styles in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 어떻게 인라인 스타일에 vendor prefixes 를 붙일수 있나요?)</h4>\n<p>React 에서는 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">vendor prefixes</a> 를 자동으로 적용해주지 않습니다. vendor prefixes 를 수동으로 추가해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div\n  style={{\n    transform: \"rotate(90deg)\",\n    WebkitTransform: \"rotate(90deg)\", // note the capital 'W' here\n    msTransform: \"rotate(90deg)\" // 'ms' is the only lowercase vendor prefix\n  }}\n/></code></pre></div>\n<ol>\n<li>\n<h3>How to import and export components using React and ES6?</h3>\n</li>\n</ol>\n<h4>(React와 ES6에서 어떻게 component 를 import 와 export 할 수 있나요?)</h4>\n<p>component 를 export 하려면 default 를 사용해야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport User from \"user\";\n\nexport default class MyProfile extends React.Component {\n  render() {\n    return &lt;User type=\"customer\">//...&lt;/User>;\n  }\n}</code></pre></div>\n<p>export 를 사용하면 MyProfile 이 모듈로 내보내집니다. 다른 component 의 이름을 사용하지 않아도 동일한 파일을 import 할 수 있습니다.</p>\n<ol>\n<li>\n<h3>Why React component names must begin with a capital letter?</h3>\n</li>\n</ol>\n<h4>(왜 React compnent 의 이름은 대문자여야하나요?)</h4>\n<p>JSX 에서 소문자 태그 이름은 HTML 태그로 간주됩니다. 그러나 점 ((property accessors) 이 있는 대문자, 소문자 태그 이름은 HTML 태그로 간주되지 않습니다.</p>\n<ul>\n<li><code class=\"language-text\">&lt;component /></code> compiles to React.createElement(‘component’) (i.e, HTML tag)</li>\n<li><code class=\"language-text\">&lt;obj.component /></code> compiles to React.createElement(obj.component)</li>\n<li><code class=\"language-text\">&lt;Component /></code> compiles to React.createElement(Component)</li>\n<li>\n<h3>Why is a component constructor called only once?</h3>\n</li>\n</ul>\n<h4>(왜 component 생성자는 한번만 호출되나요?)</h4>\n<p>React의 reconciliation 알고리즘에서는 custom component 가 다음 렌더링의 같은 위치에 나타나면 이전 component 와 동일하므로 인스턴스를 새로 만들지 않고 다시 사용한다고 가정합니다.</p>\n<ol>\n<li>\n<h3>How to define constants in React?</h3>\n</li>\n</ol>\n<h5>(React 에서 어떻게 상수를 정의하나요?)</h5>\n<p>ES7 의 static 필드를 사용하여 상수를 정의 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  static DEFAULT_PAGINATION = 10;\n}</code></pre></div>\n<p>static 필드는 statge 3 의 제안된 부분입니다.</p>\n<ol>\n<li>\n<h3>How to programmatically trigger click event in React?</h3>\n</li>\n</ol>\n<h4>(React 에서 어떻게 프로그래밍 방식으로 클릭 이벤트를 트리거 할 수 있나요?)</h4>\n<p>callback 을 통한 ref prop 를 사용하여 <code class=\"language-text\">HTMLInputElement</code> 객체에 대한 참조를 가져와 class property 로 저장하고, 나중에 저장된 참조를 사용를 이용하여 <code class=\"language-text\">HTMLElement.click</code> 메서드를 사용해 이벤트 핸들러에서 클릭 이벤트를 트리거 할 수 있습니다.</p>\n<p>이 작업은 두 단계로 나눌 수 있습니다.</p>\n<p><strong>render 메서드 안에서 ref 생성</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input ref={input => (this.inputElement = input)} /></code></pre></div>\n<p><strong>이벤트 핸들러에서 클릭 이벤트 제공:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.inputElement.click();</code></pre></div>\n<ol>\n<li>\n<h3>Is it possible to use async/await in plain React?</h3>\n</li>\n</ol>\n<h4>(기본 React 에서 async/await 를 사용할 수 있나요?)</h4>\n<p>React 에서 async/await 을 사용하고 싶다면 Babel 과 transform-async-to-generator 플러그인이 필요합니다.</p>\n<ol>\n<li>\n<h3>What are the common folder structures for React?</h3>\n</li>\n</ol>\n<h4>(React 의 일반 폴더 구조는 무엇인가요?)</h4>\n<p>여기 React project 의 파일 구조에 대한 두 가지의 사례가 있습니다.</p>\n<p><strong>기능 또는 경로별로의 그룹:</strong></p>\n<p>프로젝트를 구조화하는 하나의 일반적인 방법으로는 기능이나 경로별로 그룹화된 CSS, JS, test 들을 함께 구성하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">common/\n├─ Avatar.js\n├─ Avatar.css\n├─ APIUtils.js\n└─ APIUtils.test.js\nfeed/\n├─ index.js\n├─ Feed.js\n├─ Feed.css\n├─ FeedStory.js\n├─ FeedStory.test.js\n└─ FeedAPI.js\nprofile/\n├─ index.js\n├─ Profile.js\n├─ ProfileHeader.js\n├─ ProfileHeader.css\n└─ ProfileAPI.js</code></pre></div>\n<p><strong>파일 형식의 그룹화</strong></p>\n<p>프로젝트를 구조화하는 다른 인기있는 방법으로는 유사한 파일들을 그룹화하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">api/\n├─ APIUtils.js\n├─ APIUtils.test.js\n├─ ProfileAPI.js\n└─ UserAPI.js\ncomponents/\n├─ Avatar.js\n├─ Avatar.css\n├─ Feed.js\n├─ Feed.css\n├─ FeedStory.js\n├─ FeedStory.test.js\n├─ Profile.js\n├─ ProfileHeader.js\n└─ ProfileHeader.css</code></pre></div>\n<ol>\n<li>\n<h3>What are the popular packages for animation?</h3>\n</li>\n</ol>\n<h4>(애니메이션을 위한 인기있는 패키지는 무엇인가요?)</h4>\n<p>React 생태계에서 인기있는 애니메이션 패키지는 React Transition Group과 React Motion 입니다.</p>\n<ol>\n<li>\n<h3>What is the benefit of styles modules?</h3>\n</li>\n</ol>\n<h4>(styles modules 의 이점은 무엇인가요?)</h4>\n<p>styles modules 은 component 에서 style 의 값을 하드 코딩하는 것을 피하기 위해 추천됩니다. 서로 다른 UI component 에서 사용될 수 있는 값들은 자체 모듈에서 받아와야 합니다.</p>\n<p>예를 들어, 이런 style 들은 별도의 component 로 받아낼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const colors = {\n  white,\n  black,\n  blue\n};\n\nexport const space = [0, 8, 16, 32, 64];</code></pre></div>\n<p>다른 component 들에서 개별적으로 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { space, colors } from './styles'</code></pre></div>\n<ol>\n<li>\n<h3>What are the popular React-specific linters?</h3>\n</li>\n</ol>\n<h4>(인기있는 React linters 는 무엇인가요?)</h4>\n<p>ESLint 는 인기있는 Javascript linters 입니다. ESLint 는 코드 스타일을 분석할 수 있는 플러그인입니다. React 에서 대부분 사용하는 npm 패키지 중 하나는 <code class=\"language-text\">eslint-plugin-react</code> 입니다. 기본적으로 몇가지의 best practices 를 확인하여 규칙을 바탕으로 iterators 의 key 에서 전체 prop type 까지 확인합니다. 다른 인기있는 플러그인은 <code class=\"language-text\">eslint-plugin-jsx-a11y</code> 이며, 접근성을 통해 문제를 해결하는데 도움을 줍니다. JSX 는 일반적인 HTML 문법과 약간 다르게 제공하므로, <code class=\"language-text\">alt</code> text 그리고 <code class=\"language-text\">tabindex</code> 같은 문제는 플러그인으로 선택되지 않습니다.</p>\n<ol>\n<li>\n<h3>How to make AJAX call and in which component lifecycle methods should I make an AJAX call?</h3>\n</li>\n</ol>\n<h4>(어떻게 AJAX 를 호출하고 어떤 lifecycle 에서 메서드를 호출해야하나요?)</h4>\n<p>AJAX 라이브러리인 Axios, jQuery AJAX, 그리고 브라우저에 내장된 fetch 를 사용할 수 있습니다. <code class=\"language-text\">componentDidMount()</code> lifecycle 메서드에서 데이터를 불러와야합니다. setStaet() 를 사용하여 데이터를 검색할때 component 를 update 할 수 있습니다.</p>\n<p>예를 들어, API 에서 직원목록을 가져와 local state 를 설정합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      employees: [],\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    fetch(\"https://api.example.com/items\")\n      .then(res => res.json())\n      .then(\n        result => {\n          this.setState({\n            employees: result.employees\n          });\n        },\n        error => {\n          this.setState({ error });\n        }\n      );\n  }\n\n  render() {\n    const { error, employees } = this.state;\n    if (error) {\n      return &lt;div>Error: {error.message}&lt;/div>;\n    } else {\n      return (\n        &lt;ul>\n          {employees.map(item => (\n            &lt;li key={employee.name}>\n              {employee.name}-{employees.experience}\n            &lt;/li>\n          ))}\n        &lt;/ul>\n      );\n    }\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>What are render props?</h3>\n</li>\n</ol>\n<h4>(Render Props 란 무엇인가요?)</h4>\n<p>Render Props 는 값이 함수인 prop 를 이용하여 component 간에 코드를 공유하는 기술입니다. 아래 component 는 render prop 을 사용하여 React element 를 반환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;DataProvider render={data => &lt;h1>{`Hello ${data.target}`}&lt;/h1>} /></code></pre></div>\n<p>React Router 와 DownShift 라이브러리는 이 패턴을 사용합니다.</p>\n<h2>React Router</h2>\n<ol>\n<li>\n<h3>What is React Router?</h3>\n</li>\n</ol>\n<h4>(React Router 가 무엇인가요?)</h4>\n<p>React Router 는 React 에 구현된 강력한 routing 라이브러리 입니다. 페이지에 보여지는 내용과 URL 을 동기화된 상태로 유지해주고, 애플리케이션에 새로운 화면과 흐름을 추가할 수 있게 도와줍니다.</p>\n<ol>\n<li>\n<h3>How React Router is different from history library?</h3>\n</li>\n</ol>\n<h4>(React router 와 history 라이브러리의 다른점은 무엇인가요?)</h4>\n<p>React router 는 history 라이브러리를 감싼 래퍼입니다. React router는 브라우저의 <code class=\"language-text\">window.history</code> 과 상호작용을 하고, 브라우저 및 hash history 을 다룹니다. 또 모바일 앱 개발 (React Native) 및 Node 의 unit testing 처럼 global history 가 없는 환경에 유용한 memory 히스토리를 제공합니다.</p>\n<ol>\n<li>\n<h3>What are the components of React Router v4?</h3>\n</li>\n</ol>\n<h4>(React router v4 의 component 는 무엇이 있나요?)</h4>\n<p>React router v4는 아래와 같은 3가지 component 를 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- &lt;BrowserRouter>\n- &lt;HashRouter>\n- &lt;MemoryRouter></code></pre></div>\n<p>위의 components 들은 browser, hash, 그리고 memory history 인스턴스를 만듭니다. React Router v4 는 Router Object 의 context 를 통해 history 인스턴스의 속성과 메서드를 이용할 수 있게 해줍니다.</p>\n<h3></h3>\n<h4>(history의 push() 와 replace() 메서드의 목적은 무엇인가요?)</h4>\n<p>history 인스턴스에는 navigation 을 위한 두 가지 메서드가 있습니다.</p>\n<ul>\n<li>push()</li>\n<li>replace()</li>\n</ul>\n<p>방문한 위치의 history 를 배열로 생각한다면, push() 는 배열에 새 위치를 추가하는 것이고 replace() 는 현재의 위치를 새 위치로 변경하는 것입니다.</p>\n<h3>How do you programmatically navigate using React Router v4?</h3>\n<h4>(어떻게 프로그래밍 방식으로 React Router v4 의 navigate 를 사용하나요?)</h4>\n<p>component 안에서 프로그래밍 방식으로 routing/navigation 을 수행하는 세가지의 다른 방법이 있습니다.</p>\n<p><strong>withRouter() higher-order function 을 사용하기:</strong></p>\n<p>withRouter () higher-order function 은 history object 를 component 의 prop 로 삽입합니다. 이 객체는 context 의 사용을 피하기 위해 push() 그리고 replace() 메서드를 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { withRouter } from \"react-router-dom\"; // this also works with 'react-router-native'\n\nconst Button = withRouter(({ history }) => (\n  &lt;button\n    type=\"button\"\n    onClick={() => {\n      history.push(\"/new-location\");\n    }}\n  >\n    {\"Click Me!\"}\n  &lt;/button>\n));</code></pre></div>\n<p><strong>Route component 그리고 render props 패턴 사용하기:</strong></p>\n<p><code class=\"language-text\">&lt;Router></code> component 는 withRouter() 와 같은 prop 를 전달하므로, history prop 를 통해 history 메서드에 접근할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Route } from \"react-router-dom\";\n\nconst Button = () => (\n  &lt;Route\n    render={({ history }) => (\n      &lt;button\n        type=\"button\"\n        onClick={() => {\n          history.push(\"/new-location\");\n        }}\n      >\n        {\"Click Me!\"}\n      &lt;/button>\n    )}\n  />\n);</code></pre></div>\n<p><strong>context 사용</strong></p>\n<p>이 옵션은 추천되지 않으며 불안정한 API 로 처리됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Button = (props, context) => (\n  &lt;button\n    type=\"button\"\n    onClick={() => {\n      context.history.push(\"/new-location\");\n    }}\n  >\n    {\"Click Me!\"}\n  &lt;/button>\n);\n\nButton.contextTypes = {\n  history: React.PropTypes.shape({\n    push: React.PropTypes.func.isRequired\n  })\n};</code></pre></div>\n<ol>\n<li>\n<h3>How to get query parameters in React Router v4?</h3>\n</li>\n</ol>\n<h4>(React Router v4 에서 어떻게 query parameters 가져오나요?)</h4>\n<p>수년동안 다른 구현 지원에 대한 사용자들의 요청이 있었기 때문에 React Router v4의 query strings 을 parse 하는 기능이 제거되었습니다. 그래서 사용자들이 선호하는 구현방식을 선택하도록 결정되었습니다. 추천 방법은 query strings 라이브러리를 사용하는것 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const queryString = require(\"query-string\");\nconst parsed = queryString.parse(props.location.search);</code></pre></div>\n<p>native 방식을 원한다면 URLSearchParams 을 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const params = new URLSearchParams(props.location.search);\nconst foo = params.get(\"name\");</code></pre></div>\n<p>IE11에는 polyfill을 사용해야합니다.</p>\n<ol>\n<li>\n<h3>Why you get “Router may have only one child element” warning?</h3>\n</li>\n</ol>\n<h4>(왜 “Router 는 오직 하나의 자식 element 만 있을 수 있습니다” 라는 경고를 받나요?)</h4>\n<p><code class=\"language-text\">&lt;Switch></code> 는 route 를 독점적으로 렌더링하기 때문에 <code class=\"language-text\">&lt;Switch></code> 으로 Route 들을 감싸야합니다.</p>\n<p>먼저 Switch 를 가져와야 추가해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Switch, Router, Route } from \"react-router\";</code></pre></div>\n<p><code class=\"language-text\">&lt;Switch></code> 블록안에 routes 를 정의해아합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Router>\n  &lt;Switch>\n    &lt;Route {/* ... */} />\n    &lt;Route {/* ... */} />\n  &lt;/Switch>\n&lt;/Router></code></pre></div>\n<ol>\n<li>\n<h3>How to pass params to history.push method in React Router v4?</h3>\n</li>\n</ol>\n<h4>(React Router v4 에서 어떻게 history.push 메서드에 파라미터를 전달하나요?)</h4>\n<p>navigating 하는 동안 history object 에 props 를 전달할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.props.history.push({\n  pathname: \"/template\",\n  search: \"?name=sudheer\",\n  state: { detail: response.data }\n});</code></pre></div>\n<p><code class=\"language-text\">search</code> 속성은 push() 메서드에 query params 을 전달하는데 사용됩니다.</p>\n<ol>\n<li>\n<h3>How to implement default or NotFound page?</h3>\n</li>\n</ol>\n<h4>(기본 페이지 또는 NotFound 를 어떻게 구현하나요?)</h4>\n<p><code class=\"language-text\">&lt;Switch></code> 는 일치하는 첫번째 자식 <code class=\"language-text\">&lt;Route></code> 를 렌더링합니다. 경로가 없는 <code class=\"language-text\">&lt;Route></code> 는 항상 일치합니다. 아래와 같이 경로를 속성을 제거해주면됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Switch>\n  &lt;Route exact path=\"/\" component={Home} />\n  &lt;Route path=\"/user\" component={User} />\n  &lt;Route component={NotFound} />\n&lt;/Switch></code></pre></div>\n<ol>\n<li>\n<h3>How to get history on React Router v4?</h3>\n</li>\n</ol>\n<h4>(어떻게 React Router v4에서 history를 얻나요?)</h4>\n<p><strong>history object 를 내보내고 이 모듈을 전체 프로젝트에 가져오는 모듈을 만드세요.</strong></p>\n<p>예를 들면, history.js 파일을 만듭니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { createBrowserHistory } from \"history\";\n\nexport default createBrowserHistory({\n  /* pass a configuration object here if needed */\n});</code></pre></div>\n<p><strong>기본 구현된 routers 대신 <code class=\"language-text\">&lt;Router></code> component 를 사용해야합니다. index.js 에서 위의 history.js 를 가져왔습니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Router } from \"react-router-dom\";\nimport history from \"./history\";\nimport App from \"./App\";\n\nReactDOM.render(\n  &lt;Router history={history}>\n    &lt;App />\n  &lt;/Router>,\n  holder\n);</code></pre></div>\n<p><strong>기본 구현된 history object 와 유사하 history object 의 push 메서드를 사용할 수 있습니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// some-other-file.js\nimport history from \"./history\";\n\nhistory.push(\"/go-here\");</code></pre></div>\n<ol>\n<li>\n<h3>How to perform automatic redirect after login?</h3>\n</li>\n</ol>\n<h4>(어떻게 로그인후에 자동으로 redirect 를 시키나요?)</h4>\n<p><code class=\"language-text\">react-router</code> 패키지는 React Router 에 <code class=\"language-text\">&lt;Redirect></code> component 를 제공합니다. <code class=\"language-text\">&lt;Redirect></code> 을 렌더링하면 새로운 위치로 이동합니다. server-side redirect 와 같이, history stack 의 현재 위치를 새로운 위치로 덮어씌웁니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from \"react\";\nimport { Redirect } from \"react-router\";\n\nexport default class LoginComponent extends Component {\n  render() {\n    if (this.state.isLoggedIn === true) {\n      return &lt;Redirect to=\"/your/redirect/page\" />;\n    } else {\n      return &lt;div>{\"Login Please\"}&lt;/div>;\n    }\n  }\n}</code></pre></div>\n<h2>React Internationalization</h2>\n<ol>\n<li>\n<h3>What is React Intl?</h3>\n</li>\n</ol>\n<h4>(React Intl 이 무엇인가요?)</h4>\n<p><a href=\"https://github.com/yahoo/react-intl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Intl</a> 라이브러리는 문자열, 날짜와 숫자, 다중화 formatting 을 다룰 수 있는 component 와 api 를 제공합니다. React Intl 는 components 와 API 를 통해 React 에 바인딩을 제공하는 FormatJS 의 일부분입니다.</p>\n<ol>\n<li>\n<h3>What are the main features of React Intl?</h3>\n</li>\n</ol>\n<h4>(React Intl 의 주요 특징은 무엇인가요?)</h4>\n<ul>\n<li><a href=\"https://medium.com/@marcelmokos/internationalize-react-apps-done-right-using-react-intl-library-82978dbe175e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">구분자와 함께 숫자를 표시합니다</a></li>\n<li>날짜와 시간을 정확하게 표시합니다.</li>\n<li>“now” 를 기준으로 날짜를 표시합니다.</li>\n<li>150 개 이상의 언어를 지원합니다.</li>\n<li>브라우저와 노드에서 실행됩니다.</li>\n<li>표준을 기반으로 구축되었습니다.</li>\n<li>\n<h3>What are the two ways of formatting in React Intl?</h3>\n</li>\n</ul>\n<h4>(React Intl 에서 formatting 을 하는 두 가지 방법은 무엇인가요?)</h4>\n<p>라이브러리는 문자, 숫자와 날짜의 형식을 지정하는 두 가지 방법을 제공합니다. : React component 또는 API</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;FormattedMessage\n  id={\"account\"}\n  defaultMessage={\"The amount is less than minimum balance.\"}\n/></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const messages = defineMessages({\n  accountMessage: {\n    id: \"account\",\n    defaultMessage: \"The amount is less than minimum balance.\"\n  }\n});\n\nformatMessage(messages.accountMessage);</code></pre></div>\n<ol>\n<li>\n<h3>How to use as placeholder using React Intl?</h3>\n</li>\n</ol>\n<h4>(어떻게 React Intl를 사용하여 를 placeholder 로 사용하나요?)</h4>\n<p>react-intl 의 &#x3C;Formatted… /> component 는 elements 를 리턴하므로, placeholders, alt text, etc 등을 사용할 수 없습니다. 이런 경우에는 하위 레벨의 API formatMessage() 를 사용해야합니다. higher-order component 인 injectIntl() 를 사용하여 component 에 intl object 를 주입하고 object 에서 사용할 수 있는 formatMessage() 를 사용하여 message 형식을 지정할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport { injectIntl, intlShape } from \"react-intl\";\n\nconst MyComponent = ({ intl }) => {\n  const placeholder = intl.formatMessage({ id: \"messageId\" });\n  return &lt;input placeholder={placeholder} />;\n};\n\nMyComponent.propTypes = {\n  intl: intlShape.isRequired\n};\n\nexport default injectIntl(MyComponent);</code></pre></div>\n<ol>\n<li>\n<h3>How to access current locale with React Intl?</h3>\n</li>\n</ol>\n<h4>(어떻게 React Intl 를 사용하여 현재 locale 에 접근하나요?)</h4>\n<p><code class=\"language-text\">injectIntl()</code> 를 사용하면 application 의 모든 component 에서 현재 locale 을 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { injectIntl, intlShape } from \"react-intl\";\n\nconst MyComponent = ({ intl }) => (\n  &lt;div>{`The current locale is ${intl.locale}`}&lt;/div>\n);\n\nMyComponent.propTypes = {\n  intl: intlShape.isRequired\n};\n\nexport default injectIntl(MyComponent);</code></pre></div>\n<ol>\n<li>\n<h3>How to format date using React Intl?</h3>\n</li>\n</ol>\n<h4>(React Intl 을 사용해서 어떻게 날짜 형식을 지정하나요?)</h4>\n<p>higher-order component 인 <code class=\"language-text\">injectIntl()</code> 는 component 의 props 를 통해 <code class=\"language-text\">formatDate ()</code> 메서드에 대한 접근을 제공합니다. 이 메서드는 FormatedDate 의 인스턴스 내부에서 사용되며 형식이 지정된 날짜의 문자 표현을 반환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { injectIntl, intlShape } from \"react-intl\";\n\nconst stringDate = this.props.intl.formatDate(date, {\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\"\n});\n\nconst MyComponent = ({ intl }) => (\n  &lt;div>{`The formatted date is ${stringDate}`}&lt;/div>\n);\n\nMyComponent.propTypes = {\n  intl: intlShape.isRequired\n};\n\nexport default injectIntl(MyComponent);</code></pre></div>\n<h2>React Testing</h2>\n<h3>(React 테스트에서 얕은 렌더링은 무엇인가요?)</h3>\n<p>얕은 렌더링은 React 에서 단위 테스트 케이스를 작성하는데 유용합니다. 그것은 component 를 한단계 깊이로 렌더링하며 인스턴스화 또는 렌더링 되지 않은 하위 component 의 행동에 대한 걱정없이 렌더링 메서드가 반환하는 것에 대한 사실을 주장할 수 있습니다.</p>\n<p>예를 들어, 다음과 같은 component 가 있는 경우:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function MyComponent() {\n  return (\n    &lt;div>\n      &lt;span className={\"heading\"}>{\"Title\"}&lt;/span>\n      &lt;span className={\"description\"}>{\"Description\"}&lt;/span>\n    &lt;/div>\n  );\n}</code></pre></div>\n<p>다음과 같이 주장 할 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import ShallowRenderer from \"react-test-renderer/shallow\";\n\n// in your test\nconst renderer = new ShallowRenderer();\nrenderer.render(&lt;MyComponent />);\n\nconst result = renderer.getRenderOutput();\n\nexpect(result.type).toBe(\"div\");\nexpect(result.props.children).toEqual([\n  &lt;span className={\"heading\"}>{\"Title\"}&lt;/span>,\n  &lt;span className={\"description\"}>{\"Description\"}&lt;/span>\n]);</code></pre></div>\n<p>1.</p>\n<ol start=\"2\">\n<li>\n<h3>What is TestRenderer package in React?</h3>\n</li>\n</ol>\n<h4>(React 의 TestRenderer 패키지는 무엇인가요?)</h4>\n<p>패키지는 component 를 DOM 또는 Native mobile 환경에 의존없이 순수 Javascript Object 로 렌더링 할 수 있는 renderer 를 제공합니다. 패키지를 사용하면 브라우저 또는 jsdom 의 사용없이 ReactDOM 또는 React Native 에서 렌더링 되는 플랫폼의 뷰 계층구조 (DOM 트리와 유사하다) 의 스냅샷을 쉽게 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import TestRenderer from \"react-test-renderer\";\n\nconst Link = ({ page, children }) => &lt;a href={page}>{children}&lt;/a>;\n\nconst testRenderer = TestRenderer.create(\n  &lt;Link page={\"https://www.facebook.com/\"}>{\"Facebook\"}&lt;/Link>\n);\n\nconsole.log(testRenderer.toJSON());\n// {\n//   type: 'a',\n//   props: { href: 'https://www.facebook.com/' },\n//   children: [ 'Facebook' ]\n// }</code></pre></div>\n<ol>\n<li>\n<h3>What is the purpose of ReactTestUtils package?</h3>\n</li>\n</ol>\n<h4>(ReactTestUtils 패키지의 목적은 무엇인가요?)</h4>\n<p>ReactTestUtils 는 with-addons 에서 제공되며 유닛 테스트를 위해 시뮬레이션된 DOM 에 대한 작업을 수행할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What is Jest?</h3>\n</li>\n</ol>\n<h4>(Jest 는 무엇인가요?)</h4>\n<p>Jest 는 Facebook 에서 만든 Jasmine 기반의 Javascript 단위 테스트 프레임워크이며 자동화 된 모의 생성 및 jsdom 환경을 제공합니다. 종종 component 를 테스트하기위해 사용됩니다.</p>\n<p>1.</p>\n<ol start=\"2\">\n<li>\n<h3>What are the advantages of Jest over Jasmine?</h3>\n</li>\n</ol>\n<h4>(Jasmine 보다 좋은 Jest 의 장점은 무엇인가요?)</h4>\n<p>Jasmine 과 비교하였을때 몇가지 장점이 있습니다.</p>\n<ul>\n<li>소스코드에서 실핼할 테스트를 자동으로 찾아줍니다.</li>\n<li>테스트 실행시 자동으로 모의 의존성을 가져옵니다.</li>\n<li>비동기 코드를 동기적으로 테스트할 수 있습니다.</li>\n<li>command line 에서 테스트를 실핼할 수 있도록 가짜 DOM 구현 (jsdom 을 통해) 테스트를 실행합니다.</li>\n<li>병렬 프로세스에서 테스트가 실행되어 빨리 완료됩니다.</li>\n<li>\n<h3>Give a simple example of Jest test case</h3>\n</li>\n</ul>\n<h4>(Jest 테스트 케이스의 간단한 예제입니다)</h4>\n<p><code class=\"language-text\">sum.js</code> 파일에 두개의 숫자를 더하는 함수의 테스트를 작성해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const sum = (a, b) => a + b;\n\nexport default sum;</code></pre></div>\n<p>테스트가 포함되어 있는 <code class=\"language-text\">sum.test.js</code> 파일을 만들어주세요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import sum from \"./sum\";\n\ntest(\"adds 1 + 2 to equal 3\", () => {\n  expect(sum(1, 2)).toBe(3);\n});</code></pre></div>\n<p><code class=\"language-text\">package.json</code> 에 다음 부분을 추가해주세요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}</code></pre></div>\n<p>마지막으로 yarn test 또는 npm test 를 실행해주세요 Jest 는 결과를 출력해줄거에요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ yarn test\nPASS ./sum.test.js\n✓ adds 1 + 2 to equal 3 (2ms)</code></pre></div>\n<h2>React Redux</h2>\n<ol>\n<li>\n<h3>What is flux?</h3>\n</li>\n</ol>\n<h4>(Flux 가 뭔가요?)</h4>\n<p>Flux 는 전통적인 MVC 패턴을 교체하기 위해 사용되는 application 설계 패러다임 입니다.\nFlux 는 라이브러리나 프레임워크는 아니고 React 와 단방향 데이터 흐름의 개념을 보완해주는 새로운 아키텍쳐입니다. Facebook 은 React로 작업할때 Flux 패턴을 사용합니다.</p>\n<p>dispatcher, stores 그리고 views 컴포넌트 사이의 작업흐름은 input 과 output 이 다음과 같이 구분되어집니다.</p>\n<p><a href=\"https://github.com/appear/reactjs-interview-questions-ko/blob/master/public/flux.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://github.com/appear/reactjs-interview-questions-ko/raw/master/public/flux.png\" alt=\"flux\"></a></p>\n<ol>\n<li>\n<h3>What is Redux?</h3>\n</li>\n</ol>\n<h4>(Redux 가 뭔가요?)</h4>\n<p>Redux 는 Flux 설계 패턴을 기반으로한 Javascript App 을 위한 예측 가능한 상태 컨테이너입니다. Redux 는 React 또는 다른 view 라이브러리들과 함께 사용될 수 있습니다. 그것은 작고 (2KB 정도) 종속성이 없습니다.</p>\n<h3></h3>\n<h4>(React 의 핵심적인 원리는 무엇인가요?)</h4>\n<p>Redux 는 세가지의 기본원리를 따릅니다.</p>\n<ol>\n<li>단일 출처: 전체 application 의 상태는 하나의 스토어의 객체 트리에 저장됩니다. 단일 상태 트리를 이용하면 시간 경과에 따른 변경사항 추척과 디버깅 또는 application 의 검사를 쉽게해줍니다.</li>\n<li>읽기전용의 상태: 상태를 변경하는 유일한 방법은 발생한 일에 대한 액션을 보내는것입니다. 이것은 view 와 Network callback 에서 상태를 직접 쓰지 않도록 보장합니다.</li>\n<li>순수함수로 만들어진다: 상태 트리가 액션에 의해 어떻게 변환될지를 reducers 에 작성해야합니다. Reducers 는 이전의 상태와 매개변수를 받는 순수함수이고 다음 상태를 반환해줍니다.</li>\n<li>\n<h3>What are the downsides of Redux compared to Flux?</h3>\n</li>\n</ol>\n<h4>(Flux 와 비교했을때 Redux 의 단점은 무엇인가요?)</h4>\n<p>단점을 말하는것 보다는 Flux 보다 Redux 를 사용하는 것에 있어 타협점이 거의 없습니다. 예시는 다음과 같습니다.</p>\n<ul>\n<li>변이를 피하는 방법을 배워야합니다 : Flux 는 data 의 변이에 대해 유동적입니다. 그러나 Redux 는 변이를 좋아하지 않고 Redux 를 보완해주는 많은 패키지들이 상태를 변화시키지 않도록 합니다. <code class=\"language-text\">redux-immutable-state-invariant</code> 나 <code class=\"language-text\">Immutable.js</code> 같은 개발 전용 패키지로 실시할 수 있으며, 당신의 팀에게 변이가 없는 코드를 가르칠 수 있습니다.</li>\n<li>신중하게 패키지를 선택해야합니다: Flux 는 실행취소/다시실행, 지속성 또는 폼에 대한 문제를 해결하려 하지 않지만, Redux 는 미들웨어 및 Store 개선 등 확장된 포인트들을 가지고 풍부한 생태계를 만들어 냈습니다.</li>\n</ul>\n<h3></h3>\n<h4>(mapStateToProps() 와 mapDispatchToProps() 의 다른점은 무엇인가요?)</h4>\n<p><code class=\"language-text\">mapStateToProps()</code> 는 component 가 업데이트된 상태(다른 component 에 의해 업데이트된) 를 가져올 수 있게 도와주는 유틸리티입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const mapStateToProps = state => {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  };\n};</code></pre></div>\n<p><code class=\"language-text\">mapDispatchToProps()</code> 는 component 가 이벤트를 발생시킬 수 있도록 도와주는 유틸리티입니다. (application 의 상태가 변경될 수 있도록 action 을 보냄)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const mapDispatchToProps = dispatch => {\n  return {\n    onTodoClick: id => {\n      dispatch(toggleTodo(id));\n    }\n  };\n};</code></pre></div>\n<h3></h3>\n<h4>(reducer 에서 action 을 전달할 수 있나요?)</h4>\n<p>reducer 안에서 action 을 보내는 것은 안티패턴입니다. reducer 는 side effects 가 없어야하고 단순히 action 에 대한 처리와 새로운 객체를 반환해야합니다. reducer 안에서 액션을 보내거나 listeners 를 추가한다면 다른 side effects 가 발생할 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to access Redux store outside a component?</h3>\n</li>\n</ol>\n<h4>(component 의 밖에서 Redux store 에 어떻게 접근하나요?)</h4>\n<p><code class=\"language-text\">createStore()</code> 를 사용하여 만든 store 모듈을 내보내면 됩니다. 또한 global window 객체를 더럽히면 안됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">store = createStore(myReducer);\n\nexport default store;</code></pre></div>\n<ol>\n<li>\n<h3>What are the drawbacks of MVW pattern?</h3>\n</li>\n</ol>\n<h4>(MVW 패턴의 단점은 무엇인가요?)</h4>\n<ul>\n<li>DOM 의 조작은 매우 느리고 비싸기 때문에 applications 의 동작을 느리고 비효율적이게합니다.</li>\n<li>순환되는 종속성은 모델과 뷰를 복잡하게 만듭니다</li>\n<li>협업 applications 에서는 많은 데이터의 변화가 일어납니다 (ex. Google docs)</li>\n<li>많은 코드를 추가하지않고 실행을 취소할 수 있는 방법이 없습니다.</li>\n<li>\n<h3>Are there any similarities between Redux and RxJS?</h3>\n</li>\n</ul>\n<h4>(Redux 와 RxJS 의 유사한점이 있나요?)</h4>\n<p>두 라이브러리는 다른 목적을 가지고 있습니다. 그러나 약간의 유사점이 있습니다.</p>\n<p>Redux 는 application 의 전체 상태를 관리하기 위한 툴입니다. 일반적으로 UI 를 위한 구조로 사용됩니다.\nRxJS 는 반응형 프로그래밍 라이브러리입니다. 일반적으로 Javascript 에서 비동기적인 작업을 위해 사용됩니다. Promises 의 대안으로 사용할 수 있습니다. Redux 의 store 는 반응형이기 때문에 반응형 패러다임을 사용합니다. store 는 action 을 관찰하여 스스로 변화합니다. RxJS 또한 반응형 패러다임을 사용하지만 아키텍쳐는 아니므로 Observables 라는 빌딩 블록을 사용하여 패턴을 제공합니다.</p>\n<ol>\n<li>\n<h3>How to dispatch an action on load?</h3>\n</li>\n</ol>\n<h4>(어떻게 load 시에 action 을 전달하나요?)</h4>\n<p><code class=\"language-text\">componentDidMount</code> 와 <code class=\"language-text\">render()</code> 메서드에서 액션을 전달할 수 있고 데이터를 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class App extends Component {\n  componentDidMount() {\n    this.props.fetchData();\n  }\n\n  render() {\n    return this.props.isLoaded ? (\n      &lt;div>{\"Loaded\"}&lt;/div>\n    ) : (\n      &lt;div>{\"Not Loaded\"}&lt;/div>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  isLoaded: state.isLoaded\n});\n\nconst mapDispatchToProps = { fetchData };\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);</code></pre></div>\n<ol>\n<li>\n<h3>How to use connect() from React Redux?</h3>\n</li>\n</ol>\n<h4>(어떻게 React Redux 에서 connect() 를 사용하나요?)</h4>\n<p>container 에서 store 를 사용하려면 두 단계를 따라야합니다.</p>\n<ul>\n<li><code class=\"language-text\">mapStateToProps() 사용</code>: store 의 상태 값들을 지정 props 에 맵핑합니다.</li>\n<li>위의 props 를 컨테이너에 맵핑합니다: <code class=\"language-text\">mapStateToProps</code> 함수에 의해 리턴된 객체들은 컨테이너에 연결됩니다. <code class=\"language-text\">react-redux</code> 에서 <code class=\"language-text\">connect()</code> 를 가져올 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport { connect } from \"react-redux\";\n\nclass App extends React.Component {\n  render() {\n    return &lt;div>{this.props.containerData}&lt;/div>;\n  }\n}\n\nfunction mapStateToProps(state) {\n  return { containerData: state.data };\n}\n\nexport default connect(mapStateToProps)(App);</code></pre></div>\n<ol>\n<li>\n<h3>How to reset state in Redux?</h3>\n</li>\n</ol>\n<h4>(어떻게 Redux 에서 상태 값을 초기화하나요?)</h4>\n<p><code class=\"language-text\">combineReducers()</code>로 생성된 reducer 에게 action 을 위임하도록 application 에 root reducer 를 작성해야합니다.</p>\n<p>예를 들어, <code class=\"language-text\">rootReducer()</code> 는 <code class=\"language-text\">USER_LOGOUT</code> action 후 초기 상태 값을 반환하도록 합니다. reducer 는 action 에 상관없이 첫 번째 매개변수가 undefined 로 호출될 때, 초기 상태 값을 반환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const appReducer = combineReducers({\n  /* your app's top-level reducers */\n});\n\nconst rootReducer = (state, action) => {\n  if (action.type === \"USER_LOGOUT\") {\n    state = undefined;\n  }\n\n  return appReducer(state, action);\n};</code></pre></div>\n<p><code class=\"language-text\">redux-persist</code> 를 사용할 경우 storage 를 비워야 할 수도 있습니다. <code class=\"language-text\">redux-persist</code> 은 복사된 상태값을 storage engine 에 저장해둡니다. 우선 storage engine 을 가져오고, 상태를 undefined 로 설정하기 전에 storage state key 들을 비워주세요</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const appReducer = combineReducers({\n  /* your app's top-level reducers */\n});\n\nconst rootReducer = (state, action) => {\n  if (action.type === \"USER_LOGOUT\") {\n    Object.keys(state).forEach(key => {\n      storage.removeItem(`persist:${key}`);\n    });\n\n    state = undefined;\n  }\n\n  return appReducer(state, action);\n};</code></pre></div>\n<ol>\n<li>\n<h3>Whats the purpose of at symbol in the Redux connect decorator?</h3>\n</li>\n</ol>\n<h4>(Redux connect decorator 의 at symbol 의 목적은 무엇인가요?)</h4>\n<p>@ symbol 은 decorators 를 나타내기위한 자바스크립트 표현식입니다. Decorators 는 설계시에 class 와 속성에 주석을 달고 수정을 할 수 있게 해줍니다.</p>\n<p>decorator 가 없는 Redux 를 예로 들어보겠습니다.</p>\n<ul>\n<li>Without decorator:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport * as actionCreators from \"./actionCreators\";\nimport { bindActionCreators } from \"redux\";\nimport { connect } from \"react-redux\";\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return { actions: bindActionCreators(actionCreators, dispatch) };\n}\n\nclass MyApp extends React.Component {\n  // ...define your main app here\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyApp);</code></pre></div>\n<ul>\n<li>With decorator:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport * as actionCreators from \"./actionCreators\";\nimport { bindActionCreators } from \"redux\";\nimport { connect } from \"react-redux\";\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return { actions: bindActionCreators(actionCreators, dispatch) };\n}\n\n@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyApp extends React.Component {\n  // ...define your main app here\n}</code></pre></div>\n<p>위의 예제는 decorator 의 사용여부를 제외하고는 비슷합니다. decorator 는 아직 자바스크립트 runtime 에 구현되지 않았습니다. 여전히 실험적인 주제이므로 변화될 수 있습니다. decorators 를 지원하기 위해 babel 을 사용할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What is the difference between React context and React Redux?</h3>\n</li>\n</ol>\n<h4>(React context 와 React Redux 는 무엇이 다른가요?)</h4>\n<p>application 에서 직접적으로 Context 를 사용할 수 있으며 깊게 중첩된 component 들에게 데이터를 전달하는데 유용합니다. Redux 는 훨씬 강력하며 Context API 가 지원하지 않는 많은 기능들을 제공해줍니다. React Redux 는 내부적으로 Context 를 사용하지만 public API 에 공개하지 않았습니다.</p>\n<ol>\n<li>\n<h3>Why are Redux state functions called reducers?</h3>\n</li>\n</ol>\n<h4>(왜 Redux 상태 함수를 reducers 라 부르나요 ?)</h4>\n<p>Reducers 는 항상 모든 이전과 현재의 action 들을 기반으로 누적한 상태를 반환합니다. Redux reducer 가 호출 될 때 마다 상태와 액션이 파라미터로 전달됩니다. 상태는 action 에 따라 축소되거나 누적되어 다음 상태를 반환합니다. 최종 상태를 얻기 위한 action을 실행함에 있어 action 단위와 store 의 초기 상태 값을 줄일 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to make AJAX request in Redux?</h3>\n</li>\n</ol>\n<h4>(어떻게 Redux 에서 AJAX 요청을 하나요?)</h4>\n<p>비동기 action 을 정의할 수 있는 <code class=\"language-text\">redux-thunk</code> 미들웨어를 사용할 수 있습니다.</p>\n<p>fetch API 를 사용하여 특정한 계정을 AJAX call 로 가져오는 예제를 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export function fetchAccount(id) {\n  return dispatch => {\n    dispatch(setLoadingAccountState()); // Show a loading spinner\n    fetch(`/account/${id}`, response => {\n      dispatch(doneFetchingAccount()); // Hide loading spinner\n      if (response.status === 200) {\n        dispatch(setAccount(response.json)); // Use a normal function to set the received state\n      } else {\n        dispatch(someError);\n      }\n    });\n  };\n}\n\nfunction setAccount(data) {\n  return { type: \"SET_Account\", data: data };\n}</code></pre></div>\n<ol>\n<li>\n<h3>Should I keep all component’s state in Redux store?</h3>\n</li>\n</ol>\n<h4>(Redux Store 에서 component 들의 모든 상태를 저장하고 있어야 하나요?)</h4>\n<p>Redux Store 에서는 Data 를 저장하고 component 내부에서는 UI 에 관련된 상태들을 저장합니다.</p>\n<ol>\n<li>\n<h3>What is the proper way to access Redux store?</h3>\n</li>\n</ol>\n<h4>(Redux store 에 접근하는 올바른 방법은 무엇인가요?)</h4>\n<p>component 에서 store 에 접근하는 가장 좋은 방법은 <code class=\"language-text\">connect()</code> 함수를 사용하는 것 입니다. connect() 함수는 기존의 component 를 감싸 새로운 component 를 만듭니다. 이 패턴은 <code class=\"language-text\">Higher-Order Components</code> 라고 불리며, React 에서 일반적으로 component 의 기능을 확장하는 기본적인 방법입니다. 이 방법은 상태와 action 생성자를 component 에 매핑하고 store 가 update 되면 자동적으로 component 에 state 와 action 생성자를 전달할 수 있도록 해줍니다.</p>\n<p>connect 를 사용한 <code class=\"language-text\">&lt;FilterLink></code> component 를 예로 들어보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { connect } from \"react-redux\";\nimport { setVisibilityFilter } from \"../actions\";\nimport Link from \"../components/Link\";\n\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n});\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => dispatch(setVisibilityFilter(ownProps.filter))\n});\n\nconst FilterLink = connect(mapStateToProps, mapDispatchToProps)(Link);\n\nexport default FilterLink;</code></pre></div>\n<p>성능 최적화가되어 있고 일반적으로 버그를 유발할 가능성이 적기 때문에 Redux 개발자들은 Context API 를 사용하여 직접 store 에 접근하는 것 보다는 <code class=\"language-text\">connect()</code> 를 사용하는것을 대부분 추천합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MyComponent {\n  someMethod() {\n    doSomethingWith(this.context.store);\n  }\n}</code></pre></div>\n<ol>\n<li>\n<h3>What is the difference between component and container in React Redux?</h3>\n</li>\n</ol>\n<h4>(React Redux 에서 container 와 component 의 다른점은 무엇인가요?)</h4>\n<p>Component 는 application 의 보여지는 부분을 묘사하는 class 또는 function component 입니다.\nContainer 는 Redux store 와 연결된 component 를 부르는 비공식적인 용어입니다.\nContainer 는 Redux 의 state update 와 action 을 구독하며, DOM element 를 렌더링하지 않습니다. 하위 표현 component 들에게 rendering 을 위임합니다.</p>\n<ol>\n<li>\n<h3>What is the purpose of the constants in Redux?</h3>\n</li>\n</ol>\n<h4>(Redux 안의 상수들의 목적은 무엇인가요?)</h4>\n<p>상수를 사용하면 IDE 를 사용할 때 프로젝트 전체에서 특정한 기능의 모든 사용내역을 쉽게 찾을 수 있습니다. 또한 오타로 인한 어리석은 버그를 방지할 수 있습니다. 오타의 경우 즉시 <code class=\"language-text\">ReferenceError</code> 에러가 발생합니다.</p>\n<p>일반적으로 우리는 하나의 파일에 저장합니다 (<code class=\"language-text\">constants.js</code> 또는 <code class=\"language-text\">actionTypes.js</code>)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const ADD_TODO = \"ADD_TODO\";\nexport const DELETE_TODO = \"DELETE_TODO\";\nexport const EDIT_TODO = \"EDIT_TODO\";\nexport const COMPLETE_TODO = \"COMPLETE_TODO\";\nexport const COMPLETE_ALL = \"COMPLETE_ALL\";\nexport const CLEAR_COMPLETED = \"CLEAR_COMPLETED\";</code></pre></div>\n<p>Redux 에서는 두 가지의 공간에서 사용합니다.</p>\n<ol>\n<li>action 생성중:</li>\n</ol>\n<p><code class=\"language-text\">actions.js</code> 를 만듭니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { ADD_TODO } from \"./actionTypes\";\n\nexport function addTodo(text) {\n  return { type: ADD_TODO, text };\n}</code></pre></div>\n<ol>\n<li>reducers 안에서 <code class=\"language-text\">reducer.js</code> 를 만듭니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { ADD_TODO } from \"./actionTypes\";\n\nexport default (state = [], action) => {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ];\n    default:\n      return state;\n  }\n};</code></pre></div>\n<ol>\n<li>\n<h3>What are the different ways to write mapDispatchToProps()?</h3>\n</li>\n</ol>\n<h4>(mapDispatchToProps() 를 작성하는 다른 방법은 무엇이 있나요?)</h4>\n<p><code class=\"language-text\">mapDispatchToProps()</code> 안에서 <code class=\"language-text\">dispatch()</code> 를 사용하여 action creators 를 바인딩하는 몇가지 방법이 있습니다. 아래와 같은 몇가지 옵션들이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const mapDispatchToProps = dispatch => ({\n  action: () => dispatch(action())\n});</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const mapDispatchToProps = dispatch => ({\n  action: bindActionCreators(action, dispatch)\n});</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const mapDispatchToProps = { action };</code></pre></div>\n<p>세 번째 옵션은 첫 번째 옵션의 축약형 입니다.</p>\n<ol>\n<li>\n<h3>What is the use of the ownProps parameter in mapStateToProps() and mapDispatchToProps()?</h3>\n</li>\n</ol>\n<h4>(mapStateToProps() 그리고 mapDispatchToProps() 에서 ownProps 매개변수는 어떻게 사용하나요?)</h4>\n<p>만약 <code class=\"language-text\">ownProps</code> 매개변수가 명시되었다면, React Redux 는 component 로 전달된 props 를 연결된 함수들로 전달합니다.</p>\n<p>만약 connected component 를 사용한다면:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import ConnectedComponent from \"./containers/ConnectedComponent\";\n\n&lt;ConnectedComponent user={\"john\"} />;</code></pre></div>\n<p><code class=\"language-text\">mapStateToProps()</code> 그리고 <code class=\"language-text\">mapDispatchToProps()</code> 함수 안에서의 <code class=\"language-text\">ownProps</code> 는 객체입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  user: \"john\";\n}</code></pre></div>\n<p>이 객체를 사용하여 무엇을 반환할지 결정할 수 있습니다.</p>\n<ol>\n<li>\n<h3>How to structure Redux top level directories?</h3>\n</li>\n</ol>\n<h4>(어떻게 Redux 의 상위 레벨 디렉토리를 구성하나요?)</h4>\n<p>대부분의 application 들은 아래와 같은 상위 디렉토리를 가집니다.</p>\n<ul>\n<li>Components: Redux 를 알지못하는 멍청한 component 들</li>\n<li>Containers: Redux 와 연결된 똑똑한 component 들</li>\n<li>Actions: 파일의 이름이 app의 일부와 일치하는 모든 action creator 들</li>\n<li>Reducers: 파일의 이름이 state key 와 일치하는 모든 reducer 들</li>\n<li>Store: store 초기화 설정</li>\n</ul>\n<p>이 폴더 구조는 중소의 app 에 적합합니다.</p>\n<h2>redux-saga</h2>\n<h3>1) redux-saga</h3>\n<ul>\n<li>side effects (데이터 가져오기 같은 비동기적인 작업이나 browser cache 에 접근하는 것등) 을 React/Redux 에서 조금 더 쉽게 만들어주는 라이브러리</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> --save redux-saga</code></pre></div>\n<h3></h3>\n<h4>redux-sage 의 근본적 모델</h4>\n<ul>\n<li>sage는 application 안에 분리된 쓰레드이고, side effects 를 위한 단독적인 책임을 가지고 있습니다. </li>\n<li><code class=\"language-text\">redux-saga</code> 는 redux 미들웨어입니다. </li>\n<li>메인 application 에서 Redux actions 과 함께 쓰레드를 시작, 중지, 취소 할 수 있으며 전체의 Redux application 상태에 접근할 수 있고 Redux actions 도 전달할 수 있음</li>\n</ul>\n<h3>call, put</h3>\n<ul>\n<li>둘 다 effect 를 만드는 함수</li>\n<li>call() : middleware 가 promise 를 어떻게 호출할지에 대한 설명하는 effect 을 생성하는데 사용</li>\n<li>put() : store 에 action 을 통하여 전달하도록 미들웨어에게 가르치는 effect 를 생성</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">function* fetchUserSaga(action) {\n  // `call` function accepts rest arguments, which will be passed to `api.fetchUser` function.\n  // Instructing middleware to call promise, it resolved value will be assigned to `userData` variable\n  const userData = yield call(api.fetchUser, action.userId);\n\n  // Instructing middleware to dispatch corresponding action.\n  yield put({\n    type: &quot;FETCH_USER_SUCCESS&quot;,\n    userData\n  });\n}</code></pre></div>\n<h2>redux-thunk</h2>\n<h3>1. redux-thunk</h3>\n<p>Redux Thunk 는 action 대신 함수를 반환하는 action 생성자를 작성 할 수 있는 미들웨어</p>\n<p>Thunk 는 action dispatch 를 지연 시키거나, 특정한 조건이 성립되는 경우에만 dispatch 하도록 할 수 있습니다. 내부 함수는 매개변수로 store method dispatch 그리고 getState 를 받습니다.</p>\n<h4>(redux-saga 와 redux-thunk 의 차이점은 무엇인가요 ?)</h4>\n<p>Redux Thunk 와 Redux Saga 는 모두 side effect 를 방지합니다. 대부분의 시나리오에서 Thunk 는 Promise 를 사용하여 처리하고 Saga 는 Generators 를 사용합니다. Promise 는 많은 개발자들에게 친숙하여 Thunk 는 다루기 쉽고, Sagas / Generator 는 매우 강력하지만 러닝커브가 있습니다. 두 미들웨어 모두 공존 할 수 있습니다. Thunk 로 시작하여도 만약 Saga 가 필요하다면 도입 할 수 있습니다.</p>\n<h3></h3>\n<h4>(Redux DevTools 은 무엇인가요?)</h4>\n<p>Redux DevTools 은 Redux 를 위한 hot reload 기능을 가진 시간 여행 환경의 실시간 편집이 가능한 툴입니다. 액션을 다시 재현하거나 UI 를 사용자정의에 맞게 만들 수 있습니다. Redux DevTools 을 프로젝트에 설치하여 사용하고 싶지 않다면 Chrome 또는 Firefox 용 Extension 사용을 고려 할 수 있습니다.</p>\n<ol>\n<li>\n<h3>What are the features of Redux DevTools?</h3>\n</li>\n</ol>\n<h4>(Redux DevTools 의 목적은 무엇인가요?)</h4>\n<ol>\n<li>모든 상태와 액션을 검사 할 수 있습니다.</li>\n<li>action 을 취소하여 작업을 되돌릴 수 있습니다.</li>\n<li>reducer 의 코드를 변경한다면 각각의 준비된 action 은 다시 평가됩니다.</li>\n<li>action 에서 어떤 일이 일어났는지, 오류가 발생하였는지 알 수 있습니다.</li>\n<li><code class=\"language-text\">persistState()</code> store enhancer 을 사용하면 page reload 에서 debug session 을 지속할 수 있습니다.</li>\n</ol>\n<h3>redux-selector</h3>\n<h4>(Redux selectors 는 무엇이고 왜 사용해야하나요?)</h4>\n<p>Selectors 는 Redux state 를 argument 로 받고 component 에 전달할 데이터를 반환하는 함수입니다.</p>\n<p>예를 들어, 사용자의 세부정보를 얻으려면:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const getUserData = state => state.user.data;</code></pre></div>\n<ol>\n<li>\n<h3>What is Redux Form?</h3>\n</li>\n</ol>\n<h4>(Redux Form 은 무엇인가요?)</h4>\n<p>Redux Form 은 React와 Redux 와 함께 동작하여 React Form 에서 Redux 의 모든 스토어의 상태 값을 사용 할 수 있도록 합니다.\nRedux Form 은 HTML5 의 input 과 함께 사용 할 수 있습니다. 또한 Material UI, React Widgets, React Bootstrap 과 같은 일반적인 UI 프레임워크에서도 잘 동작합니다.</p>\n<ol>\n<li>\n<h3>What are the main features of Redux Form?</h3>\n</li>\n</ol>\n<h4>(Redux Form 의 주요한 기능들은 무엇인가요?)</h4>\n<p>Redux Form 의 주요 기능은 다음과 같습니다</p>\n<ul>\n<li>Field 의 값들은 Redux Store 를 통해 지속됩니다</li>\n<li>검증(동기/비동기) 와 제출</li>\n<li>Field 값에 대한 formatting, parsing, normalization(정규화)</li>\n</ul>\n<h3></h3>\n<h4>Redux 미들웨어 추가</h4>\n<ul>\n<li>applyMiddleware() : 인자 값으로 <code class=\"language-text\">redux-thunk</code> 와 <code class=\"language-text\">logger</code> 를 전달하여 미들웨어를 추가 </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">import { createStore, applyMiddleware } from &#39;redux&#39;\nconst createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore)</code></pre></div>\n<h3></h3>\n<h4>Redux 의 초기값 세팅</h4>\n<p><code class=\"language-text\">createStore</code> 의 두 번째 인자로 초기값을 전달 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">const rootReducer = combineReducers({\n  todos: todos,\n  visibilityFilter: visibilityFilter\n})\n\nconst initialState = {\n  todos: [{ id: 123, name: &#39;example&#39;, completed: false }]\n}\n\nconst store = createStore(\n  rootReducer,\n  initialState\n)</code></pre></div>\n<h3></h3>\n<h4>Relay 와 Redux 차이점</h4>\n<ul>\n<li>둘 다 단일 저장소를 사용</li>\n<li>릴레이는 서버로부터 생성된 상태만 관리하며, </li>\n<li>모든 상태에 대한 접근은 GraphQL 쿼리(읽기 위한)와 Mutations(상태 변경을 위한) 을 통해 사용이 가능합니다. </li>\n<li>릴레이는 변경된 데이터만 가져와 데이터를 캐시하고 최적화</li>\n</ul>\n<h3></h3>\n<h4>Redux Action</h4>\n<ul>\n<li>Application 에서 Store 로 보내는 Javascript Object 또는 전송되는 데이터에 대한 정보(Store 를 위한 정보)</li>\n<li>수행해야되는 작업을 나타내는 type 속성을 반드시 가져야 함</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">{\n  type: ADD_TODO,\n  text: &#39;Add todo item&#39;\n}</code></pre></div>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EB%9E%80\">react란</a></p>\n<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#1react%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">1)React란 무엇인가요?)</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94\">(React의 특징은 무엇이 있을까요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#jsx%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(JSX란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#element%EC%99%80-component%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(element와 component의 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%9D%EC%84%B1%ED%95%98%EB%82%98%EC%9A%94\">(React에서 컴포넌트를 어떻게 생성하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B8%EC%A0%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%96%B8%EC%A0%9C-functional-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C%EC%9A%94\">(언제 클래스 컴포넌트를 사용하고 언제 Functional 컴포넌트를 사용할까요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%88%9C%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(순수 컴포넌트란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#state%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(state란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#props%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(props란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#state%EC%99%80-props%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(state와 props의 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#state%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(state를 직접 업데이트 하면 안되는 이유는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#setstate%EC%97%90%EC%84%9C-callback%EC%9D%98-%EC%97%AD%ED%95%A0%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(setState에서 callback의 역할은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#note-callback-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EB%B3%B4%EB%8B%A8-lifecycle-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%8A%B5%EB%8B%88%EB%8B%A4\">Note: callback 함수를 이용하는 것보단 lifecycle 메서드를 이용하는 것이 좋습니다.</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#html%EA%B3%BC-react%EC%9D%98-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(HTML과 React의 이벤트 처리 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#this%EB%A5%BC-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B2%83%EB%93%A4%EC%9D%B4-%EC%9E%88%EB%82%98%EC%9A%94\">(This를 바인딩하는 방법은 어떤 것들이 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EB%98%90%EB%8A%94-%EC%BD%9C%EB%B0%B1%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%84%EB%8B%AC%ED%95%98%EB%82%98%EC%9A%94\">(이벤트 핸들러 또는 콜백에 매개변수를 어떻게 전달하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A9%EC%84%B1-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React에서의 합성 이벤트는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%9D%B8%EB%9D%BC%EC%9D%B8-%EC%A1%B0%EA%B1%B4%EC%8B%9D%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(인라인 조건식은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#list-%EC%97%90%EC%84%9C-key%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(list 에서 key를 사용했을 때의 이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#ref%EC%9D%98-%EC%9A%A9%EB%8F%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(ref의 용도는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#create-refs%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%82%98%EC%9A%94\">(create refs를 어떻게 만드나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#forward-refs-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(forward refs 란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#callback-refs-%EC%99%80-finddomnode-%EC%A4%91%EC%97%90-%EC%96%B4%EB%96%A4%EA%B2%83%EC%9D%84-%EB%8D%94-%EC%84%A0%ED%98%B8%ED%95%98%EB%82%98%EC%9A%94\">(callback refs 와 findDOMNode 중에 어떤것을 더 선호하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-string-refs-%EB%8A%94-legacy%EA%B0%80-%EB%90%98%EC%97%88%EB%82%98%EC%9A%94\">(왜 String Refs 는 legacy가 되었나요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#virtual-dom\">Virtual DOM</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#1-virtual-dom\">1) virtual dom</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#2-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">2) 동작 과정</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#shadow-dom%EA%B3%BC-virtual-dom%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">(Shadow DOM과 Virtual DOM의 차이점)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-fiber%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Fiber란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-fiber%EC%9D%98-%EC%A3%BC%EC%9A%94-%EB%AA%A9%ED%91%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Fiber의 주요 목표는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#controlled-components-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(controlled components 란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#uncontrolled-components-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(uncontrolled components 란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#createelement%EC%99%80-cloneelement%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(createElement와 cloneElement의 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-lifting-state-up-%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 에서 Lifting State Up 은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#component-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%8B%A8%EA%B3%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94\">(component 라이프사이클 단계는 무엇이 다른가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%9D%98-lifecycle-methods%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React의 lifecycle methods는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#higher-order-components-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Higher-Order components 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#hoc-component-%EC%9C%84%ED%95%9C-props-proxy-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%B2%95\">(HOC component 위한 props proxy 만드는법?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#context%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94\">(context가 뭔가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#children-prop%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(children prop란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%97%90%EC%84%9C-%EC%A3%BC%EC%84%9D%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%93%B0%EB%82%98%EC%9A%94\">(React에서 주석은 어떻게 쓰나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#props-argument%EC%99%80-%ED%95%A8%EA%BB%98-super-constructor%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(props argument와 함께 super constructor를 사용하는 목적은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#reconciliation%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(reconciliation란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EB%8F%99%EC%A0%81-key-name-%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-set-state%EB%A5%BC-%ED%95%98%EB%82%98%EC%9A%94\">(동적 key name 으로 어떻게 set State를 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#render%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\">render에서 함수 사용 시 주의사항</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-component-%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%80-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%ED%91%9C%EA%B8%B0%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(왜 Component 의 이름은 대문자로 표기해야하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-react-%EB%8A%94-class%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-classname-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(왜 React 는 class를 사용하지 않고 className 속성을 사용하나요?)</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#fragment\">Fragment</a></li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-fragments-%EA%B0%80-div-%EB%B3%B4%EB%8B%A4-%EC%A2%8B%EB%82%98%EC%9A%94-\">(왜 fragments 가 div 보다 좋나요 ?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-portals%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C-\">(React 에서 portals은 무엇입니까 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#stateless-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(stateless 컴포넌트는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#stateful-components-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(stateful components 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%97%90%EC%84%9C-props%EC%9D%98-%EC%9C%A0%ED%9A%A8%EC%84%B1%EA%B2%80%EC%82%AC%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94-\">(React에서 Props의 유효성검사를 적용하나요 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%9D%98-%EC%9E%A5%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React의 장점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%9D%98-%ED%95%9C%EA%B3%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React의 한계는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-v16-%EC%97%90%EC%84%9C-error-boundaries%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React v16 에서 error boundaries는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-v15-%EC%97%90%EC%84%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-error-boundaries-%EC%B2%98%EB%A6%AC%ED%95%98%EB%82%98%EC%9A%94\">(React v15 에서는 어떻게 error boundaries 처리하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EA%B6%8C%EC%9E%A5%EB%90%98%EB%8A%94-static-%ED%95%9C-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(권장되는 static 한 타입 체크방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-dom-%ED%8C%A8%ED%82%A4%EC%A7%80%EC%9D%98-%EC%82%AC%EC%9A%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(react-dom 패키지의 사용법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-dom%EC%9D%98-render-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React dom의 render 메서드의 목적은 무엇인가요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#reactdomserver-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(ReactDOMServer 란 무엇인가요?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%97%90%EC%84%9C-innerhtml%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(React에서 innerHTML을 어떻게 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(React 스타일을 어떻게 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94\">(React 에서 이벤트는 어떻게 다른가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#constructor-%EC%97%90%EC%84%9C-setstate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EB%AC%B4%EC%8A%A8%EC%9D%BC%EC%9D%B4-%EC%83%9D%EA%B8%B0%EB%82%98%EC%9A%94-\">(constructor 에서 setState를 사용하면 무슨일이 생기나요? )</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#index-%EA%B0%80-key-%EB%A1%9C-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(index 가 key 로 미치는 영향은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#componentwillmount-%EC%97%90%EC%84%9C-setstate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%8C-%EC%A2%8B%EB%82%98%EC%9A%94-\">(componentWillMount 에서 setState를 사용하는게 좋나요 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#state-%EC%9D%98-%EC%B4%88%EA%B8%B0%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-props-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C%EB%90%98%EB%82%98%EC%9A%94\">(state 의 초기상태에서 props 를 사용하면 어떻게되나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%94%B0%EB%A5%B8-component-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%82%98%EC%9A%94-\">(조건에 따른 component 렌더링은 어떻게 하나요 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#dom-element-%EC%97%90-props-%EB%A5%BC-spreading-%ED%95%A0%EB%95%8C-%EC%99%9C-%EC%A1%B0%EC%8B%AC%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">(DOM element 에 props 를 spreading 할때 왜 조심해야 하나요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#decorator\">Decorator</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#memoize-component\">memoize component</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#server-side-renderingssr\">Server Side Rendering(SSR)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#production-%EB%AA%A8%EB%93%9C\">production 모드</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#cra%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-cra%EC%9D%98-%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(CRA는 무엇이고 CRA의 이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EB%A7%88%EC%9A%B4%ED%8C%85%EC%97%90%EC%84%9C-lifecycle-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%88%9C%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(마운팅에서 lifecycle 메서드의 순서는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-v16-%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-lifecycle-%EB%A9%94%EC%84%9C%EB%93%9C\">React v16 에서 사용되지 않을 lifecycle 메서드</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#getderivedstatefromprops-lifecycle-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%AA%A9%EC%A0%81\">getDerivedStateFromProps() lifecycle 메서드의 목적</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#getsnapshotbeforeupdate-lifecycle-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(getSnapshotBeforeUpdate() lifecycle 메서드의 목적은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#createelement-%EC%99%80-cloneelement-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(createElement() 와 cloneElement() 의 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#component-%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-%EA%B6%8C%EC%9E%A5%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(component 의 이름을 지정하는 권장방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#component-class-%EC%95%88%EC%97%90%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%B6%94%EC%B2%9C-%EC%88%9C%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(component class 안에서 메서드의 추천 순서는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#switching-component-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(switching component 란 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-setstate-%EC%97%90-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(왜 setState 에 함수를 전달해야하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-strict-mode-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 에서 strict mode 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-mixins%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Mixins은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-ismounted-%EA%B0%80-%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4%EC%9D%B4%EA%B3%A0-%ED%95%B4%EA%B2%B0%EC%B1%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(왜 isMounted() 가 안티패턴이고 해결책은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-pointer-events-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 에서 지원하는 Pointer Events 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-component-%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%80-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(왜 Component 의 이름은 대문자로 시작해야하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-v16-%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-dom-%EC%86%8D%EC%84%B1%EC%9D%B4-%EC%A7%80%EC%9B%90%EB%90%98%EB%82%98%EC%9A%94\">(React v16 에서 사용자 정의 DOM 속성이 지원되나요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#constructor-%EC%99%80-getinitialstate%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(constructor 와 getInitialState의 차이점은 무엇인가요?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#setstate-%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-component-%EB%A5%BC-%EA%B0%95%EC%A0%9C%EB%A1%9C-%EC%9E%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%8B%9C%ED%82%AC-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(setState 를 호출하지 않고 component 를 강제로 재 렌더링 시킬 수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#es6-class-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-react-%EC%97%90%EC%84%9C-super-%EC%99%80-superprops-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">ES6 class 를 사용하는 React 에서 super() 와 super(props) 의 차이점은 무엇인가요?</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-jsx-%EC%95%88%EC%97%90%EC%84%9C-loop-%EB%A5%BC-%ED%95%98%EB%82%98%EC%9A%94\">어떻게 JSX 안에서 loop 를 하나요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#attribute-%EB%94%B0%EC%98%B4%ED%91%9C%EC%97%90%EC%84%9C-props-%EC%97%90-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%91%EA%B7%BC%ED%95%98%EB%82%98%EC%9A%94\">(attribute 따옴표에서 props 에 어떻게 접근하나요?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%94%B0%EB%9D%BC-class-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 조건에 따라 class 속성을 적용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%99%80-reactdom%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94\">(React와 ReactDOM은 무엇이 다른가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-react-%EC%99%80-reactdom%EC%9D%80-%EB%B6%84%EB%A6%AC%EB%90%98%EC%96%B4%EC%9E%88%EB%82%98%EC%9A%94\">(왜 React 와 ReactDOM은 분리되어있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-label-element-%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(React 에서 label element 를 어떻게 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-inline-style-object-%EB%A5%BC-%ED%95%A9%EC%B9%98%EB%82%98%EC%9A%94\">(어떻게 여러개의 inline style object 를 합치나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80-resize-%EB%90%A0-%EB%95%8C-%EC%9E%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%8B%9C%ED%82%A4%EB%82%98%EC%9A%94\">(어떻게 브라우저가 resize 될 때 재 렌더링 시키나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#setstate-%EC%99%80-replacestate-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(setState() 와 replaceState() 의 차이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-state-%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-listen-%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 state 의 변경을 listen 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-state-%EC%97%90%EC%84%9C-%EB%B0%B0%EC%97%B4%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%8A%94-%EC%B6%94%EC%B2%9C%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React state 에서 배열요소를 제거하는 추천방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#html-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%86%EC%9D%B4-react-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">HTML 렌더링 없이 React 사용하기</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%99%80-%ED%95%A8%EA%BB%98-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EC%81%98%EA%B2%8C-json-%EC%9D%84-print-%ED%95%98%EB%82%98%EC%9A%94\">(React와 함께 어떻게 이쁘게 JSON 을 print 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#create-react-app-%EC%97%90-polyfills%EB%A5%BC-%ED%8F%AC%ED%95%A8%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(create-react-app 에 polyfills를 포함시키는 방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#create-react-app-%EC%97%90%EC%84%9C-http-%EB%8C%80%EC%8B%A0-https-%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(create-react-app 에서 http 대신 https 를 어떻게 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#create-react-app-%EC%97%90%EC%84%9C-%EC%83%81%EB%8C%80%EA%B2%BD%EB%A1%9C-import-%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%94%BC%ED%95%98%EB%82%98%EC%9A%94\">(create-react-app 에서 상대경로 import 를 어떻게 피하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-react-router-%EC%97%90-google-analytics-%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 React Router 에 Google Analytics 를 추가하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A7%A4-%EC%B4%88-%EB%A7%88%EB%8B%A4-component-%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 매 초 마다 component 를 업데이트 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B8%EB%9D%BC%EC%9D%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%97%90-vendor-prefixes-%EB%A5%BC-%EB%B6%99%EC%9D%BC%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(React 에서 어떻게 인라인 스타일에 vendor prefixes 를 붙일수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react%EC%99%80-es6%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-component-%EB%A5%BC-import-%EC%99%80-export-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(React와 ES6에서 어떻게 component 를 import 와 export 할 수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-react-compnent-%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%80-%EB%8C%80%EB%AC%B8%EC%9E%90%EC%97%AC%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(왜 React compnent 의 이름은 대문자여야하나요?)</a></li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-component-%EC%83%9D%EC%84%B1%EC%9E%90%EB%8A%94-%ED%95%9C%EB%B2%88%EB%A7%8C-%ED%98%B8%EC%B6%9C%EB%90%98%EB%82%98%EC%9A%94\">(왜 component 생성자는 한번만 호출되나요?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%81%EC%88%98%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EB%82%98%EC%9A%94\">(React 에서 어떻게 상수를 정의하나요?)</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%ED%81%B4%EB%A6%AD-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A5%BC-%ED%8A%B8%EB%A6%AC%EA%B1%B0-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(React 에서 어떻게 프로그래밍 방식으로 클릭 이벤트를 트리거 할 수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EA%B8%B0%EB%B3%B8-react-%EC%97%90%EC%84%9C-asyncawait-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(기본 React 에서 async/await 를 사용할 수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%9D%98-%EC%9D%BC%EB%B0%98-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 의 일반 폴더 구조는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B8%EA%B8%B0%EC%9E%88%EB%8A%94-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(애니메이션을 위한 인기있는 패키지는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#styles-modules-%EC%9D%98-%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(styles modules 의 이점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%9D%B8%EA%B8%B0%EC%9E%88%EB%8A%94-react-linters-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(인기있는 React linters 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-ajax-%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B3%A0-%EC%96%B4%EB%96%A4-lifecycle-%EC%97%90%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 AJAX 를 호출하고 어떤 lifecycle 에서 메서드를 호출해야하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#render-props-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Render Props 란 무엇인가요?)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router\">React Router</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router-%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Router 가 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router-%EC%99%80-history-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EB%8B%A4%EB%A5%B8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React router 와 history 라이브러리의 다른점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router-v4-%EC%9D%98-component-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EC%9E%88%EB%82%98%EC%9A%94\">(React router v4 의 component 는 무엇이 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#history%EC%9D%98-push-%EC%99%80-replace-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(history의 push() 와 replace() 메서드의 목적은 무엇인가요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#how-do-you-programmatically-navigate-using-react-router-v4\">How do you programmatically navigate using React Router v4?</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-react-router-v4-%EC%9D%98-navigate-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 프로그래밍 방식으로 React Router v4 의 navigate 를 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router-v4-%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-query-parameters-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%82%98%EC%9A%94\">(React Router v4 에서 어떻게 query parameters 가져오나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-router-%EB%8A%94-%EC%98%A4%EC%A7%81-%ED%95%98%EB%82%98%EC%9D%98-%EC%9E%90%EC%8B%9D-element-%EB%A7%8C-%EC%9E%88%EC%9D%84-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EB%9D%BC%EB%8A%94-%EA%B2%BD%EA%B3%A0%EB%A5%BC-%EB%B0%9B%EB%82%98%EC%9A%94\">(왜 “Router 는 오직 하나의 자식 element 만 있을 수 있습니다” 라는 경고를 받나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-router-v4-%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-historypush-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%98%EB%82%98%EC%9A%94\">(React Router v4 에서 어떻게 history.push 메서드에 파라미터를 전달하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EA%B8%B0%EB%B3%B8-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%98%90%EB%8A%94-notfound-%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%98%EB%82%98%EC%9A%94\">(기본 페이지 또는 NotFound 를 어떻게 구현하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-react-router-v4%EC%97%90%EC%84%9C-history%EB%A5%BC-%EC%96%BB%EB%82%98%EC%9A%94\">(어떻게 React Router v4에서 history를 얻나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%9B%84%EC%97%90-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-redirect-%EB%A5%BC-%EC%8B%9C%ED%82%A4%EB%82%98%EC%9A%94\">(어떻게 로그인후에 자동으로 redirect 를 시키나요?)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-internationalization\">React Internationalization</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-intl-%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Intl 이 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-intl-%EC%9D%98-%EC%A3%BC%EC%9A%94-%ED%8A%B9%EC%A7%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Intl 의 주요 특징은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-intl-%EC%97%90%EC%84%9C-formatting-%EC%9D%84-%ED%95%98%EB%8A%94-%EB%91%90-%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Intl 에서 formatting 을 하는 두 가지 방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-react-intl%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A5%BC-placeholder-%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 React Intl를 사용하여 를 placeholder 로 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-react-intl-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%98%84%EC%9E%AC-locale-%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 React Intl 를 사용하여 현재 locale 에 접근하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-intl-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%A0%EC%A7%9C-%ED%98%95%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%82%98%EC%9A%94\">(React Intl 을 사용해서 어떻게 날짜 형식을 지정하나요?)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-testing\">React Testing</a></p>\n<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 테스트에서 얕은 렌더링은 무엇인가요?)</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%9D%98-testrenderer-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 의 TestRenderer 패키지는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#reacttestutils-%ED%8C%A8%ED%82%A4%EC%A7%80%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(ReactTestUtils 패키지의 목적은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#jest-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Jest 는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#jasmine-%EB%B3%B4%EB%8B%A4-%EC%A2%8B%EC%9D%80-jest-%EC%9D%98-%EC%9E%A5%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Jasmine 보다 좋은 Jest 의 장점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#jest-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%A0%9C%EC%9E%85%EB%8B%88%EB%8B%A4\">(Jest 테스트 케이스의 간단한 예제입니다)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-redux\">React Redux</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#flux-%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94\">(Flux 가 뭔가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94\">(Redux 가 뭔가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-%EC%9D%98-%ED%95%B5%EC%8B%AC%EC%A0%81%EC%9D%B8-%EC%9B%90%EB%A6%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React 의 핵심적인 원리는 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#flux-%EC%99%80-%EB%B9%84%EA%B5%90%ED%96%88%EC%9D%84%EB%95%8C-redux-%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Flux 와 비교했을때 Redux 의 단점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#mapstatetoprops-%EC%99%80-mapdispatchtoprops-%EC%9D%98-%EB%8B%A4%EB%A5%B8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(mapStateToProps() 와 mapDispatchToProps() 의 다른점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#reducer-%EC%97%90%EC%84%9C-action-%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">(reducer 에서 action 을 전달할 수 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#component-%EC%9D%98-%EB%B0%96%EC%97%90%EC%84%9C-redux-store-%EC%97%90-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%91%EA%B7%BC%ED%95%98%EB%82%98%EC%9A%94\">(component 의 밖에서 Redux store 에 어떻게 접근하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#mvw-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(MVW 패턴의 단점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-%EC%99%80-rxjs-%EC%9D%98-%EC%9C%A0%EC%82%AC%ED%95%9C%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%82%98%EC%9A%94\">(Redux 와 RxJS 의 유사한점이 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-load-%EC%8B%9C%EC%97%90-action-%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 load 시에 action 을 전달하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-react-redux-%EC%97%90%EC%84%9C-connect-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 React Redux 에서 connect() 를 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-redux-%EC%97%90%EC%84%9C-%EC%83%81%ED%83%9C-%EA%B0%92%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 Redux 에서 상태 값을 초기화하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-connect-decorator-%EC%9D%98-at-symbol-%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux connect decorator 의 at symbol 의 목적은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-context-%EC%99%80-react-redux-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94\">(React context 와 React Redux 는 무엇이 다른가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%99%9C-redux-%EC%83%81%ED%83%9C-%ED%95%A8%EC%88%98%EB%A5%BC-reducers-%EB%9D%BC-%EB%B6%80%EB%A5%B4%EB%82%98%EC%9A%94-\">(왜 Redux 상태 함수를 reducers 라 부르나요 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-redux-%EC%97%90%EC%84%9C-ajax-%EC%9A%94%EC%B2%AD%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 Redux 에서 AJAX 요청을 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-store-%EC%97%90%EC%84%9C-component-%EB%93%A4%EC%9D%98-%EB%AA%A8%EB%93%A0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B3%A0-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">(Redux Store 에서 component 들의 모든 상태를 저장하고 있어야 하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-store-%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EC%98%AC%EB%B0%94%EB%A5%B8-%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux store 에 접근하는 올바른 방법은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#react-redux-%EC%97%90%EC%84%9C-container-%EC%99%80-component-%EC%9D%98-%EB%8B%A4%EB%A5%B8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(React Redux 에서 container 와 component 의 다른점은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-%EC%95%88%EC%9D%98-%EC%83%81%EC%88%98%EB%93%A4%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux 안의 상수들의 목적은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#mapdispatchtoprops-%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4-%EC%9E%88%EB%82%98%EC%9A%94\">(mapDispatchToProps() 를 작성하는 다른 방법은 무엇이 있나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#mapstatetoprops-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mapdispatchtoprops-%EC%97%90%EC%84%9C-ownprops-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94\">(mapStateToProps() 그리고 mapDispatchToProps() 에서 ownProps 매개변수는 어떻게 사용하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#%EC%96%B4%EB%96%BB%EA%B2%8C-redux-%EC%9D%98-%EC%83%81%EC%9C%84-%EB%A0%88%EB%B2%A8-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EA%B5%AC%EC%84%B1%ED%95%98%EB%82%98%EC%9A%94\">(어떻게 Redux 의 상위 레벨 디렉토리를 구성하나요?)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-saga\">redux-saga</a></p>\n<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#1-redux-saga\">1) redux-saga</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-sage-%EC%9D%98-%EA%B7%BC%EB%B3%B8%EC%A0%81-%EB%AA%A8%EB%8D%B8\">redux-sage 의 근본적 모델</a></li>\n</ul>\n</li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#call-put\">call, put</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-thunk\">redux-thunk</a></p>\n<ul>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#1-redux-thunk\">1. redux-thunk</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-saga-%EC%99%80-redux-thunk-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-\">(redux-saga 와 redux-thunk 의 차이점은 무엇인가요 ?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-devtools-%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux DevTools 은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-devtools-%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux DevTools 의 목적은 무엇인가요?)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-selector\">redux-selector</a></p>\n<ul>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-selectors-%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">(Redux selectors 는 무엇이고 왜 사용해야하나요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-form-%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux Form 은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-form-%EC%9D%98-%EC%A3%BC%EC%9A%94%ED%95%9C-%EA%B8%B0%EB%8A%A5%EB%93%A4%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">(Redux Form 의 주요한 기능들은 무엇인가요?)</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EC%B6%94%EA%B0%80\">Redux 미들웨어 추가</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-%EC%9D%98-%EC%B4%88%EA%B8%B0%EA%B0%92-%EC%84%B8%ED%8C%85\">Redux 의 초기값 세팅</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#relay-%EC%99%80-redux-%EC%B0%A8%EC%9D%B4%EC%A0%90\">Relay 와 Redux 차이점</a></li>\n<li><a href=\"/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%A9%B4%EC%A0%91%20%EC%A7%88%EB%AC%B8%20-%20React(2)/#redux-action\">Redux Action</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"프론트엔드 면접 질문 - React(2)","path":"/프론트엔드 면접 질문 - React(2)/","images":["images/2.jpg"],"category":"기술 면접","tags":["프론트엔드","개발자","면접","기술면접","React"],"date":"2021-11-02T01:00:00.000Z","components":null,"tweets":null,"summary":"프론트엔드 면접 질문 - React(2)"}},"posts":{"edges":[{"node":{"frontmatter":{"type":"portfolio","title":"MOIJA","images":["moija/images/moija.png","moija/images/moija1.png","moija/images/moija2.png","moija/images/moija3.png","moija/images/moija4.png","moija/images/moija5.png"],"path":"/portfolios/moija/","tags":null,"date":"2022-03-02T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"portfolio","title":"VUELOG","images":["vuelog/images/vuelog.png","vuelog/images/vuelog1.png","vuelog/images/vuelog2.png","vuelog/images/vuelog3.png","vuelog/images/vuelog4.png","vuelog/images/vuelog5.png","vuelog/images/vuelog6.png"],"path":"/portfolios/VUELOG/","tags":null,"date":"2022-03-01T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"portfolio","title":"DT CENTER","images":["dtcenter/images/dtcenter.png","dtcenter/images/dtcenter1.png","dtcenter/images/dtcenter2.png","dtcenter/images/dtcenter3.png"],"path":"/portfolios/DT CENTER/","tags":null,"date":"2022-02-21T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"portfolio","title":"COLORBERRY","images":["ColorBerry/images/colorberry.png","ColorBerry/images/colorberry2.png","ColorBerry/images/colorberry3.png","ColorBerry/images/colorberry4.png","ColorBerry/images/colorberry5.png","ColorBerry/images/colorberry6.png","ColorBerry/images/colorberry7.png","ColorBerry/images/colorberry8.png"],"path":"/portfolios/COLORBERRY/","tags":null,"date":"2022-02-20T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문 - cs","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문 - cs/","tags":["벡엔드","개발자","면접","기술면접","CS"],"date":"2021-11-22T04:00:00.000Z","summary":"벡엔드 개발자 면접 질문 - cs"}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문 - 네트워크","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문 - 네트워크/","tags":["벡엔드","개발자","면접","기술면접","CS"],"date":"2021-11-22T03:00:00.000Z","summary":"벡엔드 개발자 면접 질문 - 네트워크"}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문 - 운영체제","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문 - 운영체제/","tags":["벡엔드","개발자","면접","기술면접","CS"],"date":"2021-11-22T02:00:00.000Z","summary":"벡엔드 개발자 면접 질문 - 운영체제"}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문 - 데이터베이스","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문 - 데이터베이스/","tags":["벡엔드","개발자","면접","기술면접","CS"],"date":"2021-11-228T03:00:00.000Z","summary":"벡엔드 개발자 면접 질문 - 데이터베이스"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 면접 질문 - React(2)","images":["images/2.jpg"],"path":"/프론트엔드 면접 질문 - React(2)/","tags":["프론트엔드","개발자","면접","기술면접","React"],"date":"2021-11-02T01:00:00.000Z","summary":"프론트엔드 면접 질문 - React(2)"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 면접 질문 - React(1)","images":["images/2.jpg"],"path":"/프론트엔드 면접 질문 - React(1)/","tags":["프론트엔드","개발자","면접","기술면접","React"],"date":"2021-11-01T01:00:00.000Z","summary":"프론트엔드 면접 질문 - React(1)"}}},{"node":{"frontmatter":{"type":null,"title":"threejs - 시작하기","images":["images/threejs.png"],"path":"/threejs - 시작하기/","tags":["threejs"],"date":"2021-09-4T01:00:00.000Z","summary":"threejs - 시작하기"}}},{"node":{"frontmatter":{"type":null,"title":"우아한 테크 캠프 4기 - 4주차 회고","images":["images/woowa.jpg"],"path":"/우아한 테크 캠프 4기 - 4주차 회고/","tags":["우아한 테크 캠프","우아한 테크 캠프 4기","우아한 리액트","리액트"],"date":"2021-08-02T19:21:00000Z","summary":"우아한 테크 캠프 4기 - 4주차 회고"}}},{"node":{"frontmatter":{"type":null,"title":"우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기","images":["images/woowa.jpg"],"path":"/우아한 테크 캠프 4기 - 바닐라로 함수형 리액트 만들기 (1) - useState, useEffect 만들기/","tags":["우아한 테크 캠프","우아한 테크 캠프 4기","우아한 리액트","리액트"],"date":"2021-07-11T19:21:00000Z","summary":"우아한 테크 캠프 4기 - 우아한 리액트 만들기 - useState, useEffect 만들기"}}},{"node":{"frontmatter":{"type":null,"title":"react - Jest 사용하기","images":["images/react.jpg"],"path":"/react - Jest 사용하기/","tags":["리액트","react"],"date":"2021-06-06T01:06:00.000Z","summary":"react - Jest 사용하기 정리 자료입니다."}}},{"node":{"frontmatter":{"type":null,"title":"redux-toolkit - 튜토리얼","images":["images/react.jpg"],"path":"/redux-toolkit - 튜토리얼/","tags":["리액트","react","redux","redux-toolkit"],"date":"2021-06-05T01:06:00.000Z","summary":"redux-toolkit - 튜토리얼 정리 자료입니다."}}},{"node":{"frontmatter":{"type":null,"title":"redux-toolkit - createSlice","images":["images/react.jpg"],"path":"/redux-toolkit - createSlice/","tags":["리액트","react","redux","redux-toolkit"],"date":"2021-06-05T01:06:00.000Z","summary":"redux-toolkit - createSlice 정리 자료입니다."}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - REST API","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - REST API/","tags":["자바스크립트"],"date":"2021-06-04T01:00:00.000Z","summary":"자바스크립트 요점 정리 - REST API 파트"}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - 타이머","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - 타이머/","tags":["자바스크립트"],"date":"2021-06-04T01:00:00.000Z","summary":"자바스크립트 요점 정리 - 타이머 파트"}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - 프로토타입","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - 프로토타입/","tags":["자바스크립트"],"date":"2021-06-03T01:00:00.000Z","summary":"자바스크립트 요점 정리 - 프로토타입 파트"}}},{"node":{"frontmatter":{"type":null,"title":"자바 요점 정리 - 객체지향 2","images":["images/java.jpg"],"path":"/자바 요점 정리 - 객체지향 2/","tags":["자바"],"date":"2021-05-25T01:00:00.000Z","summary":"자바 요점 정리 - 객체지향 2"}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - 실행 컨텍스트","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - 실행 컨텍스트/","tags":["자바스크립트"],"date":"2021-05-25T01:00:00.000Z","summary":"자바스크립트 요점 정리 - 실행 컨텍스트"}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 1-프로그래밍 언어 활용(1)-개요","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 1-프로그래밍 언어 활용(1)-개요/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-21T22:23:00.000Z","summary":"2021 정보 처리 기사 실기 요약 1-프로그래밍 언어 활용(1)-개요 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 1-프로그래밍 언어(2)-언어 활용","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 1-프로그래밍 언어(2)-언어 활용/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-20T20:21:00.000Z","summary":"2020 정보 처리 기사 실기 요약 1-프로그래밍 언어(2)-언어 활용 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 2-요구 사항 확인","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 2-요구 사항 확인/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-19T17:21:00.000Z","summary":"2021 정보 처리 기사 실기 요약 2-요구 사항 확인 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 3-데이터 입출력 구현","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 3-데이터 입출력 구현/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-18T17:22:00.000Z","summary":"2021 정보 처리 기사 데이터 입출력 구현 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 4-통합 구현","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 4-통합 구현/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-17T05:31:00.000Z","summary":"2021 정보 처리 기사 통합 구현 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 5-서버 프로그램 구현","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 5-서버 프로그램 구현/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-16T06:31:00.000Z","summary":"2021 정보 처리 기사 서버 프로그램 구현 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 6-화면 설계","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 6-화면 설계/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-15T17:00:00.000Z","summary":"2021 정보 처리 기사 화면 설계 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 7-애플리케이션 테스트 관리","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 7-애플리케이션 테스트 관리/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-14T17:00:00.000Z","summary":"2021 정보 처리 기사 애플리케이션 테스트 관리 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 8-SQL 응용","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 8-SQL 응용/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-12T12:45:00.000Z","summary":"2021 정보 처리 기사 SQL 응용 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 9-소프트웨어 보안 구축","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 9-소프트웨어 보안 구축/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-11T19:00:00.000Z","summary":"2021 정보 처리 기사 소프트웨어 보안 구축 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 10-응용-네트워크","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 10-응용-네트워크/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-10T21:03:00.000Z","summary":"2021 정보 처리 기사 실기 요약 10-응용-네트워크 활용 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(3)","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(3)/","tags":["프론트엔드","개발자","면접","기술면접","Vue"],"date":"2021-05-07T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(3)"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)/","tags":["프론트엔드","개발자","면접","기술면접","Vue"],"date":"2021-05-06T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(2)"}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 10-응용-운영체제 활용","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 10-응용-운영체제 활용/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-03T21:01:00.000Z","summary":"2021 정보 처리 기사 실기 요약 10-응용-운영체제 활용 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 10-응용-프로세스 관리","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 10-응용-프로세스 관리/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-02T21:01:00.000Z","summary":"2021 정보 처리 기사 실기 요약 10-응용-프로세스 관리 활용 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2021 정보 처리 기사 실기 요약 11-제품 소프트웨어 패키징","images":["images/1.jpg"],"path":"/2021 정보 처리 기사 실기 요약 11-제품 소프트웨어 패키징/","tags":["정보처리기사 실기 요약","정보처리기사","정처기"],"date":"2021-05-01T23:03:00.000Z","summary":"2021 정보 처리 기사 제품 소프트웨어 패키징 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - node","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - node/","tags":["벡엔드","개발자","면접","기술면접","node"],"date":"2021-04-20T01:00:00.000Z","summary":"벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - node"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Nuxt","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Nuxt/","tags":["프론트엔드","개발자","면접","기술면접","Nuxt"],"date":"2021-04-15T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Nuxt"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(1)","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(1)/","tags":["프론트엔드","개발자","면접","기술면접","Vue"],"date":"2021-04-15T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - Vue(1)"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - CSS","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - CSS/","tags":["프론트엔드","개발자","면접","기술면접","CSS"],"date":"2021-04-14T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - CSS"}}},{"node":{"frontmatter":{"type":null,"title":"벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 기술스택","images":["images/2.jpg"],"path":"/벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 기술스택/","tags":["벡엔드","개발자","면접","기술면접","기술스택"],"date":"2021-04-09T01:00:00.000Z","summary":"벡엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 기술스택"}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - this","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - this/","tags":["자바스크립트"],"date":"2021-04-07T01:00:00.000Z","summary":"자바스크립트 요점 정리 - this 파트"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2)/","tags":["프론트엔드","개발자","면접","기술면접","자바스크립트"],"date":"2021-04-07T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(2) 파트"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(1)","images":["images/2.jpg"],"path":"/프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(1)/","tags":["프론트엔드","개발자","면접","기술면접","자바스크립트"],"date":"2021-04-07T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 자바스크립트(1) 파트"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 프론트엔드","images":["images/2.jpg"],"path":"/프론트엔드 면접 질문 - 브라우저/","tags":["프론트엔드","개발자","면접","기술면접","자바스크립트"],"date":"2021-04-07T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 프론트엔드 파트 - 브라우저"}}},{"node":{"frontmatter":{"type":null,"title":"프론트엔드 면접 질문 - graphql","images":["images/2.jpg"],"path":"/프론트엔드 면접 질문 - graphql/","tags":["프론트엔드","개발자","면접","기술면접","자바스크립트"],"date":"2021-04-07T01:00:00.000Z","summary":"프론트엔드 개발자 면접 질문(기술면접) 질문 정리 모음 - 프론트엔드 파트 - graphql"}}},{"node":{"frontmatter":{"type":null,"title":"자바스크립트 요점 정리 - history api 정리","images":["images/js.png"],"path":"/자바스크립트 요점 정리 - history api/","tags":["자바스크립트"],"date":"2021-03-03T12:23:00.000Z","summary":"자바스크립트 요점 정리 - history api 정리"}}},{"node":{"frontmatter":{"type":null,"title":"프로그래머스 데브매칭 상태관리","images":["images/pg.jpg"],"path":"/프로그래머스 데브매칭 상태관리/","tags":["프로그래머스 데브매칭","상태관리"],"date":"2021-03-01T12:23:00.000Z","summary":"프로그래머스 데브매칭 상태관리입니다."}}},{"node":{"frontmatter":{"type":null,"title":"프로그래머스 데브매칭 고양이 정리","images":["images/pg.jpg"],"path":"/프로그래머스 데브매칭 고양이 정리/","tags":["프로그래머스 데브매칭","고양이 사진첩"],"date":"2021-03-01T12:23:00.000Z","summary":"프로그래머스 데브매칭 고양이 정리입니다."}}},{"node":{"frontmatter":{"type":null,"title":"프로그래머스 데브매칭 라우팅","images":["images/pg.jpg"],"path":"/프로그래머스 데브매칭 라우팅/","tags":["프로그래머스","데브매칭","소프트웨어"],"date":"2021-03-01T12:23:00.000Z","summary":"프로그래머스 데브매칭 라우팅입니다."}}},{"node":{"frontmatter":{"type":"portfolio","title":"MBTI WORLD","images":["mbtiworld/images/mbtiworld.png","mbtiworld/images/mbtiworld2.png","mbtiworld/images/mbtiworld3.png","mbtiworld/images/mbtiworld4.png","mbtiworld/images/mbtiworld5.png","mbtiworld/images/mbtiworld6.png","mbtiworld/images/mbtiworld7.png","mbtiworld/images/mbtiworld8.png","mbtiworld/images/mbtiworld9.png","mbtiworld/images/mbtiworld10.png"],"path":"/portfolios/MBTI WORLD/","tags":null,"date":"2021-02-19T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보 처리 기사 실기 3-단답형 문제(3)","images":["images/1.jpg"],"path":"/2020 정보 처리 기사 실기 3-단답형 문제(3)/","tags":["정보처리기사 실기","정보처리기사","정처기"],"date":"2020-10-25T09:22:00000Z","summary":"2020 정보 처리 기사 실기 3-단답형 문제(3)입니다 정처기 공부를 할 때 활용하세요"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보 처리 기사 실기 4-단답형 문제(4)","images":["images/1.jpg"],"path":"/2020 정보 처리 기사 실기 4-단답형 문제(4)/","tags":["정보처리기사 실기","정보처리기사","정처기"],"date":"2020-10-15T09:24:00000Z","summary":"2020 정보 처리 기사 실기 4-단답형 문제(4)입니다 정처기 공부를 할 때 활용하세요"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보 처리 기사 실기 2-단답형 문제(2)","images":["images/1.jpg"],"path":"/2020 정보 처리 기사 실기 2-단답형 문제(2)/","tags":["정보처리기사 실기","정보처리기사","정처기"],"date":"2020-10-15T09:21:00000Z","summary":"2020 정보 처리 기사 실기 2-단답형 문제(2)입니다 정처기 공부를 할 때 활용하세요"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보 처리 기사 실기 1-단답형 문제(1)","images":["images/1.jpg"],"path":"/2020 정보 처리 기사 실기 1-단답형 문제(1)/","tags":["정보처리기사 실기","정보처리기사","정처기"],"date":"2020-10-14T16:21:00000Z","summary":"2020 정보 처리 기사 실기 1-단답형 문제(1)입니다 정처기 공부를 할 때 활용하세요"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보 처리 기사 실기 5-정보 관련 용어 정리","images":["images/1.jpg"],"path":"/2020 정보 처리 기사 실기 5-정보 관련 용어 정리/","tags":["정보처리기사 실기","정보처리기사","정처기"],"date":"2020-10-14T02:21:00.000Z","summary":"2020 정보 처리 기사 실기 5-정보 용어 정리 요약 입니다. 정처기 공부를 할 때 활용하세요."}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(3)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(3)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-05-03T01:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(3)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(2)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(2)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-05-02T01:00:00.000Z","summary":"응용 SW 기초 기술 활용"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(1)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(1)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-05-01T01:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(5)-프로그래밍 언어 활용(1)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(3)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(3)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-04-03T03:05:00.000Z","summary":"정보시스템 구축 관리"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(2)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(2)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-04-02T03:05:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(2)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(1)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(1)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-04-01T03:05:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(4)-정보시스템 구축 관리(1)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(3)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(3)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-03-03T02:01:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(3)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(2)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(2)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-03-02T02:01:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(2)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(1)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(1)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-03-01T02:01:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(3)-소프트웨어 설계(1)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(3)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(3)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-02-03T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(3)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(2)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(2)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-02-02T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(2)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(1)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(1)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-02-01T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(2)-소프트웨어 개발(1)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(3)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(3)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-01-03T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(3)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(2)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(2)/","tags":["정보처리기사 필기","정보처리기사"],"date":"2020-01-02T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(2)"}}},{"node":{"frontmatter":{"type":null,"title":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(1)","images":["images/2.jpg"],"path":"/2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(1)/","tags":["정보처리기사 필기","정보처리기사","필기","데이터베이스 구축"],"date":"2020-01-01T05:00:00.000Z","summary":"2020 정보처리기사 필기 요점 정리(1)-데이터베이스 구축(1)"}}},{"node":{"frontmatter":{"type":"portfolio","title":"CAPTURE BLOG","images":["CaptureBlog/images/capture1.png","CaptureBlog/images/capture2.png","CaptureBlog/images/capture3.png","CaptureBlog/images/capture4.png","CaptureBlog/images/capture5.png","CaptureBlog/images/capture6.png"],"path":"/portfolios/CAPTURE BLOG/","tags":null,"date":"2020-01-01T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"portfolio","title":"LANGUAGE TOGETHER","images":["languageTogether/images/languagetogether.png","languageTogether/images/languagetogether2.png","languageTogether/images/languagetogether3.png","languageTogether/images/languagetogether4.png","languageTogether/images/languagetogether5.png","languageTogether/images/languagetogether6.png","languageTogether/images/languagetogether7.png","languageTogether/images/languagetogether8.png","languageTogether/images/languagetogether9.png"],"path":"/portfolios/LANGUAGE TOGETHER/","tags":null,"date":"2018-01-01T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"portfolio","title":"MOVIE STAR","images":["moviestar/images/moviestar.png","moviestar/images/moviestar2.png","moviestar/images/moviestar3.png","moviestar/images/moviestar4.png"],"path":"/portfolios/MOVIE STAR/","tags":null,"date":"2018-01-01T00:00:00.000Z","summary":null}}},{"node":{"frontmatter":{"type":"resume","title":"Resume","images":null,"path":"/resume/","tags":null,"date":"2000-01-01T00:00:00.000Z","summary":null}}}]}},"pageContext":{}}}